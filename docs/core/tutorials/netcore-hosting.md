---
title: Hébergement de .NET Core
description: Hébergement du runtime .NET Core à partir du code natif
author: mjrousos
ms.author: mairaw
ms.date: 2/3/2017
ms.topic: conceptual
ms.prod: dotnet-core
ms.devlang: dotnet
ms.workload:
- dotnetcore
ms.openlocfilehash: e09c849699bed63f0a271dfeede1e9e4b66e716f
ms.sourcegitcommit: 03ee570f6f528a7d23a4221dcb26a9498edbdf8c
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/28/2018
---
# <a name="hosting-net-core"></a><span data-ttu-id="3c7cf-103">Hébergement de .NET Core</span><span class="sxs-lookup"><span data-stu-id="3c7cf-103">Hosting .NET Core</span></span>

<span data-ttu-id="3c7cf-104">Comme tout code managé, les applications .NET Core sont exécutées par un hôte.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-104">Like all managed code, .NET Core applications are executed by a host.</span></span> <span data-ttu-id="3c7cf-105">L’hôte est chargé du démarrage du runtime (y compris des composants comme le JIT et le récupérateur de mémoire), de la création de domaines d’application et de l’appel de points d’entrée managés.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-105">The host is responsible for starting the runtime (including components like the JIT and garbage collector), creating AppDomains, and invoking managed entry points.</span></span>

<span data-ttu-id="3c7cf-106">L’hébergement du runtime .NET Core est un scénario avancé et, dans la plupart des cas, les développeurs .NET Core n’ont pas à se soucier de l’hébergement, car les processus de génération .NET Core fournissent un hôte par défaut pour exécuter les applications .NET Core.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-106">Hosting the .NET Core runtime is an advanced scenario and, in most cases, .NET Core developers don't need to worry about hosting because .NET Core build processes provide a default host to run .NET Core applications.</span></span> <span data-ttu-id="3c7cf-107">Toutefois, dans certains cas spécifiques, il peut être utile d’héberger explicitement le runtime .NET Core, pour appeler le code managé dans un processus natif ou pour mieux contrôler le fonctionnement du runtime.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-107">In some specialized circumstances, though, it can be useful to explicitly host the .NET Core runtime, either as a means of invoking managed code in a native process or in order to gain more control over how the runtime works.</span></span>

<span data-ttu-id="3c7cf-108">Cet article donne une vue d’ensemble des étapes nécessaires pour démarrer le runtime .NET Core à partir du code natif, créer un domaine d’application initial (<xref:System.AppDomain>) et y exécuter du code managé.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-108">This article gives an overview of the steps necessary to start the .NET Core runtime from native code, create an initial application domain (<xref:System.AppDomain>), and execute managed code in it.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="3c7cf-109">Prérequis</span><span class="sxs-lookup"><span data-stu-id="3c7cf-109">Prerequisites</span></span>

<span data-ttu-id="3c7cf-110">Comme les hôtes sont des applications natives, ce didacticiel aborde la construction d’une application C++ pour héberger .NET Core.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-110">Because hosts are native applications, this tutorial will cover constructing a C++ application to host .NET Core.</span></span> <span data-ttu-id="3c7cf-111">Vous avez besoin d’un environnement de développement C++ (comme celui fourni par [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-111">You will need a C++ development environment (such as that provided by [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span></span>

<span data-ttu-id="3c7cf-112">Vous avez également besoin d’une application .NET Core simple pour tester l’hôte, vous devez donc installer le [SDK .NET Core](https://www.microsoft.com/net/core) et [créer une petite application de test .NET Core](../../core/tutorials/with-visual-studio.md) (par exemple, une application « Hello World »).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-112">You will also want a simple .NET Core application to test the host with, so you should install the [.NET Core SDK](https://www.microsoft.com/net/core) and [build a small .NET Core test app](../../core/tutorials/with-visual-studio.md) (such as a 'Hello World' app).</span></span> <span data-ttu-id="3c7cf-113">L’application « Hello World » créée par le nouveau modèle de projet de console .NET Core est suffisante.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-113">The 'Hello World' app created by the new .NET Core console project template is sufficient.</span></span>

<span data-ttu-id="3c7cf-114">Ce didacticiel et son exemple associé génèrent un hôte Windows, mais nous vous recommandons de consulter les remarques à la fin de cet article concernant l’hébergement sur Unix.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-114">This tutorial and its associated sample build a Windows host; see the notes at the end of this article about hosting on Unix.</span></span>

## <a name="creating-the-host"></a><span data-ttu-id="3c7cf-115">Création de l'hôte</span><span class="sxs-lookup"><span data-stu-id="3c7cf-115">Creating the host</span></span>

<span data-ttu-id="3c7cf-116">Un [exemple d’hôte](https://github.com/dotnet/samples/tree/master/core/hosting) illustrant les étapes décrites dans cet article est disponible dans le dépôt GitHub dotnet/samples.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-116">A [sample host](https://github.com/dotnet/samples/tree/master/core/hosting) demonstrating the steps outlined in this article is available in the dotnet/samples GitHub repository.</span></span> <span data-ttu-id="3c7cf-117">Les commentaires du fichier *host.cpp* de l’exemple associent clairement les étapes numérotées de ce didacticiel à l’endroit où elles sont exécutées dans l’exemple.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-117">Comments in the sample's *host.cpp* file clearly associate the numbered steps from this tutorial with where they're performed in the sample.</span></span> <span data-ttu-id="3c7cf-118">Pour obtenir des instructions de téléchargement, consultez [Exemples et didacticiels](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-118">For download instructions, see [Samples and Tutorials](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).</span></span>

<span data-ttu-id="3c7cf-119">N’oubliez pas que l’exemple d’hôte est destiné à être utilisé dans un contexte d’apprentissage, il ne s’attarde donc pas sur la vérification des erreurs et privilégie la lisibilité par rapport à l’efficacité.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-119">Keep in mind that the sample host is meant to be used for learning purposes, so it is light on error checking and is designed to emphasize readability over efficiency.</span></span> <span data-ttu-id="3c7cf-120">D’autres exemples d’hôtes réels sont disponibles dans le dépôt [dotnet/coreclr](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-120">More real-world host samples are available in the [dotnet/coreclr](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts) repository.</span></span> <span data-ttu-id="3c7cf-121">L’[hôte CoreRun](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/corerun), en particulier, est un bon exemple d’hôte généraliste à étudier après avoir parcouru l’exemple simple.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-121">The [CoreRun host](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/corerun), in particular, is a good general-purpose host to study after reading through the simpler sample.</span></span>

### <a name="a-note-about-mscoreeh"></a><span data-ttu-id="3c7cf-122">Remarque concernant mscoree.h</span><span class="sxs-lookup"><span data-stu-id="3c7cf-122">A note about mscoree.h</span></span>
<span data-ttu-id="3c7cf-123">L’interface d’hébergement .NET Core principale (`ICLRRuntimeHost2`) est définie dans [MSCOREE. IDL](https://github.com/dotnet/coreclr/blob/master/src/inc/MSCOREE.IDL).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-123">The primary .NET Core hosting interface (`ICLRRuntimeHost2`) is defined in [MSCOREE.IDL](https://github.com/dotnet/coreclr/blob/master/src/inc/MSCOREE.IDL).</span></span> <span data-ttu-id="3c7cf-124">Une version d’en-tête de ce fichier (mscoree.h), que votre hôte doit référencer, est produite via MIDL pendant la génération du [runtime .NET Core](https://github.com/dotnet/coreclr/).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-124">A header version of this file (mscoree.h), which your host will need to reference, is produced via MIDL when the [.NET Core runtime](https://github.com/dotnet/coreclr/) is built.</span></span> <span data-ttu-id="3c7cf-125">Si vous ne voulez pas générer le runtime .NET Core, mscoree.h est également disponible sous forme d’[en-tête prédéfini](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc) dans le dépôt dotnet/coreclr.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-125">If you do not want to build the .NET Core runtime, mscoree.h is also available as a [pre-built header](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc) in the dotnet/coreclr repository.</span></span> <span data-ttu-id="3c7cf-126">Des [instructions pour la génération du runtime .NET Core](https://github.com/dotnet/coreclr#building-the-repository) se trouvent dans le dépôt GitHub correspondant.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-126">[Instructions on building the .NET Core runtime](https://github.com/dotnet/coreclr#building-the-repository) can be found in its GitHub repository.</span></span> 

### <a name="step-1---identify-the-managed-entry-point"></a><span data-ttu-id="3c7cf-127">Étape 1 : Identifier le point d’entrée managé</span><span class="sxs-lookup"><span data-stu-id="3c7cf-127">Step 1 - Identify the managed entry point</span></span>
<span data-ttu-id="3c7cf-128">Après avoir référencé les en-têtes nécessaires ([mscoree.h](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc/mscoree.h) et stdio.h, par exemple), l’une des premières choses que doit faire un hôte .NET Core est de localiser le point d’entrée managé à utiliser.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-128">After referencing necessary headers ([mscoree.h](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc/mscoree.h) and stdio.h, for example), one of the first things a .NET Core host must do is locate the managed entry point it will be using.</span></span> <span data-ttu-id="3c7cf-129">Dans notre exemple d’hôte, il suffit de prendre le premier argument de ligne de commande de notre hôte comme chemin d’un fichier binaire managé dont la méthode `main` doit être exécutée.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-129">In our sample host, this is done by just taking the first command line argument to our host as the path to a managed binary whose `main` method will be executed.</span></span>

[!code-cpp[NetCoreHost#1](../../../samples/core/hosting/host.cpp#1)]

### <a name="step-2---find-and-load-coreclrdll"></a><span data-ttu-id="3c7cf-130">Étape 2 : Rechercher et charger CoreCLR.dll</span><span class="sxs-lookup"><span data-stu-id="3c7cf-130">Step 2 - Find and load CoreCLR.dll</span></span>
<span data-ttu-id="3c7cf-131">Les API du runtime .NET Core se trouvent dans *CoreCLR.dll* (sur Windows).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-131">The .NET Core runtime APIs are in *CoreCLR.dll* (on Windows).</span></span> <span data-ttu-id="3c7cf-132">Pour obtenir l’interface d’hébergement (`ICLRRuntimeHost2`), vous devez rechercher et charger *CoreCLR.dll*.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-132">To get our hosting interface (`ICLRRuntimeHost2`), it's necessary to find and load *CoreCLR.dll*.</span></span> <span data-ttu-id="3c7cf-133">C’est à l’hôte de définir une convention de recherche de *CoreCLR.dll*.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-133">It is up to the host to define a convention for how it will locate *CoreCLR.dll*.</span></span> <span data-ttu-id="3c7cf-134">Certains hôtes s’attendent à trouver le fichier dans un emplacement connu sur l’ordinateur (par exemple, %programfiles%\dotnet\shared\Microsoft.NETCore.App\1.1.0).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-134">Some hosts expect the file to be present in a well-known machine-wide location (such as %programfiles%\dotnet\shared\Microsoft.NETCore.App\1.1.0).</span></span> <span data-ttu-id="3c7cf-135">D’autres considèrent que *CoreCLR.dll* est chargé à partir d’un emplacement à côté de l’ordinateur lui-même ou de l’application à héberger.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-135">Others expect that *CoreCLR.dll* will be loaded from a location next to either the host itself or the app to be hosted.</span></span> <span data-ttu-id="3c7cf-136">D’autres encore peuvent consulter une variable d’environnement pour rechercher la bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-136">Still others might consult an environment variable to find the library.</span></span>

<span data-ttu-id="3c7cf-137">Sur Linux ou Mac, la bibliothèque de runtime principale est *libcoreclr.so* ou *libcoreclr.dylib*, respectivement.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-137">On Linux or Mac, the core runtime library is *libcoreclr.so* or *libcoreclr.dylib*, respectively.</span></span>

<span data-ttu-id="3c7cf-138">Notre exemple d’hôte effectue la recherche dans certains emplacements courants pour *CoreCLR.dll*.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-138">Our sample host probes a few common locations for *CoreCLR.dll*.</span></span> <span data-ttu-id="3c7cf-139">Une fois le fichier trouvé, il doit être chargé via `LoadLibrary` (ou `dlopen` sur Linux/Mac).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-139">Once found, it must be loaded via `LoadLibrary` (or `dlopen` on Linux/Mac).</span></span>

[!code-cpp[NetCoreHost#2](../../../samples/core/hosting/host.cpp#2)]

### <a name="step-3---get-an-iclrruntimehost2-instance"></a><span data-ttu-id="3c7cf-140">Étape 3 : Obtenir une instance de ICLRRuntimeHost2</span><span class="sxs-lookup"><span data-stu-id="3c7cf-140">Step 3 - Get an ICLRRuntimeHost2 Instance</span></span>
<span data-ttu-id="3c7cf-141">L’interface d’hébergement `ICLRRuntimeHost2` est récupérée en appelant `GetProcAddress` (ou `dlsym` sur Linux/Mac) sur `GetCLRRuntimeHost`, puis en appelant cette fonction.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-141">The `ICLRRuntimeHost2` hosting interface is retrieved by calling `GetProcAddress` (or `dlsym` on Linux/Mac) on `GetCLRRuntimeHost`, and then invoking that function.</span></span> 

[!code-cpp[NetCoreHost#3](../../../samples/core/hosting/host.cpp#3)]

### <a name="step-4---setting-startup-flags-and-starting-the-runtime"></a><span data-ttu-id="3c7cf-142">Étape 4 : Définir des indicateurs de démarrage et démarrer le runtime</span><span class="sxs-lookup"><span data-stu-id="3c7cf-142">Step 4 - Setting startup flags and starting the runtime</span></span>
<span data-ttu-id="3c7cf-143">Avec une interface `ICLRRuntimeHost2`, nous pouvons maintenant spécifier des indicateurs de démarrage pour le runtime et le démarrer.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-143">With an `ICLRRuntimeHost2` in-hand, we can now specify runtime-wide startup flags and start the runtime.</span></span> <span data-ttu-id="3c7cf-144">Les indicateurs de démarrage déterminent le récupérateur de mémoire à utiliser (concurrent ou serveur), s’il faut utiliser un ou plusieurs domaines d’application et la stratégie d’optimisation de chargeur à utiliser (pour le chargement d’assemblys indépendant du domaine).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-144">Startup flags will determine which garbage collector (GC) to use (concurrent or server), whether we will use a single AppDomain or multiple AppDomains, and what loader optimization policy to use (for domain-neutral loading of assemblies).</span></span>

[!code-cpp[NetCoreHost#4](../../../samples/core/hosting/host.cpp#4)]

<span data-ttu-id="3c7cf-145">Le runtime est démarré par un appel à la fonction `Start`.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-145">The runtime is started with a call to the `Start` function.</span></span>

```C++
hr = runtimeHost->Start();
```

### <a name="step-5---preparing-appdomain-settings"></a><span data-ttu-id="3c7cf-146">Étape 5 : Préparer les paramètres AppDomain</span><span class="sxs-lookup"><span data-stu-id="3c7cf-146">Step 5 - Preparing AppDomain settings</span></span>
<span data-ttu-id="3c7cf-147">Une fois le runtime démarré, nous devons configurer un AppDomain.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-147">Once the runtime is started, we will want to set up an AppDomain.</span></span> <span data-ttu-id="3c7cf-148">Il existe un certain nombre d’options qui doivent être spécifiées pendant la création d’un AppDomain .NET, vous devez donc d’abord les préparer.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-148">There are a number of options that must be specified when creating a .NET AppDomain, however, so it's necessary to prepare those first.</span></span>

<span data-ttu-id="3c7cf-149">Les indicateurs AppDomain spécifient le comportement des domaines d’application en relation avec la sécurité et l’interopérabilité.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-149">AppDomain flags specify AppDomain behaviors related to security and interop.</span></span> <span data-ttu-id="3c7cf-150">Les anciens hôtes Silverlight utilisaient ces paramètres pour isoler le code utilisateur dans un bac à sable (sandbox), mais la plupart des hôtes .NET Core modernes exécutent le code utilisateur avec une confiance totale et activent l’interopérabilité.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-150">Older Silverlight hosts used these settings to sandbox user code, but most modern .NET Core hosts run user code as full trust and enable interop.</span></span>

[!code-cpp[NetCoreHost#5](../../../samples/core/hosting/host.cpp#5)]

<span data-ttu-id="3c7cf-151">Une fois que vous avez choisi les indicateurs AppDomain à utiliser, vous devez définir les propriétés AppDomain.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-151">After deciding which AppDomain flags to use, AppDomain properties must be defined.</span></span> <span data-ttu-id="3c7cf-152">Les propriétés sont des paires de chaînes clé/valeur.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-152">The properties are key/value pairs of strings.</span></span> <span data-ttu-id="3c7cf-153">La plupart des propriétés gèrent la façon dont l’AppDomain charge les assemblys.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-153">Many of the properties relate to how the AppDomain will load assemblies.</span></span>

<span data-ttu-id="3c7cf-154">Propriétés AppDomain courantes :</span><span class="sxs-lookup"><span data-stu-id="3c7cf-154">Common AppDomain properties include:</span></span>

* <span data-ttu-id="3c7cf-155">`TRUSTED_PLATFORM_ASSEMBLIES` Il s’agit d’une liste de chemins d’assemblys (séparés par « ; » sur Windows et « : » sur Unix) que l’AppDomain doit charger par ordre de priorité et à qui il doit accorder une confiance totale (même dans les domaines partiellement approuvés).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-155">`TRUSTED_PLATFORM_ASSEMBLIES` This is a list of assembly paths (delimited by ';' on Windows and ':' on Unix) which the AppDomain should prioritize loading and give full trust to (even in partially-trusted domains).</span></span> <span data-ttu-id="3c7cf-156">Cette liste doit contenir des assemblys « Framework » et d’autres modules approuvés, similaires au Global Assembly Cache dans les scénarios .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-156">This list is meant to contain 'Framework' assemblies and other trusted modules, similar to the GAC in .NET Framework scenarios.</span></span> <span data-ttu-id="3c7cf-157">Certains hôtes placent toutes les bibliothèques à côté de *coreclr.dll* dans cette liste, d’autres ont des manifestes codés en dur qui répertorient les assemblys de confiance qui les concernent.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-157">Some hosts will put any library next to *coreclr.dll* on this list, others have hard-coded manifests listing trusted assemblies for their purposes.</span></span>
* <span data-ttu-id="3c7cf-158">`APP_PATHS` Il s’agit d’une liste de chemins où rechercher un assembly s’il est introuvable dans la liste TPA (liste d’assemblys de plateforme sécurisée).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-158">`APP_PATHS` This is a list of paths to probe in for an assembly if it can't be found in the trusted platform assemblies (TPA) list.</span></span> <span data-ttu-id="3c7cf-159">Ces chemins doivent correspondre à l’emplacement des assemblys d’utilisateurs.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-159">These paths are meant to be the locations where users' assemblies can be found.</span></span> <span data-ttu-id="3c7cf-160">Dans un AppDomain bac à sable (sandbox), les assemblys chargés à partir de ces chemins ne reçoivent qu’une confiance partielle.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-160">In a sandboxed AppDomain, assemblies loaded from these paths will only be granted partial trust.</span></span> <span data-ttu-id="3c7cf-161">Les chemins APP_PATH courants sont notamment le chemin à partir duquel l’application cible a été chargée ou d’autres emplacements où se trouvent généralement les ressources de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-161">Common APP_PATH paths include the path the target app was loaded from or other locations where user assets are known to live.</span></span>
*  <span data-ttu-id="3c7cf-162">`APP_NI_PATHS` Cette liste est très similaire à APP_PATHS, sauf qu’il s’agit de chemins où rechercher des images natives.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-162">`APP_NI_PATHS` This list is very similar to APP_PATHS except that it's meant to be paths that will be probed for native images.</span></span>
*  <span data-ttu-id="3c7cf-163">`NATIVE_DLL_SEARCH_DIRECTORIES` Cette propriété est une liste de chemins où le chargeur doit rechercher les DLL natives appelées via p/invoke.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-163">`NATIVE_DLL_SEARCH_DIRECTORIES` This property is a list of paths the loader should probe when looking for native DLLs called via p/invoke.</span></span>
*  <span data-ttu-id="3c7cf-164">`PLATFORM_RESOURCE_ROOTS` Cette liste inclut des chemins où rechercher les assemblys satellites de ressources (dans les sous-répertoires spécifiques de la culture).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-164">`PLATFORM_RESOURCE_ROOTS` This list includes paths to probe in for resource satellite assemblies (in culture-specific sub-directories).</span></span>
*  <span data-ttu-id="3c7cf-165">`AppDomainCompatSwitch` Cette chaîne spécifie les particularités de compatibilité qui doivent être utilisées pour les assemblys sans moniker de framework cible explicite (attribut de niveau assembly indiquant le framework dans lequel doit s’exécuter un assembly).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-165">`AppDomainCompatSwitch` This string specifies which compatibility quirks should be used for assemblies without an explicit Target Framework Moniker (an assembly-level attribute indicating which Framework an assembly is meant to run against).</span></span> <span data-ttu-id="3c7cf-166">En général, elle doit être définie sur `"UseLatestBehaviorWhenTFMNotSpecified"`, mais certains hôtes peuvent préférer obtenir d’anciennes particularités de compatibilité Silverlight ou Windows Phone à la place.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-166">Typically, this should be set to `"UseLatestBehaviorWhenTFMNotSpecified"` but some hosts may prefer to get older Silverlight or Windows Phone compatibility quirks, instead.</span></span>

<span data-ttu-id="3c7cf-167">Dans notre [exemple d’hôte simple](https://github.com/dotnet/samples/tree/master/core/hosting), ces propriétés sont configurées de la façon suivante :</span><span class="sxs-lookup"><span data-stu-id="3c7cf-167">In our [simple sample host](https://github.com/dotnet/samples/tree/master/core/hosting), these properties are set up as follows:</span></span>

[!code-cpp[NetCoreHost#6](../../../samples/core/hosting/host.cpp#6)]

### <a name="step-6---create-the-appdomain"></a><span data-ttu-id="3c7cf-168">Étape 6 : Créer l’AppDomain</span><span class="sxs-lookup"><span data-stu-id="3c7cf-168">Step 6 - Create the AppDomain</span></span>
<span data-ttu-id="3c7cf-169">Une fois que tous les indicateurs et les propriétés AppDomain sont prêts, `ICLRRuntimeHost2::CreateAppDomainWithManager` peut être utilisé pour configurer l’AppDomain.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-169">Once all AppDomain flags and properties are prepared, `ICLRRuntimeHost2::CreateAppDomainWithManager` can be used to set up the AppDomain.</span></span> <span data-ttu-id="3c7cf-170">Cette fonction prend éventuellement un nom d’assembly complet et un nom de type à utiliser comme gestionnaire AppDomain du domaine.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-170">This function optionally takes a fully qualified assembly name and type name to use as the domain's AppDomain manager.</span></span> <span data-ttu-id="3c7cf-171">Un gestionnaire AppDomain peut permettre à un hôte de contrôler certains aspects du comportement de l’AppDomain et peut fournir des points d’entrée pour le lancement du code managé si l’hôte ne souhaite pas directement appeler le code utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-171">An AppDomain manager can allow a host to control some aspects of AppDomain behavior and may provide entry points for launching managed code if the host doesn't intend to invoke user code directly.</span></span>   

[!code-cpp[NetCoreHost#7](../../../samples/core/hosting/host.cpp#7)]

### <a name="step-7---run-managed-code"></a><span data-ttu-id="3c7cf-172">Étape 7 : Exécuter le code managé.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-172">Step 7 - Run managed code!</span></span>
<span data-ttu-id="3c7cf-173">Avec un AppDomain opérationnel, l’hôte peut maintenant exécuter du code managé.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-173">With an AppDomain up and running, the host can now start executing managed code.</span></span> <span data-ttu-id="3c7cf-174">Le moyen le plus simple consiste à utiliser `ICLRRuntimeHost2::ExecuteAssembly` pour appeler la méthode de point d’entrée d’un assembly managé.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-174">The easiest way to do this is to use `ICLRRuntimeHost2::ExecuteAssembly` to invoke a managed assembly's entry point method.</span></span> <span data-ttu-id="3c7cf-175">Notez que cette fonction n’est valide que dans les scénarios de domaine unique.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-175">Note that this function only works in single-domain scenarios.</span></span>

[!code-cpp[NetCoreHost#8](../../../samples/core/hosting/host.cpp#8)]

<span data-ttu-id="3c7cf-176">Si `ExecuteAssembly` ne répond pas aux besoins de l’hôte, une autre option consiste à utiliser `CreateDelegate` pour créer un pointeur de fonction vers une méthode managée statique.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-176">Another option, if `ExecuteAssembly` doesn't meet your host's needs, is to use `CreateDelegate` to create a function pointer to a static managed method.</span></span> <span data-ttu-id="3c7cf-177">Cette option implique que l’hôte connaisse la signature de la méthode qu’il appelle (afin de créer le type de pointeur de fonction), mais donne aux hôtes la possibilité d’appeler du code autre qu’un point d’entrée d’assembly.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-177">This requires the host to know the signature of the method it is calling into (in order to create the function pointer type) but allows hosts the flexibility to invoke code other than an assembly's entry point.</span></span>

```C++
void *pfnDelegate = NULL;
hr = runtimeHost->CreateDelegate(
  domainId,
  L"HW, Version=1.0.0.0, Culture=neutral",  // Target managed assembly
  L"ConsoleApplication.Program",            // Target managed type
  L"Main",                                  // Target entry point (static method)
  (INT_PTR*)&pfnDelegate);

((MainMethodFp*)pfnDelegate)(NULL);
```

### <a name="step-8---clean-up"></a><span data-ttu-id="3c7cf-178">Étape 8 : Nettoyer</span><span class="sxs-lookup"><span data-stu-id="3c7cf-178">Step 8 - Clean up</span></span>
<span data-ttu-id="3c7cf-179">Enfin, l’hôte doit effectuer un nettoyage en déchargeant les domaines d’application, en arrêtant le runtime et en libérant la référence `ICLRRuntimeHost2`.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-179">Finally, the host should clean up after itself by unloading AppDomains, stopping the runtime, and releasing the `ICLRRuntimeHost2` reference.</span></span>

[!code-cpp[NetCoreHost#9](../../../samples/core/hosting/host.cpp#9)]

## <a name="about-hosting-net-core-on-unix"></a><span data-ttu-id="3c7cf-180">À propos de l’hébergement de .NET Core sur Unix</span><span class="sxs-lookup"><span data-stu-id="3c7cf-180">About Hosting .NET Core on Unix</span></span>
<span data-ttu-id="3c7cf-181">.NET Core est un produit multiplateforme qui s’exécute sur les systèmes d’exploitation Windows, Linux et Mac.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-181">.NET Core is a cross-platform product, running on Windows, Linux, and Mac operating systems.</span></span> <span data-ttu-id="3c7cf-182">Toutefois, les hôtes étant des applications natives, ils diffèrent les uns des autres selon la plateforme dont ils sont issus.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-182">As native applications, though, hosts for different platforms will have some differences between them.</span></span> <span data-ttu-id="3c7cf-183">Le processus, décrit ci-dessus, d’utilisation de `ICLRRuntimeHost2` pour démarrer le runtime, créer un AppDomain et exécuter le code managé doit fonctionner sur n’importe quel système d’exploitation pris en charge.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-183">The process described above of using `ICLRRuntimeHost2` to start the runtime, create an AppDomain, and execute managed code, should work on any supported operating system.</span></span> <span data-ttu-id="3c7cf-184">Toutefois, les interfaces définies dans mscoree.h peuvent être lourdes à utiliser sur les plateformes Unix, car mscoree fait de nombreuses hypothèses Win32.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-184">However, the interfaces defined in mscoree.h can be cumbersome to work with on Unix platforms since mscoree makes many Win32 assumptions.</span></span>

<span data-ttu-id="3c7cf-185">Pour faciliter l’hébergement sur les plateformes Unix, un ensemble de wrappers d’API d’hébergement plus indépendant de la plateforme est disponible dans [coreclrhost.h](https://github.com/dotnet/coreclr/blob/master/src/coreclr/hosts/inc/coreclrhost.h).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-185">To make hosting on Unix platforms easier, a set of more platform-neutral hosting API wrappers are available in [coreclrhost.h](https://github.com/dotnet/coreclr/blob/master/src/coreclr/hosts/inc/coreclrhost.h).</span></span>

<span data-ttu-id="3c7cf-186">Un exemple d’utilisation de coreclrhost.h (au lieu de mscoree.h directement) peut être consulté dans l’[hôte UnixCoreRun](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-186">An example of using coreclrhost.h (instead of mscoree.h directly) can be seen in the [UnixCoreRun host](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts).</span></span> <span data-ttu-id="3c7cf-187">La procédure d’utilisation des API de coreclrhost.h pour héberger le runtime est semblable à celle de mscoree.h :</span><span class="sxs-lookup"><span data-stu-id="3c7cf-187">The steps to use the APIs from coreclrhost.h to host the runtime are similar to the steps when using mscoree.h:</span></span>

1. <span data-ttu-id="3c7cf-188">Identifier le code managé à exécuter (à partir des paramètres de la ligne de commande, par exemple).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-188">Identify the managed code to execute (from command line parameters, for example).</span></span> 
2. <span data-ttu-id="3c7cf-189">Charger la bibliothèque CoreCLR.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-189">Load the CoreCLR library.</span></span>
    1. `dlopen("./libcoreclr.so", RTLD_NOW | RTLD_LOCAL);` 
3. <span data-ttu-id="3c7cf-190">Obtenir des pointeurs de fonction vers les fonctions `coreclr_initialize`, `coreclr_create_delegate`, `coreclr_execute_assembly` et `coreclr_shutdown` de CoreCLR à l’aide de `dlsym`</span><span class="sxs-lookup"><span data-stu-id="3c7cf-190">Get function pointers to CoreCLR's `coreclr_initialize`, `coreclr_create_delegate`, `coreclr_execute_assembly`, and `coreclr_shutdown` functions using `dlsym`</span></span>
    1. `coreclr_initialize_ptr coreclr_initialize = (coreclr_initialize_ptr)dlsym(coreclrLib, "coreclr_initialize");`
4. <span data-ttu-id="3c7cf-191">Configurer les propriétés AppDomain (par exemple, la liste TPA).</span><span class="sxs-lookup"><span data-stu-id="3c7cf-191">Set up AppDomain properties (such as the TPA list).</span></span> <span data-ttu-id="3c7cf-192">C’est la même étape que l’étape 5 du flux de travail mscoree, ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-192">This is the same as step 5 from the mscoree workflow, above.</span></span>
5. <span data-ttu-id="3c7cf-193">Utiliser `coreclr_initialize` pour démarrer le runtime et créer un AppDomain.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-193">Use `coreclr_initialize` to start the runtime and create an AppDomain.</span></span> <span data-ttu-id="3c7cf-194">Cette étape permet de créer également un pointeur `hostHandle` à utiliser dans les futurs appels d’hébergement.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-194">This will also create a `hostHandle` pointer that will be used in future hosting calls.</span></span>
    1. <span data-ttu-id="3c7cf-195">Notez que cette fonction exécute les rôles des étapes 4 et 6 du flux de travail précédent.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-195">Note that this function performs the roles of both steps 4 and 6 from the previous workflow.</span></span> 
6. <span data-ttu-id="3c7cf-196">Utiliser `coreclr_execute_assembly` ou `coreclr_create_delegate` pour exécuter le code managé.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-196">Use either `coreclr_execute_assembly` or `coreclr_create_delegate` to execute managed code.</span></span> <span data-ttu-id="3c7cf-197">Ces fonctions sont analogues aux fonctions `ExecuteAssembly` et `CreateDelegate` de mscoree de l’étape 7 du flux de travail précédent.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-197">These functions are analogous to mscoree's `ExecuteAssembly` and `CreateDelegate` functions from step 7 of the previous workflow.</span></span>
7. <span data-ttu-id="3c7cf-198">Utiliser `coreclr_shutdown` pour décharger l’AppDomain et arrêter le runtime.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-198">Use `coreclr_shutdown` to unload the AppDomain and shut down the runtime.</span></span> 

## <a name="conclusion"></a><span data-ttu-id="3c7cf-199">Conclusion</span><span class="sxs-lookup"><span data-stu-id="3c7cf-199">Conclusion</span></span>
<span data-ttu-id="3c7cf-200">Une fois que votre hôte est créé, il peut être testé en l’exécutant à partir de la ligne de commande et en passant n’importe quel argument (comme l’application managée à exécuter) que l’hôte attend.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-200">Once your host is built, it can be tested by running it from the command line and passing any arguments (like the managed app to run) the host expects.</span></span> <span data-ttu-id="3c7cf-201">Quand vous spécifiez l’application .NET Core que l’hôte doit exécuter, utilisez le fichier .dll généré par `dotnet build`.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-201">When specifying the .NET Core app for the host to run, be sure to use the .dll that is produced by `dotnet build`.</span></span> <span data-ttu-id="3c7cf-202">Les fichiers exécutables générés par `dotnet publish` pour les applications autonomes sont l’hôte .NET Core par défaut (pour que l’application puisse être lancée directement à partir de la ligne de commande dans les scénarios principaux) ; le code utilisateur est compilé dans un fichier dll du même nom.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-202">Executables produced by `dotnet publish` for self-contained applications are actually the default .NET Core host (so that the app can be launched directly from the command line in mainline scenarios); user code is compiled into a dll of the same name.</span></span> 

<span data-ttu-id="3c7cf-203">Si vous n’obtenez pas les résultats attendus, vérifiez que *coreclr.dll* est disponible dans l’emplacement attendu par l’hôte, que toutes les bibliothèques Framework nécessaires sont dans la liste TPA et que le nombre de bits de CoreCLR (32 ou 64 bits) correspond au mode de génération de l’hôte.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-203">If things don't work initially, double-check that *coreclr.dll* is available in the location expected by the host, that all necessary Framework libraries are in the TPA list, and that CoreCLR's bitness (32- or 64-bit) matches how the host was built.</span></span>

<span data-ttu-id="3c7cf-204">L’hébergement du runtime .NET Core est un scénario avancé sans utilité pour un grand nombre de développeurs, mais qui peut être très utile pour ceux qui doivent lancer du code managé à partir d’un processus natif ou qui ont besoin de davantage de contrôle sur le comportement du runtime .NET Core.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-204">Hosting the .NET Core runtime is an advanced scenario that many developers won't require, but for those who need to launch managed code from a native process, or who need more control over the .NET Core runtime's behavior, it can be very useful.</span></span> <span data-ttu-id="3c7cf-205">Comme .NET Core est capable de s’exécuter côte à côte avec lui-même, il est même possible de créer des hôtes qui initialisent et démarrent plusieurs versions du runtime .NET Core et exécutent des applications sur chacun d'eux dans le même processus.</span><span class="sxs-lookup"><span data-stu-id="3c7cf-205">Because .NET Core is able to run side-by-side with itself, it's even possible to create hosts which initialize and start multiple versions of the .NET Core runtime and execute apps on all of them in the same process.</span></span> 
