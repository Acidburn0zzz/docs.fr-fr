---
title: Thread de synchronisation (Visual Basic) | Documents Microsoft
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-visual-basic
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- VB
ms.assetid: 04f485d1-8333-4510-9e72-c334e7427e7e
caps.latest.revision: 3
author: dotnet-bot
ms.author: dotnetcontent
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
ms.translationtype: Machine Translation
ms.sourcegitcommit: 9f5b8ebb69c9206ff90b05e748c64d29d82f7a16
ms.openlocfilehash: 240937905254120f777ce140049084279c35005c
ms.contentlocale: fr-fr
ms.lasthandoff: 04/12/2017

---
# <a name="thread-synchronization-visual-basic"></a><span data-ttu-id="681b3-102">Synchronisation de threads (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="681b3-102">Thread Synchronization (Visual Basic)</span></span>
<span data-ttu-id="681b3-103">Les sections suivantes décrivent les fonctionnalités et les classes qui peuvent être utilisés pour synchroniser l’accès aux ressources dans les applications multithread.</span><span class="sxs-lookup"><span data-stu-id="681b3-103">The following sections describe features and classes that can be used to synchronize access to resources in multithreaded applications.</span></span>  
  
 <span data-ttu-id="681b3-104">Un des avantages de l’utilisation de plusieurs threads dans une application est que chaque thread s’exécute de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="681b3-104">One of the benefits of using multiple threads in an application is that each thread executes asynchronously.</span></span> <span data-ttu-id="681b3-105">Pour les applications Windows, ainsi, les tâches longues à exécuter en arrière-plan pendant que la fenêtre d’application et les contrôles restent réactives.</span><span class="sxs-lookup"><span data-stu-id="681b3-105">For Windows applications, this allows time-consuming tasks to be performed in the background while the application window and controls remain responsive.</span></span> <span data-ttu-id="681b3-106">Pour serveur d’applications, le multithreading fournit la capacité de gérer chaque requête entrante avec un thread différent.</span><span class="sxs-lookup"><span data-stu-id="681b3-106">For server applications, multithreading provides the ability to handle each incoming request with a different thread.</span></span> <span data-ttu-id="681b3-107">Sinon, chaque nouvelle demande ne serait pas prise en charge jusqu'à ce que la demande précédente avait été entièrement satisfaite.</span><span class="sxs-lookup"><span data-stu-id="681b3-107">Otherwise, each new request would not get serviced until the previous request had been fully satisfied.</span></span>  
  
 <span data-ttu-id="681b3-108">Toutefois, la nature asynchrone des threads a pour conséquence que l’accès aux ressources telles que les handles de fichiers, les connexions réseau et la mémoire doit être coordonnée.</span><span class="sxs-lookup"><span data-stu-id="681b3-108">However, the asynchronous nature of threads means that access to resources such as file handles, network connections, and memory must be coordinated.</span></span> <span data-ttu-id="681b3-109">Sinon, deux ou plusieurs threads peuvent accéder à la même ressource en même temps, chacun ignorant les actions des autres.</span><span class="sxs-lookup"><span data-stu-id="681b3-109">Otherwise, two or more threads could access the same resource at the same time, each unaware of the other's actions.</span></span> <span data-ttu-id="681b3-110">Le résultat est une altération des données imprévisibles.</span><span class="sxs-lookup"><span data-stu-id="681b3-110">The result is unpredictable data corruption.</span></span>  
  
 <span data-ttu-id="681b3-111">Pour les opérations simples sur les types de données numériques intégraux, synchronisation des threads peut se faire avec les membres de la <xref:System.Threading.Interlocked>classe.</xref:System.Threading.Interlocked></span><span class="sxs-lookup"><span data-stu-id="681b3-111">For simple operations on integral numeric data types, synchronizing threads can be accomplished with members of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="681b3-112">Pour toutes les autres données types et les ressources non thread-safe, le multithreading ne peuvent être en toute sécurité effectuées à l’aide de constructions dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="681b3-112">For all other data types and non thread-safe resources, multithreading can only be safely performed using the constructs in this topic.</span></span>  
  
 <span data-ttu-id="681b3-113">Pour des informations générales sur la programmation multithread, consultez :</span><span class="sxs-lookup"><span data-stu-id="681b3-113">For background information on multithreaded programming, see:</span></span>  
  
-   [<span data-ttu-id="681b3-114">Principes fondamentaux du Threading managé</span><span class="sxs-lookup"><span data-stu-id="681b3-114">Managed Threading Basics</span></span>](http://msdn.microsoft.com/library/b2944911-0e8f-427d-a8bb-077550618935)  
  
-   [<span data-ttu-id="681b3-115">Utilisation des Threads et du Threading</span><span class="sxs-lookup"><span data-stu-id="681b3-115">Using Threads and Threading</span></span>](http://msdn.microsoft.com/library/9b5ec2cd-121b-4d49-b075-222cf26f2344)  
  
-   [<span data-ttu-id="681b3-116">Meilleures pratiques pour le Threading managé</span><span class="sxs-lookup"><span data-stu-id="681b3-116">Managed Threading Best Practices</span></span>](http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557)  
  
## <a name="the-lock-and-synclock-keywords"></a><span data-ttu-id="681b3-117">Les mots-clés lock et SyncLock</span><span class="sxs-lookup"><span data-stu-id="681b3-117">The lock and SyncLock Keywords</span></span>  
 <span data-ttu-id="681b3-118">Visual Basic `SyncLock` instruction peut être utilisée pour garantir qu’un bloc de code s’exécute jusqu'à son achèvement sans interruption par d’autres threads.</span><span class="sxs-lookup"><span data-stu-id="681b3-118">The Visual Basic `SyncLock` statement can be used to ensure that a block of code runs to completion without interruption by other threads.</span></span> <span data-ttu-id="681b3-119">Cela s’effectue en obtenant un verrou à exclusion mutuelle pour un objet donné pour la durée du bloc de code.</span><span class="sxs-lookup"><span data-stu-id="681b3-119">This is accomplished by obtaining a mutual-exclusion lock for a given object for the duration of the code block.</span></span>  
  
 <span data-ttu-id="681b3-120">Un `SyncLock` instruction Obtient un objet comme argument et est suivie d’un bloc de code qui doit être exécutée par un seul thread à la fois.</span><span class="sxs-lookup"><span data-stu-id="681b3-120">A `SyncLock` statement is given an object as an argument, and is followed by a code block that is to be executed by only one thread at a time.</span></span> <span data-ttu-id="681b3-121">Exemple :</span><span class="sxs-lookup"><span data-stu-id="681b3-121">For example:</span></span>  
  
```vb  
Public Class TestThreading  
    Dim lockThis As New Object  
  
    Public Sub Process()  
        SyncLock lockThis  
            ' Access thread-sensitive resources.  
        End SyncLock  
    End Sub  
End Class  
```  
  
 <span data-ttu-id="681b3-122">L’argument fourni pour le `SyncLock` mot clé doit être un objet basé sur un type référence et est utilisé pour définir l’étendue du verrou.</span><span class="sxs-lookup"><span data-stu-id="681b3-122">The argument provided to the `SyncLock` keyword must be an object based on a reference type, and is used to define the scope of the lock.</span></span> <span data-ttu-id="681b3-123">Dans l’exemple ci-dessus, la portée de verrouillage est limitée à cette fonction car aucune référence à l’objet `lockThis` existe en dehors de la fonction.</span><span class="sxs-lookup"><span data-stu-id="681b3-123">In the example above, the lock scope is limited to this function because no references to the object `lockThis` exist outside the function.</span></span> <span data-ttu-id="681b3-124">Si une telle référence existait, portée de verrouillage s’étendrait à cet objet.</span><span class="sxs-lookup"><span data-stu-id="681b3-124">If such a reference did exist, lock scope would extend to that object.</span></span> <span data-ttu-id="681b3-125">En principe, l’objet fourni est utilisé uniquement pour identifier de manière unique la ressource qui est partagée par plusieurs threads, afin d’être une instance de la classe arbitraire.</span><span class="sxs-lookup"><span data-stu-id="681b3-125">Strictly speaking, the object provided is used solely to uniquely identify the resource being shared among multiple threads, so it can be an arbitrary class instance.</span></span> <span data-ttu-id="681b3-126">Dans la pratique, toutefois, cet objet représente généralement la ressource pour le thread qui la synchronisation est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="681b3-126">In practice, however, this object usually represents the resource for which thread synchronization is necessary.</span></span> <span data-ttu-id="681b3-127">Par exemple, si un objet conteneur doit être utilisé par plusieurs threads, puis le conteneur peut être passé pour verrouiller, et le bloc de code synchronisé suivant le verrouillage accéderait au conteneur.</span><span class="sxs-lookup"><span data-stu-id="681b3-127">For example, if a container object is to be used by multiple threads, then the container can be passed to lock, and the synchronized code block following the lock would access the container.</span></span> <span data-ttu-id="681b3-128">Tant que les autres threads sont verrouillés sur le même contenir avant d’y accéder, en toute sécurité l’accès à l’objet est synchronisé.</span><span class="sxs-lookup"><span data-stu-id="681b3-128">As long as other threads locks on the same contain before accessing it, then access to the object is safely synchronized.</span></span>  
  
 <span data-ttu-id="681b3-129">En général, il est préférable d’éviter le verrouillage sur un `public` type, ou sur des instances d’objet du contrôle de votre application.</span><span class="sxs-lookup"><span data-stu-id="681b3-129">Generally, it is best to avoid locking on a `public` type, or on object instances beyond the control of your application.</span></span> <span data-ttu-id="681b3-130">Par exemple, `lockThis` peut être problématique si l’instance est accessible au public, car le code en dehors de votre contrôle risque de verrouiller l’objet.</span><span class="sxs-lookup"><span data-stu-id="681b3-130">For example, `lockThis` can be problematic if the instance can be accessed publicly, because code beyond your control may lock on the object as well.</span></span> <span data-ttu-id="681b3-131">Cela pourrait créer une situation de blocage où deux ou plusieurs threads attendent la libération du même objet.</span><span class="sxs-lookup"><span data-stu-id="681b3-131">This could create deadlock situations where two or more threads wait for the release of the same object.</span></span> <span data-ttu-id="681b3-132">Le verrouillage sur un type de données public, par opposition à un objet, peut entraîner des problèmes pour la même raison.</span><span class="sxs-lookup"><span data-stu-id="681b3-132">Locking on a public data type, as opposed to an object, can cause problems for the same reason.</span></span> <span data-ttu-id="681b3-133">Verrouillage sur des chaînes littérales est particulièrement risqué, car les chaînes littérales sont *stagiaire* par le common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="681b3-133">Locking on literal strings is especially risky because literal strings are *interned* by the common language runtime (CLR).</span></span> <span data-ttu-id="681b3-134">Cela signifie qu’il existe une seule instance d’une chaîne donnée littéral pour l’ensemble du programme, le même objet exact représente le littéral dans tous les domaines d’application, en cours d’exécution sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="681b3-134">This means that there is one instance of any given string literal for the entire program, the exact same object represents the literal in all running application domains, on all threads.</span></span> <span data-ttu-id="681b3-135">Par conséquent, un verrou placé sur une chaîne avec le même contenu n’importe où dans les verrous de processus d’application toutes les instances de cette chaîne dans l’application.</span><span class="sxs-lookup"><span data-stu-id="681b3-135">As a result, a lock placed on a string with the same contents anywhere in the application process locks all instances of that string in the application.</span></span> <span data-ttu-id="681b3-136">Par conséquent, il est préférable de verrouiller un membre privé ou protégé qui n’est pas stagiaire.</span><span class="sxs-lookup"><span data-stu-id="681b3-136">As a result, it is best to lock a private or protected member that is not interned.</span></span> <span data-ttu-id="681b3-137">Certaines classes fournissent des membres spécifiquement pour le verrouillage.</span><span class="sxs-lookup"><span data-stu-id="681b3-137">Some classes provide members specifically for locking.</span></span> <span data-ttu-id="681b3-138">Le <xref:System.Array>type, par exemple, fournit <xref:System.Array.SyncRoot%2A>.</xref:System.Array.SyncRoot%2A> </xref:System.Array></span><span class="sxs-lookup"><span data-stu-id="681b3-138">The <xref:System.Array> type, for example, provides <xref:System.Array.SyncRoot%2A>.</span></span> <span data-ttu-id="681b3-139">De nombreux types de collection fournissent un `SyncRoot` membre.</span><span class="sxs-lookup"><span data-stu-id="681b3-139">Many collection types provide a `SyncRoot` member as well.</span></span>  
  
 <span data-ttu-id="681b3-140">Pour plus d’informations sur la `SyncLock` instruction, consultez les rubriques suivantes :</span><span class="sxs-lookup"><span data-stu-id="681b3-140">For more information about the `SyncLock` statement, see the following topics:</span></span>  
  
-   [<span data-ttu-id="681b3-141">SyncLock (instruction)</span><span class="sxs-lookup"><span data-stu-id="681b3-141">SyncLock Statement</span></span>](../../../../visual-basic/language-reference/statements/synclock-statement.md)  
  
-   @System.Threading.Monitor  
  
## <a name="monitors"></a><span data-ttu-id="681b3-142">Analyses</span><span class="sxs-lookup"><span data-stu-id="681b3-142">Monitors</span></span>  
 <span data-ttu-id="681b3-143">Comme le `SyncLock` (mot clé), les moniteurs empêchent des blocs de code d’être exécutés simultanément par plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="681b3-143">Like the `SyncLock` keyword, monitors prevent blocks of code from simultaneous execution by multiple threads.</span></span> <span data-ttu-id="681b3-144">La <xref:System.Threading.Monitor.Enter%2A>méthode ne permet qu’un seul thread de continuer dans les instructions suivantes ; tous les autres threads sont bloqués jusqu'à ce que le thread d’exécution appelle <xref:System.Threading.Monitor.Exit%2A>.</xref:System.Threading.Monitor.Exit%2A> </xref:System.Threading.Monitor.Enter%2A></span><span class="sxs-lookup"><span data-stu-id="681b3-144">The <xref:System.Threading.Monitor.Enter%2A> method allows one and only one thread to proceed into the following statements; all other threads are blocked until the executing thread calls <xref:System.Threading.Monitor.Exit%2A>.</span></span> <span data-ttu-id="681b3-145">Cela équivaut à l’aide de la `SyncLock` (mot clé).</span><span class="sxs-lookup"><span data-stu-id="681b3-145">This is just like using the `SyncLock` keyword.</span></span> <span data-ttu-id="681b3-146">Exemple :</span><span class="sxs-lookup"><span data-stu-id="681b3-146">For example:</span></span>  
  
```vb  
SyncLock x  
    DoSomething()  
End SyncLock  
```  
  
 <span data-ttu-id="681b3-147">Cela équivaut à :</span><span class="sxs-lookup"><span data-stu-id="681b3-147">This is equivalent to:</span></span>  
  
```vb  
Dim obj As Object = CType(x, Object)  
System.Threading.Monitor.Enter(obj)  
Try  
    DoSomething()  
Finally  
    System.Threading.Monitor.Exit(obj)  
End Try  
```  
  
 <span data-ttu-id="681b3-148">À l’aide de la `SyncLock` mot clé est généralement préférée à l’aide de la <xref:System.Threading.Monitor>classe directement, les deux, car `SyncLock` est plus concis et parce que `SyncLock` assure que le moniteur sous-jacent est libéré, même si le code protégé lève une exception.</xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="681b3-148">Using the `SyncLock` keyword is generally preferred over using the <xref:System.Threading.Monitor> class directly, both because `SyncLock` is more concise, and because `SyncLock` insures that the underlying monitor is released, even if the protected code throws an exception.</span></span> <span data-ttu-id="681b3-149">Cela est effectué avec le `Finally` (mot clé), qui exécute son bloc de code associé, qu’une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="681b3-149">This is accomplished with the `Finally` keyword, which executes its associated code block regardless of whether an exception is thrown.</span></span>  
  
## <a name="synchronization-events-and-wait-handles"></a><span data-ttu-id="681b3-150">Événements de synchronisation et Handles d’attente</span><span class="sxs-lookup"><span data-stu-id="681b3-150">Synchronization Events and Wait Handles</span></span>  
 <span data-ttu-id="681b3-151">À l’aide d’un verrou ou une analyse est utile pour empêcher l’exécution simultanée des blocs de code sensibles aux threads, mais ces constructions ne permettent pas d’un thread de communiquer un événement à un autre.</span><span class="sxs-lookup"><span data-stu-id="681b3-151">Using a lock or monitor is useful for preventing the simultaneous execution of thread-sensitive blocks of code, but these constructs do not allow one thread to communicate an event to another.</span></span> <span data-ttu-id="681b3-152">Cela nécessite *les événements de synchronisation*, qui sont des objets qui ont une des deux États, signalé et non signalé, qui peut être utilisé pour activer et d’interrompre des threads.</span><span class="sxs-lookup"><span data-stu-id="681b3-152">This requires *synchronization events*, which are objects that have one of two states, signaled and un-signaled, that can be used to activate and suspend threads.</span></span> <span data-ttu-id="681b3-153">Threads peuvent être interrompus en étant obligés d’attendre un événement de synchronisation qui n’est pas signalé et peuvent être activés en modifiant l’état de l’événement signalé.</span><span class="sxs-lookup"><span data-stu-id="681b3-153">Threads can be suspended by being made to wait on a synchronization event that is unsignaled, and can be activated by changing the event state to signaled.</span></span> <span data-ttu-id="681b3-154">Si un thread tente d’attendre un événement qui est déjà signalé, le thread continue de s’exécuter sans délai.</span><span class="sxs-lookup"><span data-stu-id="681b3-154">If a thread attempts to wait on an event that is already signaled, then the thread continues to execute without delay.</span></span>  
  
 <span data-ttu-id="681b3-155">Il existe deux types d’événements de synchronisation : <xref:System.Threading.AutoResetEvent>et <xref:System.Threading.ManualResetEvent>.</xref:System.Threading.ManualResetEvent> </xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="681b3-155">There are two kinds of synchronization events: <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="681b3-156">Ils diffèrent uniquement dans cette <xref:System.Threading.AutoResetEvent>modifications d’état signalé à non signalé automatiquement à chaque fois qu’il active un thread.</xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="681b3-156">They differ only in that <xref:System.Threading.AutoResetEvent> changes from signaled to unsignaled automatically any time it activates a thread.</span></span> <span data-ttu-id="681b3-157">À l’inverse, un <xref:System.Threading.ManualResetEvent>permet à n’importe quel nombre de threads pour être activé que par leur état signalé et revient à un non signalé état lorsque son <xref:System.Threading.EventWaitHandle.Reset%2A>méthode est appelée.</xref:System.Threading.EventWaitHandle.Reset%2A> </xref:System.Threading.ManualResetEvent></span><span class="sxs-lookup"><span data-stu-id="681b3-157">Conversely, a <xref:System.Threading.ManualResetEvent> allows any number of threads to be activated by its signaled state, and will only revert to an unsignaled state when its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="681b3-158">Peuvent obliger les threads à attendre les événements en appelant une de ces méthodes d’attente, tel que <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, ou <xref:System.Threading.WaitHandle.WaitAll%2A>.</xref:System.Threading.WaitHandle.WaitAll%2A> </xref:System.Threading.WaitHandle.WaitAny%2A> </xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="681b3-158">Threads can be made to wait on events by calling one of the wait methods, such as <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="681b3-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>oblige le thread d’attente jusqu'à ce qu’un événement unique soit signalé, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName>bloque un thread jusqu'à ce qu’un ou plusieurs événements indiqués soient signalés, et <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName>bloque le thread jusqu'à ce que tous les événements indiqués soient signalés.</xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> </xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName></xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName></span><span class="sxs-lookup"><span data-stu-id="681b3-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> causes the thread to wait until a single event becomes signaled, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> blocks a thread until one or more indicated events become signaled, and <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> blocks the thread until all of the indicated events become signaled.</span></span> <span data-ttu-id="681b3-160">Un événement est signalé lors de sa <xref:System.Threading.EventWaitHandle.Set%2A>méthode est appelée.</xref:System.Threading.EventWaitHandle.Set%2A></span><span class="sxs-lookup"><span data-stu-id="681b3-160">An event becomes signaled when its <xref:System.Threading.EventWaitHandle.Set%2A> method is called.</span></span>  
  
 <span data-ttu-id="681b3-161">Dans l’exemple suivant, un thread est créé et démarré par le `Main` (fonction).</span><span class="sxs-lookup"><span data-stu-id="681b3-161">In the following example, a thread is created and started by the `Main` function.</span></span> <span data-ttu-id="681b3-162">Le nouveau thread attend un événement à l’aide de la <xref:System.Threading.WaitHandle.WaitOne%2A>méthode.</xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="681b3-162">The new thread waits on an event using the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="681b3-163">Le thread est suspendu jusqu'à ce que l’événement soit signalé par le thread principal qui exécute la `Main` (fonction).</span><span class="sxs-lookup"><span data-stu-id="681b3-163">The thread is suspended until the event becomes signaled by the primary thread that is executing the `Main` function.</span></span> <span data-ttu-id="681b3-164">Une fois que l’événement soit signalé, le thread auxiliaire est retourné.</span><span class="sxs-lookup"><span data-stu-id="681b3-164">Once the event becomes signaled, the auxiliary thread returns.</span></span> <span data-ttu-id="681b3-165">Dans ce cas, étant donné que l’événement est uniquement utilisé pour l’activation d’un thread, soit le <xref:System.Threading.AutoResetEvent>ou <xref:System.Threading.ManualResetEvent>classes peuvent être utilisés.</xref:System.Threading.ManualResetEvent> </xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="681b3-165">In this case, because the event is only used for one thread activation, either the <xref:System.Threading.AutoResetEvent> or <xref:System.Threading.ManualResetEvent> classes could be used.</span></span>  
  
```vb  
Imports System.Threading  
  
Module Module1  
    Dim autoEvent As AutoResetEvent  
  
    Sub DoWork()  
        Console.WriteLine("   worker thread started, now waiting on event...")  
        autoEvent.WaitOne()  
        Console.WriteLine("   worker thread reactivated, now exiting...")  
    End Sub  
  
    Sub Main()  
        autoEvent = New AutoResetEvent(False)  
  
        Console.WriteLine("main thread starting worker thread...")  
        Dim t As New Thread(AddressOf DoWork)  
        t.Start()  
  
        Console.WriteLine("main thread sleeping for 1 second...")  
        Thread.Sleep(1000)  
  
        Console.WriteLine("main thread signaling worker thread...")  
        autoEvent.Set()  
    End Sub  
End Module  
```  
  
## <a name="mutex-object"></a><span data-ttu-id="681b3-166">Objet mutex</span><span class="sxs-lookup"><span data-stu-id="681b3-166">Mutex Object</span></span>  
 <span data-ttu-id="681b3-167">A *mutex* est similaire à un moniteur ; elle empêche l’exécution simultanée d’un bloc de code par plusieurs threads simultanément.</span><span class="sxs-lookup"><span data-stu-id="681b3-167">A *mutex* is similar to a monitor; it prevents the simultaneous execution of a block of code by more than one thread at a time.</span></span> <span data-ttu-id="681b3-168">En fait, le nom « mutex » est une forme raccourcie du terme « mutuellement exclusif ».</span><span class="sxs-lookup"><span data-stu-id="681b3-168">In fact, the name "mutex" is a shortened form of the term "mutually exclusive."</span></span> <span data-ttu-id="681b3-169">Toutefois, contrairement aux analyses, un mutex peut être utilisé pour synchroniser des threads de processus.</span><span class="sxs-lookup"><span data-stu-id="681b3-169">Unlike monitors, however, a mutex can be used to synchronize threads across processes.</span></span> <span data-ttu-id="681b3-170">Un mutex est représenté par la <xref:System.Threading.Mutex>classe.</xref:System.Threading.Mutex></span><span class="sxs-lookup"><span data-stu-id="681b3-170">A mutex is represented by the <xref:System.Threading.Mutex> class.</span></span>  
  
 <span data-ttu-id="681b3-171">Synchronisation inter-processus, un mutex est appelé un *mutex nommé* , car il doit être utilisé dans une autre application, et par conséquent, il ne peut pas être partagé au moyen d’une variable globale ou statique.</span><span class="sxs-lookup"><span data-stu-id="681b3-171">When used for inter-process synchronization, a mutex is called a *named mutex* because it is to be used in another application, and therefore it cannot be shared by means of a global or static variable.</span></span> <span data-ttu-id="681b3-172">Il doit disposer d’un nom pour que les deux applications puissent accéder au même objet mutex.</span><span class="sxs-lookup"><span data-stu-id="681b3-172">It must be given a name so that both applications can access the same mutex object.</span></span>  
  
 <span data-ttu-id="681b3-173">Bien qu’un mutex peut être utilisé pour la synchronisation de threads intra-processus, à l’aide <xref:System.Threading.Monitor>est généralement recommandée, car les moniteurs ont été conçus spécifiquement pour le .NET Framework et par conséquent utilisent les ressources plus efficacement.</xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="681b3-173">Although a mutex can be used for intra-process thread synchronization, using <xref:System.Threading.Monitor> is generally preferred, because monitors were designed specifically for the .NET Framework and therefore make better use of resources.</span></span> <span data-ttu-id="681b3-174">En revanche, la <xref:System.Threading.Mutex>classe est un wrapper d’une construction Win32.</xref:System.Threading.Mutex></span><span class="sxs-lookup"><span data-stu-id="681b3-174">In contrast, the <xref:System.Threading.Mutex> class is a wrapper to a Win32 construct.</span></span> <span data-ttu-id="681b3-175">Il est plus puissant qu’un moniteur, un mutex nécessite des transitions d’interopérabilité qui sont plus gourmandes que celles requises par la <xref:System.Threading.Monitor>classe.</xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="681b3-175">While it is more powerful than a monitor, a mutex requires interop transitions that are more computationally expensive than those required by the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="681b3-176">Pour obtenir un exemple de l’utilisation d’un mutex, consultez [les mutex](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2).</span><span class="sxs-lookup"><span data-stu-id="681b3-176">For an example of using a mutex, see [Mutexes](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2).</span></span>  
  
## <a name="interlocked-class"></a><span data-ttu-id="681b3-177">Interlocked (classe)</span><span class="sxs-lookup"><span data-stu-id="681b3-177">Interlocked Class</span></span>  
 <span data-ttu-id="681b3-178">Vous pouvez utiliser les méthodes de la <xref:System.Threading.Interlocked>classe pour éviter les problèmes qui peuvent se produire lorsque plusieurs threads tentent simultanément de mettre à jour ou de comparer une même valeur.</xref:System.Threading.Interlocked></span><span class="sxs-lookup"><span data-stu-id="681b3-178">You can use the methods of the <xref:System.Threading.Interlocked> class to prevent problems that can occur when multiple threads attempt to simultaneously update or compare the same value.</span></span> <span data-ttu-id="681b3-179">Les méthodes de cette classe vous permettent d’en toute sécurité incrément décrémentent, exchange et comparer des valeurs à partir de n’importe quel thread.</span><span class="sxs-lookup"><span data-stu-id="681b3-179">The methods of this class let you safely increment, decrement, exchange, and compare values from any thread.</span></span>  
  
## <a name="readerwriter-locks"></a><span data-ttu-id="681b3-180">Verrous ReaderWriter</span><span class="sxs-lookup"><span data-stu-id="681b3-180">ReaderWriter Locks</span></span>  
 <span data-ttu-id="681b3-181">Dans certains cas, vous souhaiterez verrouiller une ressource uniquement lorsque les données sont écrites et autoriser plusieurs clients à lire simultanément des données ne sont pas actualisées.</span><span class="sxs-lookup"><span data-stu-id="681b3-181">In some cases, you may want to lock a resource only when data is being written and permit multiple clients to simultaneously read data when data is not being updated.</span></span> <span data-ttu-id="681b3-182">La <xref:System.Threading.ReaderWriterLock>classe applique un accès exclusif à une ressource lors de la modification par un thread, mais elle permet un accès non exclusif lors de la lecture de la ressource.</xref:System.Threading.ReaderWriterLock></span><span class="sxs-lookup"><span data-stu-id="681b3-182">The <xref:System.Threading.ReaderWriterLock> class enforces exclusive access to a resource while a thread is modifying the resource, but it allows non-exclusive access when reading the resource.</span></span> <span data-ttu-id="681b3-183">Les verrous ReaderWriter constituent une alternative utile aux verrous exclusifs qui provoquent des autres threads à attendre, même lorsque ces threads n’avez pas besoin de mettre à jour les données.</span><span class="sxs-lookup"><span data-stu-id="681b3-183">ReaderWriter locks are a useful alternative to exclusive locks, which cause other threads to wait, even when those threads do not need to update data.</span></span>  
  
## <a name="deadlocks"></a><span data-ttu-id="681b3-184">Blocages</span><span class="sxs-lookup"><span data-stu-id="681b3-184">Deadlocks</span></span>  
 <span data-ttu-id="681b3-185">Synchronisation de threads est très utile dans les applications multithread, mais le risque de création d’un `deadlock`, où plusieurs threads s’attendent mutuellement et l’application s’arrête.</span><span class="sxs-lookup"><span data-stu-id="681b3-185">Thread synchronization is invaluable in multithreaded applications, but there is always the danger of creating a `deadlock`, where multiple threads are waiting for each other and the application comes to a halt.</span></span> <span data-ttu-id="681b3-186">Un blocage est analogue à une situation dans laquelle automobiles bloquées à un arrêt de quatre processeurs, et chaque personne est en attente pour l’autre passe.</span><span class="sxs-lookup"><span data-stu-id="681b3-186">A deadlock is analogous to a situation in which cars are stopped at a four-way stop and each person is waiting for the other to go.</span></span> <span data-ttu-id="681b3-187">Éviter les verrous mortels est important. la clé est une planification soigneuse.</span><span class="sxs-lookup"><span data-stu-id="681b3-187">Avoiding deadlocks is important; the key is careful planning.</span></span> <span data-ttu-id="681b3-188">Vous pouvez souvent prévoir les situations de blocage par la représentation graphique des applications multithread, avant de commencer le codage.</span><span class="sxs-lookup"><span data-stu-id="681b3-188">You can often predict deadlock situations by diagramming multithreaded applications before you start coding.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="681b3-189">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="681b3-189">See Also</span></span>  
 <span data-ttu-id="681b3-190"><xref:System.Threading.Thread></xref:System.Threading.Thread></span><span class="sxs-lookup"><span data-stu-id="681b3-190"><xref:System.Threading.Thread></span></span>   
 <span data-ttu-id="681b3-191"><xref:System.Threading.WaitHandle.WaitOne%2A></xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="681b3-191"><xref:System.Threading.WaitHandle.WaitOne%2A></span></span>   
 <span data-ttu-id="681b3-192"><xref:System.Threading.WaitHandle.WaitAny%2A></xref:System.Threading.WaitHandle.WaitAny%2A></span><span class="sxs-lookup"><span data-stu-id="681b3-192"><xref:System.Threading.WaitHandle.WaitAny%2A></span></span>   
 <span data-ttu-id="681b3-193"><xref:System.Threading.WaitHandle.WaitAll%2A></xref:System.Threading.WaitHandle.WaitAll%2A></span><span class="sxs-lookup"><span data-stu-id="681b3-193"><xref:System.Threading.WaitHandle.WaitAll%2A></span></span>   
 <span data-ttu-id="681b3-194"><xref:System.Threading.Thread.Join%2A></xref:System.Threading.Thread.Join%2A></span><span class="sxs-lookup"><span data-stu-id="681b3-194"><xref:System.Threading.Thread.Join%2A></span></span>   
 <span data-ttu-id="681b3-195"><xref:System.Threading.Thread.Start%2A></xref:System.Threading.Thread.Start%2A></span><span class="sxs-lookup"><span data-stu-id="681b3-195"><xref:System.Threading.Thread.Start%2A></span></span>   
 <span data-ttu-id="681b3-196"><xref:System.Threading.Thread.Sleep%2A></xref:System.Threading.Thread.Sleep%2A></span><span class="sxs-lookup"><span data-stu-id="681b3-196"><xref:System.Threading.Thread.Sleep%2A></span></span>   
 <span data-ttu-id="681b3-197"><xref:System.Threading.Monitor></xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="681b3-197"><xref:System.Threading.Monitor></span></span>   
 <span data-ttu-id="681b3-198"><xref:System.Threading.Mutex></xref:System.Threading.Mutex></span><span class="sxs-lookup"><span data-stu-id="681b3-198"><xref:System.Threading.Mutex></span></span>   
 <span data-ttu-id="681b3-199"><xref:System.Threading.AutoResetEvent></xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="681b3-199"><xref:System.Threading.AutoResetEvent></span></span>   
 <span data-ttu-id="681b3-200"><xref:System.Threading.ManualResetEvent></xref:System.Threading.ManualResetEvent></span><span class="sxs-lookup"><span data-stu-id="681b3-200"><xref:System.Threading.ManualResetEvent></span></span>   
 <span data-ttu-id="681b3-201"><xref:System.Threading.Interlocked></xref:System.Threading.Interlocked></span><span class="sxs-lookup"><span data-stu-id="681b3-201"><xref:System.Threading.Interlocked></span></span>   
 <span data-ttu-id="681b3-202"><xref:System.Threading.WaitHandle></xref:System.Threading.WaitHandle></span><span class="sxs-lookup"><span data-stu-id="681b3-202"><xref:System.Threading.WaitHandle></span></span>   
 <span data-ttu-id="681b3-203"><xref:System.Threading.EventWaitHandle></xref:System.Threading.EventWaitHandle></span><span class="sxs-lookup"><span data-stu-id="681b3-203"><xref:System.Threading.EventWaitHandle></span></span>   
 <span data-ttu-id="681b3-204"><xref:System.Threading></xref:System.Threading></span><span class="sxs-lookup"><span data-stu-id="681b3-204"><xref:System.Threading></span></span>   
 <span data-ttu-id="681b3-205"><xref:System.Threading.EventWaitHandle.Set%2A></xref:System.Threading.EventWaitHandle.Set%2A></span><span class="sxs-lookup"><span data-stu-id="681b3-205"><xref:System.Threading.EventWaitHandle.Set%2A></span></span>   
<span data-ttu-id="681b3-206"> [Applications multithread (Visual Basic)](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md) </span><span class="sxs-lookup"><span data-stu-id="681b3-206"> [Multithreaded Applications (Visual Basic)](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md) </span></span>  
<span data-ttu-id="681b3-207"> [SyncLock, instruction](../../../../visual-basic/language-reference/statements/synclock-statement.md) </span><span class="sxs-lookup"><span data-stu-id="681b3-207"> [SyncLock Statement](../../../../visual-basic/language-reference/statements/synclock-statement.md) </span></span>  
<span data-ttu-id="681b3-208"> [Mutex](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2) </span><span class="sxs-lookup"><span data-stu-id="681b3-208"> [Mutexes](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2) </span></span>  
 @System.Threading.Monitor   
<span data-ttu-id="681b3-209"> [Opérations verrouillées](http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b) </span><span class="sxs-lookup"><span data-stu-id="681b3-209"> [Interlocked Operations](http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b) </span></span>  
<span data-ttu-id="681b3-210"> [AutoResetEvent](http://msdn.microsoft.com/library/6d39c48d-6b37-4a9b-8631-f2924cfd9c18) </span><span class="sxs-lookup"><span data-stu-id="681b3-210"> [AutoResetEvent](http://msdn.microsoft.com/library/6d39c48d-6b37-4a9b-8631-f2924cfd9c18) </span></span>  
<span data-ttu-id="681b3-211"> [Synchronisation des données pour le Multithreading](http://msdn.microsoft.com/library/b980eb4c-71d5-4860-864a-6dfe3692430a)</span><span class="sxs-lookup"><span data-stu-id="681b3-211"> [Synchronizing Data for Multithreading](http://msdn.microsoft.com/library/b980eb4c-71d5-4860-864a-6dfe3692430a)</span></span>
