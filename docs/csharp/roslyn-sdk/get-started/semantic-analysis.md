---
title: "Bien démarrer avec l’analyse sémantique"
description: "Ce tutoriel fournit une vue d’ensemble de l’utilisation de l’analyse sémantique avec le SDK du compilateur .NET."
author: billwagner
ms.author: wiwagn
ms.date: 02/06/2018
ms.topic: conceptual
ms.prod: .net
ms.devlang: devlang-csharp
ms.custom: mvc
ms.openlocfilehash: 04bd57dfd32a51bf5d7e3a573e34140b0feec90f
ms.sourcegitcommit: 3a96c706e4dbb4667bf3bf37edac9e1666646f93
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/27/2018
---
# <a name="get-started-with-semantic-analysis"></a><span data-ttu-id="8db9a-103">Bien démarrer avec l’analyse sémantique</span><span class="sxs-lookup"><span data-stu-id="8db9a-103">Get started with semantic analysis</span></span>

<span data-ttu-id="8db9a-104">Ce tutoriel suppose que vous êtes familiarisé avec l’API Syntaxe.</span><span class="sxs-lookup"><span data-stu-id="8db9a-104">This tutorial assumes you're familiar with the Syntax API.</span></span> <span data-ttu-id="8db9a-105">L’article [Bien démarrer avec l’analyse syntaxique](syntax-analysis.md) fournit une introduction suffisante.</span><span class="sxs-lookup"><span data-stu-id="8db9a-105">The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction.</span></span>

<span data-ttu-id="8db9a-106">Dans ce tutoriel, vous découvrez les API **Symbole** et **Liaison**.</span><span class="sxs-lookup"><span data-stu-id="8db9a-106">In this tutorial, you explore the **Symbol** and **Binding APIs**.</span></span> <span data-ttu-id="8db9a-107">Ces API fournissent des informations sur la _signification sémantique_ d’un programme.</span><span class="sxs-lookup"><span data-stu-id="8db9a-107">These APIs provide information about the _semantic meaning_ of a program.</span></span> <span data-ttu-id="8db9a-108">Elles vous permettent de poser et de répondre à des questions sur les types représentés par un symbole dans votre programme.</span><span class="sxs-lookup"><span data-stu-id="8db9a-108">They enable you to ask and answer questions about the types represented by any symbol in your program.</span></span>

## <a name="understanding-compilations-and-symbols"></a><span data-ttu-id="8db9a-109">Présentation des compilations et des symboles</span><span class="sxs-lookup"><span data-stu-id="8db9a-109">Understanding Compilations and Symbols</span></span>

<span data-ttu-id="8db9a-110">Au fil de votre utilisation du SDK du compilateur .NET, vous allez mieux comprendre les différences entre l’API Syntaxe et l’API Sémantique.</span><span class="sxs-lookup"><span data-stu-id="8db9a-110">As you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API.</span></span> <span data-ttu-id="8db9a-111">**L’API Syntaxe** vous permet d’examiner la _structure_ d’un programme.</span><span class="sxs-lookup"><span data-stu-id="8db9a-111">The **Syntax API** allows you to look at the _structure_ of a program.</span></span> <span data-ttu-id="8db9a-112">Cependant, des informations plus détaillées sur la sémantique ou la _signification_ d’un programme sont souvent nécessaires.</span><span class="sxs-lookup"><span data-stu-id="8db9a-112">However, often you want richer information about the semantics or _meaning_ of a program.</span></span> <span data-ttu-id="8db9a-113">Si la syntaxe d’un fichier ou d’un extrait de code autonome VB ou C# peut être analysé de façon isolée, cela ne veut pas dire grand-chose de poser des questions comme « quel est le type de cette variable ?» dans le vide.</span><span class="sxs-lookup"><span data-stu-id="8db9a-113">While a loose code file or snippet of VB or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as "what's the type of this variable" in a vacuum.</span></span> <span data-ttu-id="8db9a-114">La signification d’un nom de type peut dépendre de références d’assembly, d’importations d’espaces de noms ou d’autres fichiers de code.</span><span class="sxs-lookup"><span data-stu-id="8db9a-114">The meaning of a type name may be dependent on assembly references, namespace imports, or other code files.</span></span> <span data-ttu-id="8db9a-115">Ces questions sont traitées avec **l’API Sémantique**, plus précisément avec la classe <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8db9a-115">Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class.</span></span>

<span data-ttu-id="8db9a-116">Une instance de <xref:Microsoft.CodeAnalysis.Compilation> est analogue à un projet tel qu’il est vu par le compilateur et représente tout ce qui est nécessaire pour compiler un programme Visual Basic ou C#.</span><span class="sxs-lookup"><span data-stu-id="8db9a-116">An instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program.</span></span> <span data-ttu-id="8db9a-117">La **compilation** comprend l’ensemble des fichiers sources à compiler, les références d’assembly et les options du compilateur.</span><span class="sxs-lookup"><span data-stu-id="8db9a-117">The **compilation** includes the set of source files to be compiled, assembly references, compiler options.</span></span> <span data-ttu-id="8db9a-118">Vous pouvez analyser la signification du code en utilisant toutes les autres informations de ce contexte.</span><span class="sxs-lookup"><span data-stu-id="8db9a-118">You can reason about the meaning of the code using all the other information in this context.</span></span> <span data-ttu-id="8db9a-119">Une <xref:Microsoft.CodeAnalysis.Compilation> vous permet de rechercher des **symboles**, qui sont des entités comme des types, des espaces de noms, des membres et des variables, qui sont référencées par des noms et d’autres expressions.</span><span class="sxs-lookup"><span data-stu-id="8db9a-119">A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to.</span></span> <span data-ttu-id="8db9a-120">Le processus consistant à associer des noms et des expressions à des **symboles** est appelé la **liaison**.</span><span class="sxs-lookup"><span data-stu-id="8db9a-120">The process of associating names and expressions with **Symbols** is called **Binding**.</span></span>

<span data-ttu-id="8db9a-121">Comme <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> est une classe abstraite avec des dérivés spécifiques à un langage.</span><span class="sxs-lookup"><span data-stu-id="8db9a-121">Like <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives.</span></span> <span data-ttu-id="8db9a-122">Quand vous créez une instance de compilation, vous devez appeler une méthode de fabrique sur la classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (ou <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="8db9a-122">When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class.</span></span>

## <a name="querying-symbols"></a><span data-ttu-id="8db9a-123">Interrogation des symboles</span><span class="sxs-lookup"><span data-stu-id="8db9a-123">Querying symbols</span></span>

<span data-ttu-id="8db9a-124">Dans ce tutoriel, vous examinez à nouveau le programme « Hello World ».</span><span class="sxs-lookup"><span data-stu-id="8db9a-124">In this tutorial, you look at the "Hello World" program again.</span></span> <span data-ttu-id="8db9a-125">Cette fois-ci, vous interrogez les symboles du programme pour comprendre quels types ces symboles représentent.</span><span class="sxs-lookup"><span data-stu-id="8db9a-125">This time, you query the symbols in the program to understand what types those symbols represent.</span></span> <span data-ttu-id="8db9a-126">Vous interrogez les types dans un espace de noms et vous découvrez comment trouver les méthodes disponibles sur un type.</span><span class="sxs-lookup"><span data-stu-id="8db9a-126">You query for the types in a namespace, and learn to find the methods available on a type.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="8db9a-127">Les exemples suivants nécessitent que le **SDK du compilateur .NET** soit installé dans le cadre de Visual Studio 2017.</span><span class="sxs-lookup"><span data-stu-id="8db9a-127">The following samples require the **.NET Compiler SDK** installed as part of Visual Studio 2017.</span></span> <span data-ttu-id="8db9a-128">Le SDK du compilateur .NET est le dernier composant facultatif répertorié sous la charge de travail **Développement d’extension Visual Studio**.</span><span class="sxs-lookup"><span data-stu-id="8db9a-128">You can find the .NET Compiler SDK as the last optional component listed under the **Visual Studio extension development** workload.</span></span> <span data-ttu-id="8db9a-129">Les modèles ne sont pas installés sans ce composant.</span><span class="sxs-lookup"><span data-stu-id="8db9a-129">The templates aren't installed without this component.</span></span>

<span data-ttu-id="8db9a-130">Vous trouverez le code complet de cet exemple dans [notre dépôt d’exemples GitHub](https://github.com/dotnet/samples/csharp/roslyn-sdk/SemanticQuickStart).</span><span class="sxs-lookup"><span data-stu-id="8db9a-130">You can see the finished code for this sample in [our GitHub samples repository](https://github.com/dotnet/samples/csharp/roslyn-sdk/SemanticQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="8db9a-131">Les types de l’arborescence de syntaxe utilisent l’héritage pour décrire les différents éléments de syntaxe qui sont valides à différents emplacements du programme.</span><span class="sxs-lookup"><span data-stu-id="8db9a-131">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="8db9a-132">Utiliser ces API signifie souvent effectuer un cast des propriétés ou des membres de collection vers des types dérivés spécifiques.</span><span class="sxs-lookup"><span data-stu-id="8db9a-132">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="8db9a-133">Dans les exemples suivants, l’affectation et les casts sont des instructions distinctes, qui utilisent des variables typées explicitement.</span><span class="sxs-lookup"><span data-stu-id="8db9a-133">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="8db9a-134">Vous pouvez lire le code pour voir les types de retour de l’API et le type à l’exécution des objets retournés.</span><span class="sxs-lookup"><span data-stu-id="8db9a-134">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="8db9a-135">Dans la pratique, il est plus courant d’utiliser des variables typées implicitement et de se baser sur des noms d’API pour décrire le type des objets examinés.</span><span class="sxs-lookup"><span data-stu-id="8db9a-135">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="8db9a-136">Créez un projet C# **Outil d’analyse du code autonome** :</span><span class="sxs-lookup"><span data-stu-id="8db9a-136">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="8db9a-137">Dans Visual Studio, choisissez **Fichier** > **Nouveau** > **Projet** pour afficher la boîte de dialogue Nouveau projet.</span><span class="sxs-lookup"><span data-stu-id="8db9a-137">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="8db9a-138">Sous **Visual C#** > **Extensibilité**, choisissez **Outil d’analyse du code autonome**.</span><span class="sxs-lookup"><span data-stu-id="8db9a-138">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="8db9a-139">Nommez votre projet « **SemanticQuickStart** » et cliquez sur OK.</span><span class="sxs-lookup"><span data-stu-id="8db9a-139">Name your project "**SemanticQuickStart**" and click OK.</span></span>

<span data-ttu-id="8db9a-140">Vous allez analyser le programme simple « Hello World! »</span><span class="sxs-lookup"><span data-stu-id="8db9a-140">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="8db9a-141">montré précédemment.</span><span class="sxs-lookup"><span data-stu-id="8db9a-141">program shown earlier.</span></span>
<span data-ttu-id="8db9a-142">Ajoutez le texte pour le programme Hello World en tant que constante dans votre classe `Program` :</span><span class="sxs-lookup"><span data-stu-id="8db9a-142">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program test](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="8db9a-143">Ensuite, ajoutez le code suivant pour générer l’arborescence de syntaxe pour le texte du code dans la constante `programText`.</span><span class="sxs-lookup"><span data-stu-id="8db9a-143">Next, add the following code to build the syntax tree for the code text in the `programText` constant.</span></span>  <span data-ttu-id="8db9a-144">Ajoutez la ligne suivante à votre méthode `Main` :</span><span class="sxs-lookup"><span data-stu-id="8db9a-144">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="8db9a-145">Ensuite, générez une <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> à partir de l’arborescence que vous avez déjà créée.</span><span class="sxs-lookup"><span data-stu-id="8db9a-145">Next, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created.</span></span> <span data-ttu-id="8db9a-146">L’exemple « Hello World » est basé sur les types <xref:System.String> et <xref:System.Console>.</span><span class="sxs-lookup"><span data-stu-id="8db9a-146">The "Hello World" sample relies on the <xref:System.String> and <xref:System.Console> types.</span></span> <span data-ttu-id="8db9a-147">Vous devez référencer l’assembly qui déclare ces deux types dans votre compilation.</span><span class="sxs-lookup"><span data-stu-id="8db9a-147">You need to reference the assembly that declares those two types in your compilation.</span></span> <span data-ttu-id="8db9a-148">Ajoutez la ligne suivante à votre méthode `Main` pour créer une compilation de votre arborescence de syntaxe, en incluant la référence à l’assembly approprié :</span><span class="sxs-lookup"><span data-stu-id="8db9a-148">Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:</span></span>

[!code-csharp[Create the compilation](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#3 "Create the compilation for the semantic model")]

<span data-ttu-id="8db9a-149">La méthode <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> ajoute des références à la compilation.</span><span class="sxs-lookup"><span data-stu-id="8db9a-149">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation.</span></span> <span data-ttu-id="8db9a-150">La méthode <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)> charge un assembly en tant que référence.</span><span class="sxs-lookup"><span data-stu-id="8db9a-150">The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)> method loads an assembly as a reference.</span></span> 

## <a name="querying-the-semantic-model"></a><span data-ttu-id="8db9a-151">Interrogation du modèle sémantique</span><span class="sxs-lookup"><span data-stu-id="8db9a-151">Querying the semantic model</span></span>

<span data-ttu-id="8db9a-152">Une fois que vous avez une <xref:Microsoft.CodeAnalysis.Compilation>, vous pouvez la demander pour un <xref:Microsoft.CodeAnalysis.SemanticModel> pour n’importe quelle <xref:Microsoft.CodeAnalysis.SyntaxTree> contenue dans <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="8db9a-152">Once you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="8db9a-153">Vous pouvez considérer le modèle sémantique comme étant la source de toutes les informations que vous obtiendriez normalement d’IntelliSense.</span><span class="sxs-lookup"><span data-stu-id="8db9a-153">You can think of the semantic model as the source for all the information would normally get from intellisense.</span></span> <span data-ttu-id="8db9a-154"><xref:Microsoft.CodeAnalysis.SemanticModel> peut répondre à des questions comme « Quels noms se trouvent dans l’étendue à cet emplacement ? »,</span><span class="sxs-lookup"><span data-stu-id="8db9a-154">A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like "What names are in scope at this location?"</span></span> <span data-ttu-id="8db9a-155">« Quels membres sont accessibles à partir de cette méthode ? »,</span><span class="sxs-lookup"><span data-stu-id="8db9a-155">"What members are accessible from this method?"</span></span> <span data-ttu-id="8db9a-156">« Quelles variables sont utilisées dans ce bloc de texte ? »</span><span class="sxs-lookup"><span data-stu-id="8db9a-156">"What variables are used in this block of text?"</span></span> <span data-ttu-id="8db9a-157">et « À quoi ce nom ou cette expression font-ils référence ? ».</span><span class="sxs-lookup"><span data-stu-id="8db9a-157">and "What does this name/expression refer to?"</span></span> <span data-ttu-id="8db9a-158">Ajoutez cette instruction pour créer le modèle sémantique :</span><span class="sxs-lookup"><span data-stu-id="8db9a-158">Add this statement to create the semantic model:</span></span>

[!code-csharp[Create the semantic model](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#4 "Create the semantic model")]

## <a name="binding-a-name"></a><span data-ttu-id="8db9a-159">Liaison d’un nom</span><span class="sxs-lookup"><span data-stu-id="8db9a-159">Binding a name</span></span>

<span data-ttu-id="8db9a-160"><xref:Microsoft.CodeAnalysis.Compilation> crée <xref:Microsoft.CodeAnalysis.SemanticModel> à partir de <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span><span class="sxs-lookup"><span data-stu-id="8db9a-160">The <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="8db9a-161">Après avoir créé le modèle, vous pouvez l’interroger pour rechercher la première directive `using` et récupérer les informations des symboles pour l’espace de noms `System`.</span><span class="sxs-lookup"><span data-stu-id="8db9a-161">After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace.</span></span> <span data-ttu-id="8db9a-162">Ajoutez ces deux lignes à votre méthode `Main` pour créer le modèle sémantique et pour récupérer le symbole pour la première instruction using :</span><span class="sxs-lookup"><span data-stu-id="8db9a-162">Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:</span></span>

[!code-csharp[Find the namespace symbol for the first using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#5 "Find the namespace symbol for the first using")]

<span data-ttu-id="8db9a-163">Le code précédent montre comment obtenir un objet <xref:Microsoft.CodeAnalysis.SemanticModel> pour votre <xref:Microsoft.CodeAnalysis.SyntaxTree> HelloWorld.</span><span class="sxs-lookup"><span data-stu-id="8db9a-163">The preceding code shows how to obtain a <xref:Microsoft.CodeAnalysis.SemanticModel> object for your HelloWorld <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="8db9a-164">Une fois le modèle obtenu, le nom dans la première directive `using` est lié pour récupérer un <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> pour l’espace de noms `System`.</span><span class="sxs-lookup"><span data-stu-id="8db9a-164">Once the model is obtained, the name in the first `using` directive is bound to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace.</span></span> <span data-ttu-id="8db9a-165">Le code précédent montre aussi que vous utilisez le **modèle de syntaxe** pour trouver la structure du code ; vous utilisez le **modèle sémantique** pour comprendre sa signification.</span><span class="sxs-lookup"><span data-stu-id="8db9a-165">The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning.</span></span> <span data-ttu-id="8db9a-166">Le **modèle de syntaxe** recherche la chaîne `System` dans l’instruction using.</span><span class="sxs-lookup"><span data-stu-id="8db9a-166">The **syntax model** finds the string `System` in the using statement.</span></span> <span data-ttu-id="8db9a-167">Le **modèle sémantique** a toutes les informations sur les types définis dans l’espace de noms `System`.</span><span class="sxs-lookup"><span data-stu-id="8db9a-167">The **semantic model** has all the information about the types defined in the `System` namespace.</span></span>

<span data-ttu-id="8db9a-168">À partir de l’objet <xref:Microsoft.CodeAnalysis.SymbolInfo>, vous pouvez obtenir <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> en utilisant la propriété <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8db9a-168">From the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8db9a-169">Cette propriété retourne le symbole auquel cette expression fait référence.</span><span class="sxs-lookup"><span data-stu-id="8db9a-169">This property returns the symbol this expression refers to.</span></span> <span data-ttu-id="8db9a-170">Pour les expressions qui ne font référence à rien (comme les littéraux numériques), cette propriété est `null`.</span><span class="sxs-lookup"><span data-stu-id="8db9a-170">For expressions that don't refer to anything (such as numeric literals) this property is `null`.</span></span> <span data-ttu-id="8db9a-171">Quand <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> n’est pas null, <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> indique le type du symbole.</span><span class="sxs-lookup"><span data-stu-id="8db9a-171">When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol.</span></span> <span data-ttu-id="8db9a-172">Dans cet exemple, la propriété <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> est un <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8db9a-172">In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8db9a-173">Ajoutez le code suivant à votre méthode `Main`.</span><span class="sxs-lookup"><span data-stu-id="8db9a-173">Add the following code to your `Main` method.</span></span> <span data-ttu-id="8db9a-174">Il récupère le symbole pour l’espace de noms `System`, puis affiche tous les espaces de noms enfants déclarés dans l’espace de noms `System` :</span><span class="sxs-lookup"><span data-stu-id="8db9a-174">It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:</span></span>

[!code-csharp[Display all the child namespaces](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#6 "Display all the child namespaces from this compilation")]

<span data-ttu-id="8db9a-175">Exécutez le programme ; vous devez normalement voir la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="8db9a-175">Run the program and you should see the following output:</span></span>

```
Collections
Configuration
Deployment
Diagnostics
Globalization
IO
Reflection
Resources
Runtime
Security
StubHelpers
Text
Threading
Press any key to continue . . .
```

> [!NOTE]
> <span data-ttu-id="8db9a-176">La sortie n’inclut pas chaque espace de noms qui est un espace de noms enfant de l’espace de noms `System`.</span><span class="sxs-lookup"><span data-stu-id="8db9a-176">The output does not include every namespace that is a child namespace of the `System` namespace.</span></span> <span data-ttu-id="8db9a-177">Elle affiche chaque espace de noms qui est présent dans cette compilation, qui référence seulement l’assembly où `System.String` est déclaré.</span><span class="sxs-lookup"><span data-stu-id="8db9a-177">It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared.</span></span> <span data-ttu-id="8db9a-178">Les espaces de noms déclarés dans d’autres assemblys ne sont pas connus de cette compilation.</span><span class="sxs-lookup"><span data-stu-id="8db9a-178">Any namespaces declared in other assemblies are not known to this compilation</span></span>

### <a name="binding-an-expression"></a><span data-ttu-id="8db9a-179">Liaison d’une expression</span><span class="sxs-lookup"><span data-stu-id="8db9a-179">Binding an expression</span></span>

<span data-ttu-id="8db9a-180">Le code précédent montre comment trouver un symbole en le liant à un nom.</span><span class="sxs-lookup"><span data-stu-id="8db9a-180">The preceding code shows how to find a symbol by binding to a name.</span></span> <span data-ttu-id="8db9a-181">D’autres expressions existent dans un programme C# qui peuvent être liées, mais qui ne sont pas des noms.</span><span class="sxs-lookup"><span data-stu-id="8db9a-181">There are other expressions in a C# program that can be bound that aren't names.</span></span> <span data-ttu-id="8db9a-182">Pour montrer cette possibilité, accédons à la liaison vers un littéral de chaîne simple.</span><span class="sxs-lookup"><span data-stu-id="8db9a-182">To demonstrate this capability, let's access the binding to a simple string literal.</span></span>

<span data-ttu-id="8db9a-183">Le programme « Hello World » contient un <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, : la chaîne « Hello, World! »</span><span class="sxs-lookup"><span data-stu-id="8db9a-183">The "Hello World" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the "Hello, World!"</span></span> <span data-ttu-id="8db9a-184">affichée dans la console.</span><span class="sxs-lookup"><span data-stu-id="8db9a-184">string displayed to the console.</span></span>

<span data-ttu-id="8db9a-185">Vous trouvez la chaîne « Hello, World! »</span><span class="sxs-lookup"><span data-stu-id="8db9a-185">You find the "Hello, World!"</span></span> <span data-ttu-id="8db9a-186">en recherchant le seul littéral de chaîne dans le programme.</span><span class="sxs-lookup"><span data-stu-id="8db9a-186">string by locating the single string literal in the program.</span></span> <span data-ttu-id="8db9a-187">Ensuite, une fois que vous avez localisé le nœud de syntaxe, vous obtenez les informations de type pour ce nœud auprès du modèle sémantique.</span><span class="sxs-lookup"><span data-stu-id="8db9a-187">Then, once you've located the syntax node, get the type info for that node from the semantic model.</span></span> <span data-ttu-id="8db9a-188">Ajoutez le code suivant à votre méthode `Main` :</span><span class="sxs-lookup"><span data-stu-id="8db9a-188">Add the following code to your `Main` method:</span></span>

[!code-csharp[Find the namespace symbol for the only using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#7 "Find the namespace symbol for the only using")]

<span data-ttu-id="8db9a-189">La struct <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> inclut une propriété <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> qui permet d’accéder aux informations sémantiques sur le type du littéral.</span><span class="sxs-lookup"><span data-stu-id="8db9a-189">The <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal.</span></span> <span data-ttu-id="8db9a-190">Dans cet exemple, il s’agit du type `string`.</span><span class="sxs-lookup"><span data-stu-id="8db9a-190">In this example, that's the `string` type.</span></span> <span data-ttu-id="8db9a-191">Ajoutez une déclaration qui affecte cette propriété à une variable locale :</span><span class="sxs-lookup"><span data-stu-id="8db9a-191">Add a declaration that assigns this property to a local variable:</span></span>

[!code-csharp[Find the semantic information about the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#8 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="8db9a-192">Pour terminer ce tutoriel, construisons une requête LINQ qui crée une séquence de toutes les méthodes publiques déclarées sur le type `string` qui retournent un type `string`.</span><span class="sxs-lookup"><span data-stu-id="8db9a-192">To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`.</span></span> <span data-ttu-id="8db9a-193">Cette requête est complexe : nous allons donc la construire ligne par ligne, puis la reconstruire pour former une seule requête.</span><span class="sxs-lookup"><span data-stu-id="8db9a-193">This query gets complex, so let's build it line by line, then reconstruct it as a single query.</span></span> <span data-ttu-id="8db9a-194">La source de cette requête est la séquence de tous les membres déclarés sur le type `string` :</span><span class="sxs-lookup"><span data-stu-id="8db9a-194">The source for this query is the sequence of all members declared on the `string` type:</span></span>

[!code-csharp[Access the sequence of members on the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#9 "Access the sequence of members on the string type.")]

<span data-ttu-id="8db9a-195">Cette séquence source contient tous les membres, notamment les propriétés et les champs : filtrez-la donc avec la méthode <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> pour trouver les éléments qui sont des objets <xref:Microsoft.CodeAnalysis.IMethodSymbol?diplayProperty=nameWithType> :</span><span class="sxs-lookup"><span data-stu-id="8db9a-195">That source sequence conatins all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?diplayProperty=nameWithType> objects:</span></span>

[!code-csharp[Filter the sequence to only methods](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#10 "Find the subset of the collection that is the methods.")]

<span data-ttu-id="8db9a-196">Ensuite, ajoutez un autre filtre pour retourner seulement les méthodes qui sont publiques et qui retournent un type `string` :</span><span class="sxs-lookup"><span data-stu-id="8db9a-196">Next, add another filter to return only those methods that are public and return a `string`:</span></span>

[!code-csharp[Filter on return type and accessibility](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#11 "Find only the public methods that return a string.")]

<span data-ttu-id="8db9a-197">Sélectionnez seulement la propriété name et seulement les noms distincts en supprimant les surcharges :</span><span class="sxs-lookup"><span data-stu-id="8db9a-197">Select only the name property, and only distinct names by removing any overloads:</span></span>

[!code-csharp[find the distinct names.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#12 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="8db9a-198">Vous pouvez aussi créer toute la requête avec la syntaxe de requête LINQ, puis afficher tous les noms de méthode dans la console :</span><span class="sxs-lookup"><span data-stu-id="8db9a-198">You can also build the full query using the LINQ query syntax, and then display all the method names in  the console:</span></span>

[!code-csharp[build and display the results of this query.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#12 "Build and display the results of the query.")]

<span data-ttu-id="8db9a-199">Générez et exécutez le programme.</span><span class="sxs-lookup"><span data-stu-id="8db9a-199">Build and run the program.</span></span> <span data-ttu-id="8db9a-200">Vous devez voir la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="8db9a-200">You should see the following output:</span></span>

```
Join
Substring
Trim
TrimStart
TrimEnd
Normalize
PadLeft
PadRight
ToLower
ToLowerInvariant
ToUpper
ToUpperInvariant
ToString
Insert
Replace
Remove
Format
Copy
Concat
Intern
IsInterned
Press any key to continue . . .
```
<span data-ttu-id="8db9a-201">Vous avez utilisé l’API Sémantique pour rechercher et afficher des informations sur les symboles qui font partie de ce programme.</span><span class="sxs-lookup"><span data-stu-id="8db9a-201">You've used the Semantic API to find and display information about the symbols that are part of this program.</span></span>
