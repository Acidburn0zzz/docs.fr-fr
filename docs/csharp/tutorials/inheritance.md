---
title: "Héritage dans C#"
description: "Apprenez à utiliser l’héritage dans les bibliothèques et applications C#."
keywords: "Héritage (C#), classes de base, classes dérivées, classes de base abstraites"
author: rpetrusha
manager: wpickett
ms.author: ronpet
ms.date: 08/16/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: 39de8879fd902c714a58cf59c70f0a4914b2ff6e
ms.sourcegitcommit: 9bee08539b1886c9d57fa3d5bd8a58dfdd7cad94
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/12/2017
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="26388-104">Héritage dans C# et .NET</span><span class="sxs-lookup"><span data-stu-id="26388-104">Inheritance in C# and .NET</span></span>

<span data-ttu-id="26388-105">Ce didacticiel vous présente l’héritage dans C#.</span><span class="sxs-lookup"><span data-stu-id="26388-105">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="26388-106">L’héritage est une fonctionnalité des langages de programmation orientés objet qui vous permet de définir une classe de base qui fournit des fonctionnalités spécifiques (données et comportement) et de définir des classes dérivées qui héritent ou substituent cette fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="26388-106">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="26388-107">Conditions préalables</span><span class="sxs-lookup"><span data-stu-id="26388-107">Prerequisites</span></span>

<span data-ttu-id="26388-108">Ce didacticiel suppose que vous avez installé .NET Core.</span><span class="sxs-lookup"><span data-stu-id="26388-108">This tutorial assumes that you've installed .NET Core.</span></span> <span data-ttu-id="26388-109">Pour des instructions d'installation, consultez le [Guide d’installation de .NET Core](https://www.microsoft.com/net/core).</span><span class="sxs-lookup"><span data-stu-id="26388-109">For installation instructions, see [.NET Core installation guide](https://www.microsoft.com/net/core).</span></span> <span data-ttu-id="26388-110">Il vous faut également un éditeur de code.</span><span class="sxs-lookup"><span data-stu-id="26388-110">You also need a code editor.</span></span> <span data-ttu-id="26388-111">Ce didacticiel utilise [Visual Studio Code](https://code.visualstudio.com), mais vous pouvez utiliser l’éditeur de code de votre choix.</span><span class="sxs-lookup"><span data-stu-id="26388-111">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="26388-112">Exécution des exemples</span><span class="sxs-lookup"><span data-stu-id="26388-112">Running the examples</span></span>

<span data-ttu-id="26388-113">Pour créer et exécuter les exemples de ce didacticiel, vous utilisez l’utilitaire [dotnet](../../core/tools/dotnet.md) en ligne de commande.</span><span class="sxs-lookup"><span data-stu-id="26388-113">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="26388-114">Pour chaque exemple, procédez comme suit :</span><span class="sxs-lookup"><span data-stu-id="26388-114">Follow these steps for each example:</span></span>

1. <span data-ttu-id="26388-115">Créez un répertoire pour stocker l’exemple.</span><span class="sxs-lookup"><span data-stu-id="26388-115">Create a directory to store the example.</span></span>
1. <span data-ttu-id="26388-116">Entrez la commande [dotnet new console](../../core/tools/dotnet-new.md) dans l’invite de commandes pour créer un projet .NET Core.</span><span class="sxs-lookup"><span data-stu-id="26388-116">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="26388-117">Copiez et collez le code de l’exemple dans votre éditeur de code.</span><span class="sxs-lookup"><span data-stu-id="26388-117">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="26388-118">Entrez la commande [dotnet restore](../../core/tools/dotnet-restore.md) à partir de la ligne de commande pour charger ou restaurer les dépendances du projet.</span><span class="sxs-lookup"><span data-stu-id="26388-118">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

  [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="26388-119">Entrez la commande [dotnet run](../../core/tools/dotnet-run.md) pour compiler et exécuter l’exemple.</span><span class="sxs-lookup"><span data-stu-id="26388-119">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>


## <a name="background-what-is-inheritance"></a><span data-ttu-id="26388-120">Présentation : Qu’est-ce que l’héritage ?</span><span class="sxs-lookup"><span data-stu-id="26388-120">Background: What is inheritance?</span></span>

<span data-ttu-id="26388-121">*L’héritage* est un des attributs fondamentaux de la programmation orientée objet.</span><span class="sxs-lookup"><span data-stu-id="26388-121">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="26388-122">Il vous permet de définir une classe enfant qui réutilise (hérite), étend ou modifie le comportement d’une classe parente.</span><span class="sxs-lookup"><span data-stu-id="26388-122">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="26388-123">La classe dont les membres sont hérités s’appelle la *classe de base*.</span><span class="sxs-lookup"><span data-stu-id="26388-123">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="26388-124">La classe qui hérite des membres de la classe de base est appelée la *classe dérivée*.</span><span class="sxs-lookup"><span data-stu-id="26388-124">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="26388-125">C# et .NET prennent uniquement en charge *l’héritage simple*.</span><span class="sxs-lookup"><span data-stu-id="26388-125">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="26388-126">C’est-à-dire qu’une classe ne peut hériter que d'une seule classe.</span><span class="sxs-lookup"><span data-stu-id="26388-126">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="26388-127">Toutefois, l’héritage est transitif, ce qui permet de définir une hiérarchie d’héritage pour un ensemble de types.</span><span class="sxs-lookup"><span data-stu-id="26388-127">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="26388-128">En d’autres termes, le type `D` peut hériter du type `C`, qui hérite du type `B`, qui hérite du type de classe de base `A`.</span><span class="sxs-lookup"><span data-stu-id="26388-128">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="26388-129">Étant donné que l’héritage est transitif, les membres de type `A` sont disponibles pour le type `D`.</span><span class="sxs-lookup"><span data-stu-id="26388-129">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="26388-130">Tous les membres d’une classe de base ne sont pas hérités par les classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="26388-130">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="26388-131">Les membres suivants ne sont pas hérités :</span><span class="sxs-lookup"><span data-stu-id="26388-131">The following members are not inherited:</span></span>

- <span data-ttu-id="26388-132">Les [constructeurs statiques](../programming-guide/classes-and-structs/static-constructors.md), qui initialisent les données statiques d’une classe.</span><span class="sxs-lookup"><span data-stu-id="26388-132">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="26388-133">Les [Constructeurs d’instance](../programming-guide/classes-and-structs/constructors.md), que vous appelez pour créer une nouvelle instance de la classe.</span><span class="sxs-lookup"><span data-stu-id="26388-133">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="26388-134">Chaque classe doit définir ses propres constructeurs.</span><span class="sxs-lookup"><span data-stu-id="26388-134">Each class must define its own constructors.</span></span>

- <span data-ttu-id="26388-135">Les [finaliseurs](../programming-guide/classes-and-structs/destructors.md), qui sont appelés par le récupérateur de mémoire du runtime pour détruire les instances d’une classe.</span><span class="sxs-lookup"><span data-stu-id="26388-135">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="26388-136">Bien que tous les autres membres de classe de base sont hérités par les classes dérivées, leur visibilité dépend de leur accessibilité.</span><span class="sxs-lookup"><span data-stu-id="26388-136">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="26388-137">L’accessibilité d’un membre affecte sa visibilité pour les classes dérivées de la manière suivante :</span><span class="sxs-lookup"><span data-stu-id="26388-137">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="26388-138">Les membres [Privés](../language-reference/keywords/private.md) sont visibles uniquement dans les classes dérivées qui sont imbriquées dans leur classe de base.</span><span class="sxs-lookup"><span data-stu-id="26388-138">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="26388-139">Sinon, ils ne sont pas visibles dans les classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="26388-139">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="26388-140">Dans l’exemple suivant, `A.B` est une classe imbriquée qui dérive de `A`, et `C` dérive de `A`.</span><span class="sxs-lookup"><span data-stu-id="26388-140">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="26388-141">Le champ privé `A.value` est visible dans A.B.</span><span class="sxs-lookup"><span data-stu-id="26388-141">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="26388-142">Toutefois, si vous supprimez les commentaires de la méthode `C.GetValue` et essayez de compiler l’exemple, il génère l’erreur de compilateur CS0122 : « 'A.value est inaccessible en raison de son niveau de protection ».</span><span class="sxs-lookup"><span data-stu-id="26388-142">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="26388-143">Les membres [protégés](../language-reference/keywords/protected.md) sont visibles uniquement dans les classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="26388-143">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="26388-144">Les membres [internes](../language-reference/keywords/internal.md) sont visibles uniquement dans les classes dérivées qui sont trouvent dans le même assembly que la classe de base.</span><span class="sxs-lookup"><span data-stu-id="26388-144">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="26388-145">Ils ne sont pas visibles dans les classes dérivées situées dans un autre assembly à partir de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="26388-145">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="26388-146">Les membres [publics](../language-reference/keywords/public.md) sont visibles dans les classes dérivées et font partie de l’interface publique de la classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="26388-146">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="26388-147">Les membres publics hérités peuvent être appelées comme s’ils étaient définis dans la classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="26388-147">Public inherited members can be called just as if they were defined in the derived class.</span></span> <span data-ttu-id="26388-148">Dans l’exemple suivant, la classe `A` définit une méthode nommée `Method1`, et la classe `B` hérite de la classe `A`.</span><span class="sxs-lookup"><span data-stu-id="26388-148">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="26388-149">L’exemple appelle ensuite `Method1` comme s’il s’agissait d’une méthode d’instance sur `B`.</span><span class="sxs-lookup"><span data-stu-id="26388-149">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="26388-150">Les classes dérivées peuvent également *substituer* les membres hérités en fournissant une implémentation alternative.</span><span class="sxs-lookup"><span data-stu-id="26388-150">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="26388-151">Pour être en mesure de substituer un membre, le membre de la classe de base doit être marqué avec le mot-clé [virtual](../language-reference/keywords/virtual.md).</span><span class="sxs-lookup"><span data-stu-id="26388-151">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="26388-152">Par défaut, les membres de classe de base ne sont pas marqués comme `virtual` et ne peut pas être substitués.</span><span class="sxs-lookup"><span data-stu-id="26388-152">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="26388-153">Une tentative de substituer un membre non virtuel, comme dans l’exemple suivant, génère l’erreur de compilateur CS0506 : « <member> : impossible de substituer le membre hérité <member>, car il n’est pas marqué comme virtual, abstract ou override.</span><span class="sxs-lookup"><span data-stu-id="26388-153">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "<member> cannot override inherited member <member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="26388-154">Dans certains cas, une classe dérivée *doit* remplacer l’implémentation de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="26388-154">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="26388-155">Les membres de classe de base marqués avec le mot-clé [abstract](../language-reference/keywords/abstract.md) requièrent que les classes dérivées les remplacent.</span><span class="sxs-lookup"><span data-stu-id="26388-155">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="26388-156">Compiler l’exemple suivant génère l’erreur de compilateur CS0534, « <class> n’implémente pas le membre abstrait hérité <member>, car la classe `B` ne fournit aucune implémentation de `A.Method1`.</span><span class="sxs-lookup"><span data-stu-id="26388-156">Attempting to compile the following example generates compiler error CS0534, "<class> does not implement inherited abstract member <member>', because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="26388-157">L’héritage s’applique uniquement aux classes et interfaces.</span><span class="sxs-lookup"><span data-stu-id="26388-157">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="26388-158">Les autres catégories de type (structures, délégués et énumérations) ne permettent pas l’héritage.</span><span class="sxs-lookup"><span data-stu-id="26388-158">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="26388-159">Pour cette raison, la tentative de compilation du code suivant suit génère l’erreur de compilateur CS0527 : « Le type 'ValueType' dans la liste des interfaces n’est pas une interface. »</span><span class="sxs-lookup"><span data-stu-id="26388-159">Because of this, attempting to compile code like the following produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="26388-160">Le message d’erreur indique que, même si vous pouvez définir les interfaces qu’implémente un struct, l’héritage n'est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="26388-160">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="26388-161">Héritage implicite</span><span class="sxs-lookup"><span data-stu-id="26388-161">Implicit inheritance</span></span>

<span data-ttu-id="26388-162">Outre les types qui peuvent hériter via l’héritage simple, tous les types dans le système de types de .NET héritent implicitement de <xref:System.Object> ou d’un type dérivé.</span><span class="sxs-lookup"><span data-stu-id="26388-162">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="26388-163">Cela garantit que les fonctionnalités communes sont disponibles pour n’importe quel type.</span><span class="sxs-lookup"><span data-stu-id="26388-163">This ensures that common functionality is available to any type.</span></span>

<span data-ttu-id="26388-164">Pour comprendre ce que l’héritage implicite signifie, nous allons définir une nouvelle classe, `SimpleClass`, qui est simplement une définition de classe vide :</span><span class="sxs-lookup"><span data-stu-id="26388-164">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="26388-165">Nous pouvons ensuite utiliser la réflexion (qui nous permet d’inspecter les métadonnées d’un type pour obtenir des informations sur ce type) pour obtenir la liste des membres qui appartiennent au type `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="26388-165">We can then use reflection (which lets us inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="26388-166">Même si nous n’avons pas défini de membres dans notre classe `SimpleClass`, la sortie de l’exemple indique qu’il a en fait neuf membres.</span><span class="sxs-lookup"><span data-stu-id="26388-166">Although we haven't defined any members in our `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="26388-167">Un d’eux est un constructeur sans paramètre (ou par défaut) qui est fourni automatiquement pour le type `SimpleClass` par le compilateur C#.</span><span class="sxs-lookup"><span data-stu-id="26388-167">One of these is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="26388-168">Les huit restants sont membres de <xref:System.Object>, le type à partir duquel toutes les classes et interfaces du système de type .NET héritent implicitement.</span><span class="sxs-lookup"><span data-stu-id="26388-168">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="26388-169">L’héritage implicite à partir de la classe <xref:System.Object> rend ces méthodes disponibles pour la classe `SimpleClass` :</span><span class="sxs-lookup"><span data-stu-id="26388-169">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="26388-170">La méthode public `ToString`, qui convertit un objet `SimpleClass` en sa représentation de chaîne, retourne le nom de type complet.</span><span class="sxs-lookup"><span data-stu-id="26388-170">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="26388-171">Dans ce cas, la méthode `ToString` retourne la chaîne « SimpleClass ».</span><span class="sxs-lookup"><span data-stu-id="26388-171">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="26388-172">Voici trois méthodes de test d’égalité de deux objets : la méthode public instance `Equals(Object)`, la méthode public static `Equals(Object, Object)` et la méthode public static `ReferenceEquals(Object, Object)`.</span><span class="sxs-lookup"><span data-stu-id="26388-172">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="26388-173">Par défaut, ces méthodes testent l’égalité des références. Autrement dit, pour être égales, deux variables d’objet doivent faire référence au même objet.</span><span class="sxs-lookup"><span data-stu-id="26388-173">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="26388-174">La méthode public `GetHashCode`, qui calcule une valeur qui permet à une instance du type d’être utilisée dans des collections hachées.</span><span class="sxs-lookup"><span data-stu-id="26388-174">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="26388-175">La méthode `GetType` publique qui retourne un objet <xref:System.Type> qui représente le type `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="26388-175">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="26388-176">La méthode protected <xref:System.Object.Finalize%2A>, qui est conçue pour libérer les ressources non gérées avant que la mémoire d’un objet soit récupérée par le récupérateur de mémoire.</span><span class="sxs-lookup"><span data-stu-id="26388-176">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="26388-177">La méthode protected <xref:System.Object.MemberwiseClone%2A>, qui crée un clone partiel de l’objet actuel.</span><span class="sxs-lookup"><span data-stu-id="26388-177">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="26388-178">En raison de l’héritage implicite, nous pouvons appeler n’importe quel membre hérité d’un objet `SimpleClass` exactement comme s’il était en fait un membre défini dans la classe `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="26388-178">Because of implicit inheritance, we can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="26388-179">Par exemple, l’exemple suivant appelle la méthode `SimpleClass.ToString`, dont `SimpleClass` hérite de <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="26388-179">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="26388-180">Le tableau suivant répertorie les catégories de types que vous pouvez créer en C# et les types à partir desquels ils héritent implicitement.</span><span class="sxs-lookup"><span data-stu-id="26388-180">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="26388-181">Chaque type de base apporte un autre ensemble de membres disponibles via l’héritage aux types dérivés implicitement.</span><span class="sxs-lookup"><span data-stu-id="26388-181">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="26388-182">Catégorie de type</span><span class="sxs-lookup"><span data-stu-id="26388-182">Type category</span></span> | <span data-ttu-id="26388-183">Hérite implicitement de</span><span class="sxs-lookup"><span data-stu-id="26388-183">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="26388-184">class</span><span class="sxs-lookup"><span data-stu-id="26388-184">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="26388-185">struct</span><span class="sxs-lookup"><span data-stu-id="26388-185">struct</span></span>        | <span data-ttu-id="26388-186"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="26388-186"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="26388-187">enum</span><span class="sxs-lookup"><span data-stu-id="26388-187">enum</span></span>          | <span data-ttu-id="26388-188"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="26388-188"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="26388-189">délégué</span><span class="sxs-lookup"><span data-stu-id="26388-189">delegate</span></span>      | <span data-ttu-id="26388-190"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="26388-190"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="26388-191">L’héritage et une relation « est un »</span><span class="sxs-lookup"><span data-stu-id="26388-191">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="26388-192">En règle générale, l’héritage est utilisé pour exprimer une relation « est un » entre une classe de base et une ou plusieurs classes dérivées, où les classes dérivées sont des versions spécialisées de la classe de base ; la classe dérivée est un type de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="26388-192">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="26388-193">Par exemple, la classe `Publication` représente une publication de tout type et les classes `Book` et `Magazine` représentent les classes des types spécifiques de publications.</span><span class="sxs-lookup"><span data-stu-id="26388-193">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="26388-194">Les classes et structs peuvent implémenter plusieurs interfaces.</span><span class="sxs-lookup"><span data-stu-id="26388-194">A class or struct can implement one more interfaces.</span></span> <span data-ttu-id="26388-195">Bien que l’implémentation d’interface est souvent présentée comme une solution de contournement pour l’héritage unique ou comme une façon d’utiliser l’héritage avec les structures, elle est conçue pour exprimer une autre relation (« peut faire ») entre une interface et son type d’implémentation que l’héritage.</span><span class="sxs-lookup"><span data-stu-id="26388-195">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="26388-196">Une interface définit un sous-ensemble de fonctionnalités (comme la capacité à tester l’égalité, comparer ou trier des objets, ou pour prendre en charge la mise en forme et l’analyse dépendant de la culture) que l’interface met à disposition pour ses types d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="26388-196">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="26388-197">Notez que « est un » exprime également la relation entre un type et une instanciation spécifique de ce type.</span><span class="sxs-lookup"><span data-stu-id="26388-197">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="26388-198">Dans l’exemple suivant, `Automobile` est une classe qui possède trois propriétés en lecture seule uniques : `Make`, le fabricant de l’automobile ; `Model`, le type de voiture et `Year`, son année de fabrication.</span><span class="sxs-lookup"><span data-stu-id="26388-198">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="26388-199">Notre classe `Automobile` comporte également un constructeur dont les arguments sont assignés aux valeurs de propriété, et elle remplace la méthode <xref:System.Object.ToString%2A?displayProperty=nameWithType> pour générer une chaîne qui identifie de façon unique l’instance `Automobile` plutôt que la classe `Automobile`.</span><span class="sxs-lookup"><span data-stu-id="26388-199">Our `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="26388-200">Dans ce cas, nous ne devrions pas nous reposer sur l’héritage pour représenter les modèles et constructeurs spécifiques.</span><span class="sxs-lookup"><span data-stu-id="26388-200">In this case, we should not rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="26388-201">Par exemple, il est inutile de définir un type `Packard` pour représenter les véhicules automobiles fabriqués par la société Packard Motor Car.</span><span class="sxs-lookup"><span data-stu-id="26388-201">For example, we do not need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="26388-202">Au lieu de cela, nous pouvons les représenter en créant un objet `Automobile` avec les valeurs appropriées passées à son constructeur de classe, comme dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="26388-202">Instead, we can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="26388-203">Une relation « est un » basée sur l’héritage est préférablement appliquée à une classe de base et aux classes dérivées qui ajoutent des membres supplémentaires à la classe de base ou qui nécessitent des fonctionnalités supplémentaires non présentes dans la classe de base.</span><span class="sxs-lookup"><span data-stu-id="26388-203">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="26388-204">Conception de la classe de base et des classes dérivées</span><span class="sxs-lookup"><span data-stu-id="26388-204">Designing the base class and derived classes</span></span>

<span data-ttu-id="26388-205">Examinons le processus de conception d’une classe de base et de ses classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="26388-205">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="26388-206">Dans cette section, nous allons définir une classe de base, `Publication`, qui représente une publication de tout type, comme un livre, un magazine, un journal, une revue, un article, etc. Nous définirons aussi une classe `Book` qui dérive de `Publication`.</span><span class="sxs-lookup"><span data-stu-id="26388-206">In this section, we'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. We'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="26388-207">Nous pourrions facilement étendre l’exemple pour définir d’autres classes dérivées, comme `Magazine`, `Journal`, `Newspaper` et `Article`.</span><span class="sxs-lookup"><span data-stu-id="26388-207">We could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="26388-208">Classe Publication de base</span><span class="sxs-lookup"><span data-stu-id="26388-208">The base Publication class</span></span>

<span data-ttu-id="26388-209">Lors de la conception de notre classe `Publication`, nous devons prendre plusieurs décisions de conception :</span><span class="sxs-lookup"><span data-stu-id="26388-209">In designing our `Publication` class, we need to make several design decisions:</span></span>

- <span data-ttu-id="26388-210">Les membres à inclure dans notre classe de base `Publication` et si les membres `Publication` fournissent des implémentations de méthode, ou si `Publication` est une classe de base abstraite qui sert de modèle pour ses classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="26388-210">What members to include in our base `Publication` class, and whether the `Publication` members provide method implementations, or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="26388-211">Dans ce cas, la classe `Publication` fournit des implémentations de méthode.</span><span class="sxs-lookup"><span data-stu-id="26388-211">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="26388-212">La section [Conception de classes de base abstraites et leurs classes dérivées](#abstract) contient un exemple qui utilise une classe de base abstraite pour définir les méthodes que les classes dérivées doivent substituer.</span><span class="sxs-lookup"><span data-stu-id="26388-212">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="26388-213">Les classes dérivées sont libres de fournir une implémentation qui convient pour le type dérivé.</span><span class="sxs-lookup"><span data-stu-id="26388-213">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="26388-214">La possibilité de réutiliser le code (autrement dit, plusieurs classes dérivées partagent la déclaration et l’implémentation de méthodes de classe de base et n’ont pas besoin de les substituer) constitue un avantage des classes de base non abstraites.</span><span class="sxs-lookup"><span data-stu-id="26388-214">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="26388-215">Par conséquent, nous devons ajouter des membres à `Publication` si leur code est susceptible d’être partagé par certains ou la majorité des types `Publication` spécialisés.</span><span class="sxs-lookup"><span data-stu-id="26388-215">Therefore, we should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="26388-216">Si nous ne le faites pas efficacement, vous devrez fournir des implémentations de membres en grande partie identiques dans les classes dérivées au lieu d’une implémentation unique de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="26388-216">If we fail to do this efficiently, we'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="26388-217">La nécessité de maintenir le code dupliqué à plusieurs emplacements est une source potentielle de bogues.</span><span class="sxs-lookup"><span data-stu-id="26388-217">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="26388-218">Pour optimiser la réutilisation du code et créer une hiérarchie d’héritage logique et intuitive, nous souhaitons nous assurer que nous ajoutons à la classe `Publication` uniquement les données et fonctionnalités communes à toutes les publications ou la plupart d’entre elles.</span><span class="sxs-lookup"><span data-stu-id="26388-218">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, we want to be sure that we include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="26388-219">Les classes dérivées implémentent ensuite les membres qui sont uniques pour les types particuliers de publications qu’ils représentent.</span><span class="sxs-lookup"><span data-stu-id="26388-219">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="26388-220">La mesure dans laquelle étendre notre hiérarchie de classes.</span><span class="sxs-lookup"><span data-stu-id="26388-220">How far to extend our class hierarchy.</span></span> <span data-ttu-id="26388-221">Souhaitons-nous développer une hiérarchie de trois classes ou plus, plutôt que simplement une classe de base et une ou plusieurs classes dérivées ?</span><span class="sxs-lookup"><span data-stu-id="26388-221">Do we want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="26388-222">Par exemple, `Publication` peut être une classe de base de `Periodical`, qui est elle-même une classe de base de `Magazine`, `Journal` et `Newspaper`.</span><span class="sxs-lookup"><span data-stu-id="26388-222">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="26388-223">Dans notre exemple, nous allons utiliser la hiérarchie simple d’une classe `Publication` et d’une classe dérivée unique, `Book`.</span><span class="sxs-lookup"><span data-stu-id="26388-223">For our example, we'll use the simple hierarchy of a `Publication` class and a single derived classes, `Book`.</span></span> <span data-ttu-id="26388-224">Nous pourrions facilement étendre l’exemple pour créer un certain nombre d’autres classes qui dérivent de `Publication`, comme `Magazine` et `Article`.</span><span class="sxs-lookup"><span data-stu-id="26388-224">We could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="26388-225">S’il est judicieux d’instancier la classe de base.</span><span class="sxs-lookup"><span data-stu-id="26388-225">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="26388-226">Si ce n’est pas le cas, nous devons appliquer le mot-clé [abstract](../language-reference/keywords/abstract.md) à la classe.</span><span class="sxs-lookup"><span data-stu-id="26388-226">If it does not, we should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="26388-227">Si une tentative est faite pour instancier une classe marquée avec le mot-clé `abstract` par un appel direct à son constructeur de classe, le compilateur C# génère l’erreur CS0144, « Impossible de créer une instance de la classe ou interface abstraite ».</span><span class="sxs-lookup"><span data-stu-id="26388-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="26388-228">Si une tentative est faite pour instancier la classe à l’aide de la réflexion, la méthode de la réflexion lève une exception <xref:System.MemberAccessException>.</span><span class="sxs-lookup"><span data-stu-id="26388-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span> <span data-ttu-id="26388-229">Dans le cas contraire, notre classe `Publication` peut être instanciée en appelant son constructeur de classe.</span><span class="sxs-lookup"><span data-stu-id="26388-229">Otherwise, our `Publication` class can be instantiated by calling its class constructor.</span></span>

  <span data-ttu-id="26388-230">Par défaut, une classe de base peut être instanciée en appelant son constructeur de classe.</span><span class="sxs-lookup"><span data-stu-id="26388-230">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="26388-231">Notez que nous n’avons pas à définir explicitement un constructeur de classe.</span><span class="sxs-lookup"><span data-stu-id="26388-231">Note that we do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="26388-232">S’il n’y en a aucun présent dans le code source de la classe de base, le compilateur C# fournit automatiquement un constructeur par défaut (sans paramètre).</span><span class="sxs-lookup"><span data-stu-id="26388-232">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="26388-233">Dans notre exemple, nous marquons la classe `Publication` comme [abstract](../language-reference/keywords/abstract.md) afin qu’elle ne puisse pas être instanciée.</span><span class="sxs-lookup"><span data-stu-id="26388-233">For our example, we'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>

- <span data-ttu-id="26388-234">Si les classes dérivées doivent hériter de l’implémentation de classe de base d’un membres particulier, ou si elles ont la possibilité de substituer l’implémentation de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="26388-234">Whether derived classes must inherit the base class implementation of a particular members, or whether they have the option to override the base class implementation.</span></span> <span data-ttu-id="26388-235">Nous devons utiliser le mot-clé [virtual](../language-reference/keywords/virtual.md) pour permettre aux classes dérivées de substituer une méthode de classe de base.</span><span class="sxs-lookup"><span data-stu-id="26388-235">We have to use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="26388-236">Par défaut, les méthodes définies dans la classe de base ne sont *pas* substituables.</span><span class="sxs-lookup"><span data-stu-id="26388-236">By default, methods defined in the base class are *not* overridable.</span></span>

- <span data-ttu-id="26388-237">Si une classe dérivée représente la classe finale dans la hiérarchie d’héritage et ne peut pas elle-même être utilisée comme classe de base pour les classes dérivées supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="26388-237">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="26388-238">Par défaut, toute classe peut servir de classe de base.</span><span class="sxs-lookup"><span data-stu-id="26388-238">By default, any class can serve as a base class.</span></span> <span data-ttu-id="26388-239">Nous pouvons appliquer le mot-clé [sealed](../language-reference/keywords/sealed.md) pour indiquer qu’une classe ne peut pas servir de classe de base pour les classes supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="26388-239">We can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="26388-240">La tentative de dériver à partir d’une classe sealed a généré l’erreur de compilateur CS0509, « impossible de dériver à partir du type sealed <typeName> ».</span><span class="sxs-lookup"><span data-stu-id="26388-240">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type <typeName>".</span></span>

  <span data-ttu-id="26388-241">Dans notre exemple, nous marquons notre classe dérivée en tant que `sealed`.</span><span class="sxs-lookup"><span data-stu-id="26388-241">For our example, we'll mark our derived class as `sealed`.</span></span>

<span data-ttu-id="26388-242">L’exemple suivant montre le code source pour la classe `Publication` ainsi qu’une énumération `PublicationType` retournée par la propriété `Publication.PublicationType`.</span><span class="sxs-lookup"><span data-stu-id="26388-242">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="26388-243">Outre les membres qu’elle hérite de <xref:System.Object>, la classe `Publication` définit les membres uniques et substitutions de membres suivants :</span><span class="sxs-lookup"><span data-stu-id="26388-243">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="26388-244">Un constructeur</span><span class="sxs-lookup"><span data-stu-id="26388-244">A constructor</span></span>

  <span data-ttu-id="26388-245">Étant donné que la classe `Publication` est `abstract`, elle ne peut pas être instanciée directement à partir du code comme dans ce qui suit :</span><span class="sxs-lookup"><span data-stu-id="26388-245">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="26388-246">Toutefois, son constructeur d’instance peut être appelé directement à partir des constructeurs de classes dérivées, comme le code source pour la classe `Book` le montre.</span><span class="sxs-lookup"><span data-stu-id="26388-246">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="26388-247">Deux propriétés liées à la publication</span><span class="sxs-lookup"><span data-stu-id="26388-247">Two publication-related properties</span></span>

  <span data-ttu-id="26388-248">`Title` est une propriété <xref:System.String> en lecture seule dont la valeur est fournie en appelant le constructeur `Publication`.</span><span class="sxs-lookup"><span data-stu-id="26388-248">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="26388-249">`Pages` est une propriété <xref:System.Int32> en lecture seule qui indique le nombre total de pages de la publication.</span><span class="sxs-lookup"><span data-stu-id="26388-249">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="26388-250">La valeur est stockée dans un champ privé nommé `totalPages`.</span><span class="sxs-lookup"><span data-stu-id="26388-250">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="26388-251">Elle doit être positive, sans quoi une exception <xref:System.ArgumentOutOfRangeException> est levée.</span><span class="sxs-lookup"><span data-stu-id="26388-251">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="26388-252">Membres liés à l’éditeur</span><span class="sxs-lookup"><span data-stu-id="26388-252">Publisher-related members</span></span>

  <span data-ttu-id="26388-253">Deux propriétés en lecture seule, `Publisher` et `Type`.</span><span class="sxs-lookup"><span data-stu-id="26388-253">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="26388-254">Les valeurs sont à l’origine fournies par l’appel au constructeur de la classe `Publication`.</span><span class="sxs-lookup"><span data-stu-id="26388-254">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="26388-255">Membres liés à la publication</span><span class="sxs-lookup"><span data-stu-id="26388-255">Publishing-related members</span></span>

  <span data-ttu-id="26388-256">Deux méthodes, `Publish` et `GetPublicationDate` définissent et retournent la date de publication.</span><span class="sxs-lookup"><span data-stu-id="26388-256">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="26388-257">La méthode `Publish` définit l’indicateur privé `published` sur `true` lorsqu’elle est appelée et affecte la date passée comme argument au champ privé `datePublished`.</span><span class="sxs-lookup"><span data-stu-id="26388-257">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="26388-258">La méthode `GetPublicationDate` retourne la chaîne « NYP » si l’indicateur `published` est `false`, et la valeur du champ `datePublished` si l’indicateur est `true`.</span><span class="sxs-lookup"><span data-stu-id="26388-258">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="26388-259">Membres liés aux droits d’auteur</span><span class="sxs-lookup"><span data-stu-id="26388-259">Copyright-related members</span></span>

  <span data-ttu-id="26388-260">La méthode `Copyright` prend comme arguments le nom du titulaire des droits d’auteur et l’année des droits d’auteur et les attribue aux propriétés `CopyrightName` et `CopyrightDate`.</span><span class="sxs-lookup"><span data-stu-id="26388-260">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="26388-261">Une substitution de la méthode `ToString`</span><span class="sxs-lookup"><span data-stu-id="26388-261">An override of the `ToString` method</span></span>

  <span data-ttu-id="26388-262">Si un type ne remplace pas la méthode <xref:System.Object.ToString%2A?displayProperty=nameWithType>, il retourne le nom qualifié complet du type, ce qui n’aide pas vraiment à faire la différence entre une instance et une autre.</span><span class="sxs-lookup"><span data-stu-id="26388-262">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="26388-263">La classe `Publication` substitue <xref:System.Object.ToString%2A?displayProperty=nameWithType> pour retourner la valeur de la propriété `Title`.</span><span class="sxs-lookup"><span data-stu-id="26388-263">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="26388-264">Le schéma suivant illustre la relation entre la base notre classe `Publication` de base et sa classe <xref:System.Object> implicitement héritée.</span><span class="sxs-lookup"><span data-stu-id="26388-264">The following figure illustrates the relationship between our base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Les classes Object et Publication](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="26388-266">La classe `Book`</span><span class="sxs-lookup"><span data-stu-id="26388-266">The `Book` class</span></span>

<span data-ttu-id="26388-267">La classe `Book` représente un livre sous la forme d’un type spécialisé de publication.</span><span class="sxs-lookup"><span data-stu-id="26388-267">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="26388-268">L’exemple suivant montre le code source pour la classe `Book`.</span><span class="sxs-lookup"><span data-stu-id="26388-268">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="26388-269">Outre les membres qu’elle hérite de `Publication`, la classe `Book` définit les membres uniques et substitutions de membres suivants :</span><span class="sxs-lookup"><span data-stu-id="26388-269">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="26388-270">Deux constructeurs</span><span class="sxs-lookup"><span data-stu-id="26388-270">Two constructors</span></span>

  <span data-ttu-id="26388-271">Les deux constructeurs `Book` partagent trois paramètres communs.</span><span class="sxs-lookup"><span data-stu-id="26388-271">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="26388-272">Deux d’entre eux, *title* et *publisher*, correspondent aux paramètres du constructeur `Publication`.</span><span class="sxs-lookup"><span data-stu-id="26388-272">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="26388-273">Le troisième est *author*, qui est stocké dans un champ privé `authorName`.</span><span class="sxs-lookup"><span data-stu-id="26388-273">The third is *author*, which is stored to a private `authorName` field.</span></span> <span data-ttu-id="26388-274">Un constructeur inclut un paramètre *isbn*, qui est stocké dans l’auto-propriété `ISBN`.</span><span class="sxs-lookup"><span data-stu-id="26388-274">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="26388-275">Le premier constructeur utilise le mot-clé [this](../language-reference/keywords/this.md) pour appeler l’autre constructeur.</span><span class="sxs-lookup"><span data-stu-id="26388-275">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="26388-276">Il s’agit d’un modèle courant dans la définition des constructeurs.</span><span class="sxs-lookup"><span data-stu-id="26388-276">This is a common pattern in defining constructors.</span></span> <span data-ttu-id="26388-277">Les constructeurs avec le moins de paramètres fournissent les valeurs par défaut au moment de l’appel du constructeur avec le plus grand nombre de paramètres.</span><span class="sxs-lookup"><span data-stu-id="26388-277">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="26388-278">Le deuxième constructeur utilise le mot-clé [base](../language-reference/keywords/base.md) pour transmettre le titre et le nom de l’éditeur au constructeur de classe de base.</span><span class="sxs-lookup"><span data-stu-id="26388-278">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="26388-279">Si vous n’effectuez pas un appel explicite à un constructeur de classe de base dans votre code source, le compilateur C# fournit automatiquement un appel au constructeur par défaut ou sans paramètres de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="26388-279">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="26388-280">Une propriété `ISBN` en lecture seule qui retourne le numéro ISBN de l’objet `Book`, un numéro unique à 10 ou 13 chiffres.</span><span class="sxs-lookup"><span data-stu-id="26388-280">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="26388-281">Le numéro ISBN est fourni en tant qu’argument à un des constructeurs `Book`.</span><span class="sxs-lookup"><span data-stu-id="26388-281">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="26388-282">Le numéro ISBN est stocké dans un champ de stockage privé qui est généré automatiquement par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="26388-282">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="26388-283">Une propriété `Author` en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="26388-283">A read-only `Author` property.</span></span> <span data-ttu-id="26388-284">Le nom de l’auteur est fourni en tant qu’argument aux deux constructeurs `Book` et est stocké dans le champ `authorName` privé.</span><span class="sxs-lookup"><span data-stu-id="26388-284">The author name is supplied as an argument to both `Book` constructors and is stored in the private `authorName` field.</span></span>

- <span data-ttu-id="26388-285">Deux propriétés en lecture seule relatives au prix, `Price` et `Currency`.</span><span class="sxs-lookup"><span data-stu-id="26388-285">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="26388-286">Leurs valeurs sont fournies comme arguments dans un appel de méthode `SetPrice`.</span><span class="sxs-lookup"><span data-stu-id="26388-286">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="26388-287">Le prix est stocké dans un champ privé, `bookPrice`.</span><span class="sxs-lookup"><span data-stu-id="26388-287">The price is stored in a private field, `bookPrice`.</span></span> <span data-ttu-id="26388-288">La propriété `Currency` est le symbole de devise ISO à trois caractères (par exemple, USD pour le dollar américain) et est stockée dans le champ `ISOCurrencySymbol` privé.</span><span class="sxs-lookup"><span data-stu-id="26388-288">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar) and is stored in the private `ISOCurrencySymbol` field.</span></span> <span data-ttu-id="26388-289">Les symboles de devise ISO peuvent être récupérés à partir de la propriété <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A>.</span><span class="sxs-lookup"><span data-stu-id="26388-289">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span>

- <span data-ttu-id="26388-290">Une méthode `SetPrice` qui définit les valeurs des champs `bookPrice` et `ISOCurrencySymbol`.</span><span class="sxs-lookup"><span data-stu-id="26388-290">A `SetPrice` method, which sets the values of the `bookPrice` and `ISOCurrencySymbol` fields.</span></span> <span data-ttu-id="26388-291">Ce sont les valeurs récupérées par les propriétés `Price` et `Currency`.</span><span class="sxs-lookup"><span data-stu-id="26388-291">These are the values returned by the `Price` and `Currency` properties.</span></span>

- <span data-ttu-id="26388-292">Se substitue à la méthode `ToString` (héritée de `Publication`) et aux méthodes <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> et <xref:System.Object.GetHashCode%2A> (héritées de <xref:System.Object>).</span><span class="sxs-lookup"><span data-stu-id="26388-292">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="26388-293">Sauf si elle est substituée, la méthode <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> teste l’égalité des références.</span><span class="sxs-lookup"><span data-stu-id="26388-293">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="26388-294">Autrement dit, deux variables d’objet sont considérées comme égales si elles font référence au même objet.</span><span class="sxs-lookup"><span data-stu-id="26388-294">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="26388-295">Dans le cas de la classe `Book`, en revanche, deux objets `Book` doivent être égaux s’ils ont le même ISBN.</span><span class="sxs-lookup"><span data-stu-id="26388-295">In the case of the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="26388-296">Lorsque vous substituez la méthode <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, vous devez également substituer la méthode <xref:System.Object.GetHashCode%2A> qui retourne une valeur que le runtime utilise pour stocker les éléments dans les collections hachées pour une récupération efficace.</span><span class="sxs-lookup"><span data-stu-id="26388-296">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="26388-297">Le code de hachage doit retourner une valeur qui est cohérente avec le test d’égalité.</span><span class="sxs-lookup"><span data-stu-id="26388-297">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="26388-298">Étant donné que nous avons substitué <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> pour retourner `true` si les propriétés ISBN de deux objets `Book` sont égales, nous retournons le code de hachage calculé en appelant la méthode <xref:System.String.GetHashCode%2A> de la chaîne retournée par la propriété `ISBN`.</span><span class="sxs-lookup"><span data-stu-id="26388-298">Since we've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, we return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="26388-299">Le schéma suivant illustre la relation entre la base la classe `Book` et `Publication`, sa classe de base.</span><span class="sxs-lookup"><span data-stu-id="26388-299">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Les classes Publication et Book](media/book-class.jpg)

<span data-ttu-id="26388-301">Nous pouvons maintenant instancier un objet `Book`, appeler ses membres uniques et hérités le passer en tant qu’argument pour une méthode qui attend un paramètre de type `Publication` ou de type `Book`, comme illustré dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="26388-301">We can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="26388-302">Conception de classes de base abstraites et de leurs classes dérivées</span><span class="sxs-lookup"><span data-stu-id="26388-302">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="26388-303">Dans l’exemple précédent, nous avons défini une classe de base qui a fourni une implémentation d’un certain nombre de méthodes pour permettre aux classes dérivées de partager du code.</span><span class="sxs-lookup"><span data-stu-id="26388-303">In the previous example, we defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="26388-304">Dans de nombreux cas, toutefois, la classe de base n'est pas censée fournir une implémentation.</span><span class="sxs-lookup"><span data-stu-id="26388-304">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="26388-305">Au lieu de cela, la classe de base est une *classe abstraite* ; elle sert de modèle qui définit les membres que chaque classe dérivée doit implémenter.</span><span class="sxs-lookup"><span data-stu-id="26388-305">Instead, the base class is an *abstract class*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="26388-306">En général, dans le cas d’une classe de base abstraite, l’implémentation de chaque type dérivé est propre à ce type.</span><span class="sxs-lookup"><span data-stu-id="26388-306">Typically in the case of an abstract base class, the implementation of each derived type is unique to that type.</span></span>

<span data-ttu-id="26388-307">Par exemple, chaque forme géométrique bidimensionnelle fermée inclut deux propriétés : l’aire, l’étendue interne de la forme, et le périmètre, ou la distance le long des bords de la forme.</span><span class="sxs-lookup"><span data-stu-id="26388-307">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="26388-308">La façon de laquelle ces propriétés sont calculées, cependant, dépend entièrement de la forme spécifique.</span><span class="sxs-lookup"><span data-stu-id="26388-308">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="26388-309">La formule de calcul du périmètre (ou de la circonférence) d’un cercle, par exemple, est très différente de celle d’un triangle.</span><span class="sxs-lookup"><span data-stu-id="26388-309">The formula for calculating the perimeter (or circumference) of a circle, for example, is very different from that of a triangle.</span></span>

<span data-ttu-id="26388-310">L’exemple suivant définit une classe de base abstraite nommée `Shape` qui définit deux propriétés : `Area` et `Perimeter`.</span><span class="sxs-lookup"><span data-stu-id="26388-310">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="26388-311">Notez que, en plus de marquer la classe avec le mot-clé [abstract](../language-reference/keywords/abstract.md), chaque membre de l’instance est également marqué avec le mot-clé [abstract](../language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="26388-311">Note that, in addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="26388-312">Dans ce cas, `Shape` substitue également la méthode <xref:System.Object.ToString%2A?displayProperty=nameWithType> pour renvoyer le nom du type, plutôt que son nom qualifié complet.</span><span class="sxs-lookup"><span data-stu-id="26388-312">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="26388-313">Elle définit aussi deux membres statiques, `GetArea` et `GetPerimeter`, qui permettent aux appelants de récupérer facilement l’aire et le périmètre d’une instance de toute classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="26388-313">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="26388-314">Lorsque nous passons une instance d’une classe dérivée à une de ces méthodes, le runtime appelle la substitution de la méthode de la classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="26388-314">When we pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="26388-315">Nous pouvons ensuite dériver des classes qui représentent des formes spécifiques à partir de `Shape`.</span><span class="sxs-lookup"><span data-stu-id="26388-315">We can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="26388-316">L’exemple suivant définit trois classes : `Triangle`, `Rectangle` et `Circle`.</span><span class="sxs-lookup"><span data-stu-id="26388-316">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="26388-317">Chaque forme utilise une formule unique pour calculer l’aire et périmètre.</span><span class="sxs-lookup"><span data-stu-id="26388-317">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="26388-318">Certaines des classes dérivées définissent également des propriétés, telles que `Rectangle.Diagonal` et `Circle.Diameter`, qui sont propres à la forme qu’ils représentent.</span><span class="sxs-lookup"><span data-stu-id="26388-318">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="26388-319">L'exemple suivant utilise les objets dérivés de `Shape`.</span><span class="sxs-lookup"><span data-stu-id="26388-319">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="26388-320">Elle instancie un tableau d’objets dérivés de `Shape` et appelle les méthodes statiques de la classe `Shape` qui encapsule les valeurs de propriété de retour de `Shape`.</span><span class="sxs-lookup"><span data-stu-id="26388-320">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="26388-321">Notez que le runtime récupère les valeurs de propriétés substituées des types dérivés.</span><span class="sxs-lookup"><span data-stu-id="26388-321">Note that the runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="26388-322">L’exemple convertit également chaque objet `Shape` dans le tableau en son type dérivé et, si la conversion réussit, récupère les propriétés de cette sous-classe particulière de `Shape`.</span><span class="sxs-lookup"><span data-stu-id="26388-322">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span> 

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="26388-323">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="26388-323">See also</span></span>

<span data-ttu-id="26388-324">[Classes et objets](../tour-of-csharp/classes-and-objects.md) </span><span class="sxs-lookup"><span data-stu-id="26388-324">[Classes and objects](../tour-of-csharp/classes-and-objects.md) </span></span>  
[<span data-ttu-id="26388-325">Héritage (Guide de programmation C#)</span><span class="sxs-lookup"><span data-stu-id="26388-325">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
