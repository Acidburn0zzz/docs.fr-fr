---
title: Synchronisation des threads (C#)
ms.date: 07/20/2015
ms.assetid: e42b1be6-c93c-479f-a148-be0759f1a4e1
ms.openlocfilehash: 138b94ef8ae5fc54e42277127f9b22f88803457f
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33338609"
---
# <a name="thread-synchronization-c"></a><span data-ttu-id="f1a26-102">Synchronisation des threads (C#)</span><span class="sxs-lookup"><span data-stu-id="f1a26-102">Thread Synchronization (C#)</span></span>
<span data-ttu-id="f1a26-103">Les sections suivantes décrivent les fonctionnalités et les classes qui peuvent être utilisées pour synchroniser l’accès aux ressources dans les applications multithread.</span><span class="sxs-lookup"><span data-stu-id="f1a26-103">The following sections describe features and classes that can be used to synchronize access to resources in multithreaded applications.</span></span>  
  
 <span data-ttu-id="f1a26-104">L’un des avantages de l’utilisation de plusieurs threads dans une application est que chaque thread s’exécute de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="f1a26-104">One of the benefits of using multiple threads in an application is that each thread executes asynchronously.</span></span> <span data-ttu-id="f1a26-105">Pour les applications Windows, cela permet d’exécuter les tâches longues en arrière-plan pendant que la fenêtre et les contrôles de l’application restent réactifs.</span><span class="sxs-lookup"><span data-stu-id="f1a26-105">For Windows applications, this allows time-consuming tasks to be performed in the background while the application window and controls remain responsive.</span></span> <span data-ttu-id="f1a26-106">Pour les applications serveur, le multithreading offre la possibilité de gérer chaque demande entrante avec un thread différent.</span><span class="sxs-lookup"><span data-stu-id="f1a26-106">For server applications, multithreading provides the ability to handle each incoming request with a different thread.</span></span> <span data-ttu-id="f1a26-107">Sinon, une nouvelle demande ne serait pas prise en charge tant que la demande précédente n’aurait pas été entièrement satisfaite.</span><span class="sxs-lookup"><span data-stu-id="f1a26-107">Otherwise, each new request would not get serviced until the previous request had been fully satisfied.</span></span>  
  
 <span data-ttu-id="f1a26-108">Toutefois, la nature asynchrone des threads signifie que l’accès à des ressources telles que des descripteurs de fichiers, des connexions réseau et la mémoire doit être coordonné.</span><span class="sxs-lookup"><span data-stu-id="f1a26-108">However, the asynchronous nature of threads means that access to resources such as file handles, network connections, and memory must be coordinated.</span></span> <span data-ttu-id="f1a26-109">Sinon, deux threads ou plus pourraient accéder à la même ressource en même temps, chacun ignorant les actions des autres.</span><span class="sxs-lookup"><span data-stu-id="f1a26-109">Otherwise, two or more threads could access the same resource at the same time, each unaware of the other's actions.</span></span> <span data-ttu-id="f1a26-110">Il en résulterait une altération imprévisible des données.</span><span class="sxs-lookup"><span data-stu-id="f1a26-110">The result is unpredictable data corruption.</span></span>  
  
 <span data-ttu-id="f1a26-111">Pour les opérations simples sur les types de données numériques intégraux, la synchronisation des threads peut se faire avec les membres de la classe <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="f1a26-111">For simple operations on integral numeric data types, synchronizing threads can be accomplished with members of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="f1a26-112">Pour tous les autres types de données et les ressources non thread-safe, le multithreading ne peut être réalisé en toute sécurité qu’en utilisant les constructions fournies dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="f1a26-112">For all other data types and non thread-safe resources, multithreading can only be safely performed using the constructs in this topic.</span></span>  
  
 <span data-ttu-id="f1a26-113">Pour obtenir des informations générales sur la programmation multithread, consultez :</span><span class="sxs-lookup"><span data-stu-id="f1a26-113">For background information on multithreaded programming, see:</span></span>  
  
-   [<span data-ttu-id="f1a26-114">Éléments fondamentaux du threading managé</span><span class="sxs-lookup"><span data-stu-id="f1a26-114">Managed Threading Basics</span></span>](../../../../standard/threading/managed-threading-basics.md)  
  
-   [<span data-ttu-id="f1a26-115">Utilisation des threads et du threading</span><span class="sxs-lookup"><span data-stu-id="f1a26-115">Using Threads and Threading</span></span>](../../../../standard/threading/using-threads-and-threading.md)  
  
-   [<span data-ttu-id="f1a26-116">Bonnes pratiques de threading géré</span><span class="sxs-lookup"><span data-stu-id="f1a26-116">Managed Threading Best Practices</span></span>](../../../../standard/threading/managed-threading-best-practices.md)  
  
## <a name="the-lock-keyword"></a><span data-ttu-id="f1a26-117">Mot clé lock</span><span class="sxs-lookup"><span data-stu-id="f1a26-117">The lock Keyword</span></span>  
 <span data-ttu-id="f1a26-118">L’instruction C# `lock` permet de garantir qu’un bloc de code s’exécute jusqu’à son achèvement sans être interrompu par d’autres threads.</span><span class="sxs-lookup"><span data-stu-id="f1a26-118">The C# `lock` statement can be used to ensure that a block of code runs to completion without interruption by other threads.</span></span> <span data-ttu-id="f1a26-119">Pour cela, elle obtient un verrou d’exclusion mutuelle pour un objet donné pour la durée du bloc de code.</span><span class="sxs-lookup"><span data-stu-id="f1a26-119">This is accomplished by obtaining a mutual-exclusion lock for a given object for the duration of the code block.</span></span>  
  
 <span data-ttu-id="f1a26-120">Une instruction `lock` se voit attribuer un objet comme argument et est suivie par un bloc de code qui doit être exécuté par un seul thread à la fois.</span><span class="sxs-lookup"><span data-stu-id="f1a26-120">A `lock` statement is given an object as an argument, and is followed by a code block that is to be executed by only one thread at a time.</span></span> <span data-ttu-id="f1a26-121">Exemple :</span><span class="sxs-lookup"><span data-stu-id="f1a26-121">For example:</span></span>  
  
```csharp  
public class TestThreading  
{  
    private System.Object lockThis = new System.Object();  
  
    public void Process()  
    {  
  
        lock (lockThis)  
        {  
            // Access thread-sensitive resources.  
        }  
    }  
  
}  
```  
  
 <span data-ttu-id="f1a26-122">L’argument fourni au mot clé `lock` doit être un objet basé sur un type référence servant à définir la portée du verrou.</span><span class="sxs-lookup"><span data-stu-id="f1a26-122">The argument provided to the `lock` keyword must be an object based on a reference type, and is used to define the scope of the lock.</span></span> <span data-ttu-id="f1a26-123">Dans l’exemple ci-dessus, la portée du verrou est limitée à cette fonction car aucune référence à l’objet `lockThis` n’existe en dehors de la fonction.</span><span class="sxs-lookup"><span data-stu-id="f1a26-123">In the example above, the lock scope is limited to this function because no references to the object `lockThis` exist outside the function.</span></span> <span data-ttu-id="f1a26-124">Si une telle référence existait, la portée du verrou s’étendrait à cet objet.</span><span class="sxs-lookup"><span data-stu-id="f1a26-124">If such a reference did exist, lock scope would extend to that object.</span></span> <span data-ttu-id="f1a26-125">À proprement parler, l’objet fourni est utilisé seulement pour identifier de manière unique la ressource qui est partagée entre plusieurs threads, si bien qu’il peut s’agir d’une instance de classe arbitraire.</span><span class="sxs-lookup"><span data-stu-id="f1a26-125">Strictly speaking, the object provided is used solely to uniquely identify the resource being shared among multiple threads, so it can be an arbitrary class instance.</span></span> <span data-ttu-id="f1a26-126">Dans la pratique, toutefois, cet objet représente généralement la ressource pour laquelle la synchronisation des threads est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="f1a26-126">In practice, however, this object usually represents the resource for which thread synchronization is necessary.</span></span> <span data-ttu-id="f1a26-127">Par exemple, si un objet conteneur doit être utilisé par plusieurs threads, le conteneur peut être passé au verrou, et le bloc de code synchronisé suivant le verrou accéderait au conteneur.</span><span class="sxs-lookup"><span data-stu-id="f1a26-127">For example, if a container object is to be used by multiple threads, then the container can be passed to lock, and the synchronized code block following the lock would access the container.</span></span> <span data-ttu-id="f1a26-128">L’accès à l’objet est bien synchronisé du moment que les autres threads appliquent un verrou sur le même conteneur avant d’y accéder.</span><span class="sxs-lookup"><span data-stu-id="f1a26-128">As long as other threads locks on the same contain before accessing it, then access to the object is safely synchronized.</span></span>  
  
 <span data-ttu-id="f1a26-129">En général, il est préférable d’éviter d’appliquer un verrou sur un type `public` ou sur des instances d’objet non contrôlées par votre application.</span><span class="sxs-lookup"><span data-stu-id="f1a26-129">Generally, it is best to avoid locking on a `public` type, or on object instances beyond the control of your application.</span></span> <span data-ttu-id="f1a26-130">Par exemple, `lock(this)` peut être problématique si l’instance est accessible publiquement, car du code en dehors de votre contrôle risque d’appliquer également un verrou sur l’objet.</span><span class="sxs-lookup"><span data-stu-id="f1a26-130">For example, `lock(this)` can be problematic if the instance can be accessed publicly, because code beyond your control may lock on the object as well.</span></span> <span data-ttu-id="f1a26-131">Cela pourrait créer des situations de blocage où deux threads ou plus attendent la libération du même objet.</span><span class="sxs-lookup"><span data-stu-id="f1a26-131">This could create deadlock situations where two or more threads wait for the release of the same object.</span></span> <span data-ttu-id="f1a26-132">L’application d’un verrou sur un type de données public, par opposition à un objet, peut entraîner des problèmes pour la même raison.</span><span class="sxs-lookup"><span data-stu-id="f1a26-132">Locking on a public data type, as opposed to an object, can cause problems for the same reason.</span></span> <span data-ttu-id="f1a26-133">L’application d’un verrou sur des chaînes littérales est particulièrement risqué, car les chaînes littérales sont *intégrées* par le CLR (Common Language Runtime).</span><span class="sxs-lookup"><span data-stu-id="f1a26-133">Locking on literal strings is especially risky because literal strings are *interned* by the common language runtime (CLR).</span></span> <span data-ttu-id="f1a26-134">Cela signifie qu’il existe une seule instance d’une chaîne littérale donnée pour l’ensemble du programme. Un seul et même objet représente le littéral dans tous les domaines d’application en cours d’exécution, sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="f1a26-134">This means that there is one instance of any given string literal for the entire program, the exact same object represents the literal in all running application domains, on all threads.</span></span> <span data-ttu-id="f1a26-135">Par conséquent, un verrou placé sur une chaîne avec le même contenu n’importe où dans le processus d’application verrouille toutes les instances de cette chaîne dans l’application.</span><span class="sxs-lookup"><span data-stu-id="f1a26-135">As a result, a lock placed on a string with the same contents anywhere in the application process locks all instances of that string in the application.</span></span> <span data-ttu-id="f1a26-136">Par conséquent, il est préférable de verrouiller un membre privé ou protégé qui n’est pas intégré.</span><span class="sxs-lookup"><span data-stu-id="f1a26-136">As a result, it is best to lock a private or protected member that is not interned.</span></span> <span data-ttu-id="f1a26-137">Certaines classes fournissent des membres spécifiquement pour le verrouillage.</span><span class="sxs-lookup"><span data-stu-id="f1a26-137">Some classes provide members specifically for locking.</span></span> <span data-ttu-id="f1a26-138">Le type <xref:System.Array>, par exemple, fournit <xref:System.Array.SyncRoot%2A>.</span><span class="sxs-lookup"><span data-stu-id="f1a26-138">The <xref:System.Array> type, for example, provides <xref:System.Array.SyncRoot%2A>.</span></span> <span data-ttu-id="f1a26-139">De nombreux types de collection fournissent également un membre `SyncRoot`.</span><span class="sxs-lookup"><span data-stu-id="f1a26-139">Many collection types provide a `SyncRoot` member as well.</span></span>  
  
 <span data-ttu-id="f1a26-140">Pour plus d’informations sur l’instruction `lock`, consultez les rubriques suivantes :</span><span class="sxs-lookup"><span data-stu-id="f1a26-140">For more information about the `lock` statement, see the following topics:</span></span>  
  
-   [<span data-ttu-id="f1a26-141">lock, instruction</span><span class="sxs-lookup"><span data-stu-id="f1a26-141">lock Statement</span></span>](../../../../csharp/language-reference/keywords/lock-statement.md)  
  
-   <xref:System.Threading.Monitor>  
  
## <a name="monitors"></a><span data-ttu-id="f1a26-142">Analyses</span><span class="sxs-lookup"><span data-stu-id="f1a26-142">Monitors</span></span>  
 <span data-ttu-id="f1a26-143">Comme le mot clé `lock`, les moniteurs empêchent l’exécution simultanée de blocs de code par plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="f1a26-143">Like the `lock` keyword, monitors prevent blocks of code from simultaneous execution by multiple threads.</span></span> <span data-ttu-id="f1a26-144">La méthode <xref:System.Threading.Monitor.Enter%2A> permet à un seul thread de passer aux instructions suivantes ; tous les autres threads sont bloqués jusqu’à ce que le thread d’exécution appelle <xref:System.Threading.Monitor.Exit%2A>.</span><span class="sxs-lookup"><span data-stu-id="f1a26-144">The <xref:System.Threading.Monitor.Enter%2A> method allows one and only one thread to proceed into the following statements; all other threads are blocked until the executing thread calls <xref:System.Threading.Monitor.Exit%2A>.</span></span> <span data-ttu-id="f1a26-145">Cela équivaut à utiliser le mot clé `lock`.</span><span class="sxs-lookup"><span data-stu-id="f1a26-145">This is just like using the `lock` keyword.</span></span> <span data-ttu-id="f1a26-146">Exemple :</span><span class="sxs-lookup"><span data-stu-id="f1a26-146">For example:</span></span>  
  
```csharp  
lock (x)  
{  
    DoSomething();  
}  
```  
  
 <span data-ttu-id="f1a26-147">Ceci équivaut à :</span><span class="sxs-lookup"><span data-stu-id="f1a26-147">This is equivalent to:</span></span>  
  
```csharp  
System.Object obj = (System.Object)x;  
System.Threading.Monitor.Enter(obj);  
try  
{  
    DoSomething();  
}  
finally  
{  
    System.Threading.Monitor.Exit(obj);  
}  
```  
  
 <span data-ttu-id="f1a26-148">L’utilisation du mot clé `lock` est généralement préférée à l’utilisation directe de la classe <xref:System.Threading.Monitor>. En effet, `lock` est plus concis et `lock` garantit la libération du moniteur sous-jacent, même si le code protégé lève une exception.</span><span class="sxs-lookup"><span data-stu-id="f1a26-148">Using the `lock` keyword is generally preferred over using the <xref:System.Threading.Monitor> class directly, both because `lock` is more concise, and because `lock` insures that the underlying monitor is released, even if the protected code throws an exception.</span></span> <span data-ttu-id="f1a26-149">Le mot clé `finally` permet cela ; il exécute son bloc de code associé qu’une exception soit levée ou non.</span><span class="sxs-lookup"><span data-stu-id="f1a26-149">This is accomplished with the `finally` keyword, which executes its associated code block regardless of whether an exception is thrown.</span></span>  
  
## <a name="synchronization-events-and-wait-handles"></a><span data-ttu-id="f1a26-150">Événements de synchronisation et handles d’attente</span><span class="sxs-lookup"><span data-stu-id="f1a26-150">Synchronization Events and Wait Handles</span></span>  
 <span data-ttu-id="f1a26-151">L’utilisation d’un verrou ou d’un moniteur est utile pour empêcher l’exécution simultanée de blocs de code sensibles aux threads, mais ces constructions ne permettent pas à un thread de communiquer un événement à un autre.</span><span class="sxs-lookup"><span data-stu-id="f1a26-151">Using a lock or monitor is useful for preventing the simultaneous execution of thread-sensitive blocks of code, but these constructs do not allow one thread to communicate an event to another.</span></span> <span data-ttu-id="f1a26-152">Cela nécessite des *événements de synchronisation* Ce sont des objets qui possèdent l’un des deux états suivants : signalé ou non signalé, et qui peuvent être utilisés pour activer et suspendre des threads.</span><span class="sxs-lookup"><span data-stu-id="f1a26-152">This requires *synchronization events*, which are objects that have one of two states, signaled and un-signaled, that can be used to activate and suspend threads.</span></span> <span data-ttu-id="f1a26-153">Il est possible de suspendre des threads en les obligeant à attendre un événement de synchronisation non signalé, et de les activer en changeant l’état de l’événement sur signalé.</span><span class="sxs-lookup"><span data-stu-id="f1a26-153">Threads can be suspended by being made to wait on a synchronization event that is unsignaled, and can be activated by changing the event state to signaled.</span></span> <span data-ttu-id="f1a26-154">Si un thread tente d’attendre un événement qui est déjà signalé, le thread continue de s’exécuter sans délai.</span><span class="sxs-lookup"><span data-stu-id="f1a26-154">If a thread attempts to wait on an event that is already signaled, then the thread continues to execute without delay.</span></span>  
  
 <span data-ttu-id="f1a26-155">Il existe deux types d’événements de synchronisation : <xref:System.Threading.AutoResetEvent> et <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="f1a26-155">There are two kinds of synchronization events: <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="f1a26-156">Leur seule différence est que <xref:System.Threading.AutoResetEvent> passe automatiquement de l’état signalé à l’état non signalé chaque fois qu’il active un thread.</span><span class="sxs-lookup"><span data-stu-id="f1a26-156">They differ only in that <xref:System.Threading.AutoResetEvent> changes from signaled to unsignaled automatically any time it activates a thread.</span></span> <span data-ttu-id="f1a26-157">À l’inverse, un <xref:System.Threading.ManualResetEvent> permet l’activation de n’importe quel nombre de threads en fonction de son état signalé et revient à un état non signalé quand sa méthode <xref:System.Threading.EventWaitHandle.Reset%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="f1a26-157">Conversely, a <xref:System.Threading.ManualResetEvent> allows any number of threads to be activated by its signaled state, and will only revert to an unsignaled state when its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="f1a26-158">Vous pouvez obliger les threads à attendre les événements en appelant une méthode d’attente, comme <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> ou <xref:System.Threading.WaitHandle.WaitAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="f1a26-158">Threads can be made to wait on events by calling one of the wait methods, such as <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="f1a26-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> oblige le thread à attendre qu’un événement unique soit signalé, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> bloque un thread jusqu'à ce qu’un ou plusieurs événements indiqués soient signalés, et <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> bloque le thread jusqu'à ce que tous les événements indiqués soient signalés.</span><span class="sxs-lookup"><span data-stu-id="f1a26-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> causes the thread to wait until a single event becomes signaled, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> blocks a thread until one or more indicated events become signaled, and <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> blocks the thread until all of the indicated events become signaled.</span></span> <span data-ttu-id="f1a26-160">Un événement est signalé quand sa méthode <xref:System.Threading.EventWaitHandle.Set%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="f1a26-160">An event becomes signaled when its <xref:System.Threading.EventWaitHandle.Set%2A> method is called.</span></span>  
  
 <span data-ttu-id="f1a26-161">Dans l’exemple suivant, un thread est créé et démarré par la fonction `Main`.</span><span class="sxs-lookup"><span data-stu-id="f1a26-161">In the following example, a thread is created and started by the `Main` function.</span></span> <span data-ttu-id="f1a26-162">Le nouveau thread attend un événement à l’aide de la méthode <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="f1a26-162">The new thread waits on an event using the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="f1a26-163">Le thread est suspendu jusqu’à ce que l’événement soit signalé par le thread principal qui exécute la fonction `Main`.</span><span class="sxs-lookup"><span data-stu-id="f1a26-163">The thread is suspended until the event becomes signaled by the primary thread that is executing the `Main` function.</span></span> <span data-ttu-id="f1a26-164">Une fois que l’événement a été signalé, le thread auxiliaire est retourné.</span><span class="sxs-lookup"><span data-stu-id="f1a26-164">Once the event becomes signaled, the auxiliary thread returns.</span></span> <span data-ttu-id="f1a26-165">Dans ce cas, comme l’événement est uniquement utilisé pour l’activation d’un seul thread, les classes <xref:System.Threading.AutoResetEvent> ou <xref:System.Threading.ManualResetEvent> peuvent être utilisées.</span><span class="sxs-lookup"><span data-stu-id="f1a26-165">In this case, because the event is only used for one thread activation, either the <xref:System.Threading.AutoResetEvent> or <xref:System.Threading.ManualResetEvent> classes could be used.</span></span>  
  
```csharp  
using System;  
using System.Threading;  
  
class ThreadingExample  
{  
    static AutoResetEvent autoEvent;  
  
    static void DoWork()  
    {  
        Console.WriteLine("   worker thread started, now waiting on event...");  
        autoEvent.WaitOne();  
        Console.WriteLine("   worker thread reactivated, now exiting...");  
    }  
  
    static void Main()  
    {  
        autoEvent = new AutoResetEvent(false);  
  
        Console.WriteLine("main thread starting worker thread...");  
        Thread t = new Thread(DoWork);  
        t.Start();  
  
        Console.WriteLine("main thread sleeping for 1 second...");  
        Thread.Sleep(1000);  
  
        Console.WriteLine("main thread signaling worker thread...");  
        autoEvent.Set();  
    }  
}  
```  
  
## <a name="mutex-object"></a><span data-ttu-id="f1a26-166">Objet mutex</span><span class="sxs-lookup"><span data-stu-id="f1a26-166">Mutex Object</span></span>  
 <span data-ttu-id="f1a26-167">Un *mutex* est similaire à un moniteur. Il empêche l’exécution simultanée d’un bloc de code par plusieurs threads à la fois.</span><span class="sxs-lookup"><span data-stu-id="f1a26-167">A *mutex* is similar to a monitor; it prevents the simultaneous execution of a block of code by more than one thread at a time.</span></span> <span data-ttu-id="f1a26-168">En fait, le nom « mutex » est une forme raccourcie du terme « mutuellement exclusif ».</span><span class="sxs-lookup"><span data-stu-id="f1a26-168">In fact, the name "mutex" is a shortened form of the term "mutually exclusive."</span></span> <span data-ttu-id="f1a26-169">Contrairement aux moniteurs, toutefois, un mutex peut être utilisé pour synchroniser des threads entre des processus.</span><span class="sxs-lookup"><span data-stu-id="f1a26-169">Unlike monitors, however, a mutex can be used to synchronize threads across processes.</span></span> <span data-ttu-id="f1a26-170">Un mutex est représenté par la classe <xref:System.Threading.Mutex>.</span><span class="sxs-lookup"><span data-stu-id="f1a26-170">A mutex is represented by the <xref:System.Threading.Mutex> class.</span></span>  
  
 <span data-ttu-id="f1a26-171">Quand il est utilisé pour une synchronisation inter-processus, un mutex est qualifié de *mutex nommé*, car il doit être utilisé dans une autre application et, par conséquent, il ne peut pas être partagé au moyen d’une variable globale ou statique.</span><span class="sxs-lookup"><span data-stu-id="f1a26-171">When used for inter-process synchronization, a mutex is called a *named mutex* because it is to be used in another application, and therefore it cannot be shared by means of a global or static variable.</span></span> <span data-ttu-id="f1a26-172">Il doit se voir attribuer un nom pour que les deux applications puissent accéder au même objet mutex.</span><span class="sxs-lookup"><span data-stu-id="f1a26-172">It must be given a name so that both applications can access the same mutex object.</span></span>  
  
 <span data-ttu-id="f1a26-173">Un mutex peut être utilisé pour la synchronisation intra-processus de threads, mais l’utilisation de <xref:System.Threading.Monitor> est généralement préférée, car les moniteurs ont été conçus spécifiquement pour le .NET Framework et, par conséquent, font meilleur usage des ressources.</span><span class="sxs-lookup"><span data-stu-id="f1a26-173">Although a mutex can be used for intra-process thread synchronization, using <xref:System.Threading.Monitor> is generally preferred, because monitors were designed specifically for the .NET Framework and therefore make better use of resources.</span></span> <span data-ttu-id="f1a26-174">À l’inverse, la classe <xref:System.Threading.Mutex> est un wrapper d’une construction Win32.</span><span class="sxs-lookup"><span data-stu-id="f1a26-174">In contrast, the <xref:System.Threading.Mutex> class is a wrapper to a Win32 construct.</span></span> <span data-ttu-id="f1a26-175">Bien que plus puissant qu’un moniteur, un mutex nécessite des transitions d’interopérabilité qui sont plus gourmandes en ressources informatiques que celles demandées par la classe <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="f1a26-175">While it is more powerful than a monitor, a mutex requires interop transitions that are more computationally expensive than those required by the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="f1a26-176">Pour obtenir un exemple d’utilisation d’un mutex, consultez [Mutex](../../../../standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="f1a26-176">For an example of using a mutex, see [Mutexes](../../../../standard/threading/mutexes.md).</span></span>  
  
## <a name="interlocked-class"></a><span data-ttu-id="f1a26-177">Classe Interlocked</span><span class="sxs-lookup"><span data-stu-id="f1a26-177">Interlocked Class</span></span>  
 <span data-ttu-id="f1a26-178">Vous pouvez utiliser les méthodes de la classe <xref:System.Threading.Interlocked> pour éviter les problèmes qui peuvent se produire quand plusieurs threads tentent simultanément de mettre à jour ou de comparer la même valeur.</span><span class="sxs-lookup"><span data-stu-id="f1a26-178">You can use the methods of the <xref:System.Threading.Interlocked> class to prevent problems that can occur when multiple threads attempt to simultaneously update or compare the same value.</span></span> <span data-ttu-id="f1a26-179">Les méthodes de cette classe vous permettent d’incrémenter, de décrémenter, d’échanger et de comparer en toute sécurité des valeurs à partir de n’importe quel thread.</span><span class="sxs-lookup"><span data-stu-id="f1a26-179">The methods of this class let you safely increment, decrement, exchange, and compare values from any thread.</span></span>  
  
## <a name="readerwriter-locks"></a><span data-ttu-id="f1a26-180">Verrous ReaderWriter</span><span class="sxs-lookup"><span data-stu-id="f1a26-180">ReaderWriter Locks</span></span>  
 <span data-ttu-id="f1a26-181">Dans certains cas, vous pouvez souhaiter verrouiller une ressource seulement lors de l’écriture de données et autoriser plusieurs clients à lire simultanément les données quand celles-ci ne sont pas en cours d’actualisation.</span><span class="sxs-lookup"><span data-stu-id="f1a26-181">In some cases, you may want to lock a resource only when data is being written and permit multiple clients to simultaneously read data when data is not being updated.</span></span> <span data-ttu-id="f1a26-182">La classe <xref:System.Threading.ReaderWriterLock> applique un accès exclusif à une ressource quand un thread modifie cette ressource, mais elle permet un accès non exclusif lors de la lecture de la ressource.</span><span class="sxs-lookup"><span data-stu-id="f1a26-182">The <xref:System.Threading.ReaderWriterLock> class enforces exclusive access to a resource while a thread is modifying the resource, but it allows non-exclusive access when reading the resource.</span></span> <span data-ttu-id="f1a26-183">Les verrous ReaderWriter constituent une alternative utile aux verrous exclusifs, lesquels obligent les autres threads à attendre même lorsque ces threads n’ont pas besoin de mettre à jour les données.</span><span class="sxs-lookup"><span data-stu-id="f1a26-183">ReaderWriter locks are a useful alternative to exclusive locks, which cause other threads to wait, even when those threads do not need to update data.</span></span>  
  
## <a name="deadlocks"></a><span data-ttu-id="f1a26-184">Interblocages (deadlocks)</span><span class="sxs-lookup"><span data-stu-id="f1a26-184">Deadlocks</span></span>  
 <span data-ttu-id="f1a26-185">La synchronisation des threads est précieuse dans les applications multithread, mais implique toujours un risque de créer un interblocage (`deadlock`), lorsque plusieurs threads s’attendent mutuellement et que l’application s’arrête.</span><span class="sxs-lookup"><span data-stu-id="f1a26-185">Thread synchronization is invaluable in multithreaded applications, but there is always the danger of creating a `deadlock`, where multiple threads are waiting for each other and the application comes to a halt.</span></span> <span data-ttu-id="f1a26-186">Un interblocage s’apparente au cas d’un carrefour où chaque voie est munie d’un stop et où chaque automobiliste attend que l’autre passe.</span><span class="sxs-lookup"><span data-stu-id="f1a26-186">A deadlock is analogous to a situation in which cars are stopped at a four-way stop and each person is waiting for the other to go.</span></span> <span data-ttu-id="f1a26-187">Il est important d’éviter les interblocages et seule une planification rigoureuse le permet.</span><span class="sxs-lookup"><span data-stu-id="f1a26-187">Avoiding deadlocks is important; the key is careful planning.</span></span> <span data-ttu-id="f1a26-188">Vous pouvez souvent prévoir un interblocage en représentant graphiquement les applications multithread avant de commencer le codage.</span><span class="sxs-lookup"><span data-stu-id="f1a26-188">You can often predict deadlock situations by diagramming multithreaded applications before you start coding.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f1a26-189">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="f1a26-189">See Also</span></span>  
 <xref:System.Threading.Thread>  
 <xref:System.Threading.WaitHandle.WaitOne%2A>  
 <xref:System.Threading.WaitHandle.WaitAny%2A>  
 <xref:System.Threading.WaitHandle.WaitAll%2A>  
 <xref:System.Threading.Thread.Join%2A>  
 <xref:System.Threading.Thread.Start%2A>  
 <xref:System.Threading.Thread.Sleep%2A>  
 <xref:System.Threading.Monitor>  
 <xref:System.Threading.Mutex>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 <xref:System.Threading.Interlocked>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading>  
 <xref:System.Threading.EventWaitHandle.Set%2A>  
 <xref:System.Threading.Monitor>  
 [<span data-ttu-id="f1a26-190">Applications multithread (C#)</span><span class="sxs-lookup"><span data-stu-id="f1a26-190">Multithreaded Applications (C#)</span></span>](../../../../csharp/programming-guide/concepts/threading/multithreaded-applications.md)  
 [<span data-ttu-id="f1a26-191">lock, instruction</span><span class="sxs-lookup"><span data-stu-id="f1a26-191">lock Statement</span></span>](../../../../csharp/language-reference/keywords/lock-statement.md)  
 [<span data-ttu-id="f1a26-192">Mutex</span><span class="sxs-lookup"><span data-stu-id="f1a26-192">Mutexes</span></span>](../../../../standard/threading/mutexes.md)  
 [<span data-ttu-id="f1a26-193">Opérations verrouillées</span><span class="sxs-lookup"><span data-stu-id="f1a26-193">Interlocked Operations</span></span>](../../../../standard/threading/interlocked-operations.md)  
 [<span data-ttu-id="f1a26-194">AutoResetEvent</span><span class="sxs-lookup"><span data-stu-id="f1a26-194">AutoResetEvent</span></span>](../../../../standard/threading/autoresetevent.md)  
 [<span data-ttu-id="f1a26-195">Synchronisation des données pour le multithreading</span><span class="sxs-lookup"><span data-stu-id="f1a26-195">Synchronizing Data for Multithreading</span></span>](../../../../standard/threading/synchronizing-data-for-multithreading.md)
