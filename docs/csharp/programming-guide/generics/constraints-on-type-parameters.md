---
title: "Contraintes sur les paramètres de type (Guide de programmation C#)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- generics [C#], type constraints
- type constraints [C#]
- type parameters [C#], constraints
- unbound type parameter [C#]
ms.assetid: 141b003e-1ddb-4e1c-bcb2-e1c3870e6a51
caps.latest.revision: "41"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: f5382b0050b81ed3bb1a075a042bdc4034a3975d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/21/2017
---
# <a name="constraints-on-type-parameters-c-programming-guide"></a><span data-ttu-id="942d8-102">Contraintes sur les paramètres de type (Guide de programmation C#)</span><span class="sxs-lookup"><span data-stu-id="942d8-102">Constraints on Type Parameters (C# Programming Guide)</span></span>
<span data-ttu-id="942d8-103">Quand vous définissez une classe générique, vous pouvez appliquer des restrictions aux genres de types que le code client peut utiliser pour les arguments de type lorsqu’il instancie votre classe.</span><span class="sxs-lookup"><span data-stu-id="942d8-103">When you define a generic class, you can apply restrictions to the kinds of types that client code can use for type arguments when it instantiates your class.</span></span> <span data-ttu-id="942d8-104">Si le code client essaie d’instancier votre classe à l’aide d’un type qui n’est pas autorisé par une contrainte, il en résulte une erreur de compilation.</span><span class="sxs-lookup"><span data-stu-id="942d8-104">If client code tries to instantiate your class by using a type that is not allowed by a constraint, the result is a compile-time error.</span></span> <span data-ttu-id="942d8-105">Ces restrictions sont appelées des contraintes.</span><span class="sxs-lookup"><span data-stu-id="942d8-105">These restrictions are called constraints.</span></span> <span data-ttu-id="942d8-106">Les contraintes sont spécifiées à l’aide du mot clé contextuel `where`.</span><span class="sxs-lookup"><span data-stu-id="942d8-106">Constraints are specified by using the `where` contextual keyword.</span></span> <span data-ttu-id="942d8-107">Le tableau suivant liste les six types de contraintes :</span><span class="sxs-lookup"><span data-stu-id="942d8-107">The following table lists the six types of constraints:</span></span>  
  
|<span data-ttu-id="942d8-108">Contrainte</span><span class="sxs-lookup"><span data-stu-id="942d8-108">Constraint</span></span>|<span data-ttu-id="942d8-109">Description</span><span class="sxs-lookup"><span data-stu-id="942d8-109">Description</span></span>|  
|----------------|-----------------|  
|<span data-ttu-id="942d8-110">where T : struct</span><span class="sxs-lookup"><span data-stu-id="942d8-110">where T: struct</span></span>|<span data-ttu-id="942d8-111">L’argument de type doit être un type valeur.</span><span class="sxs-lookup"><span data-stu-id="942d8-111">The type argument must be a value type.</span></span> <span data-ttu-id="942d8-112">Tout type valeur, excepté <xref:System.Nullable>, peut être spécifié.</span><span class="sxs-lookup"><span data-stu-id="942d8-112">Any value type except <xref:System.Nullable> can be specified.</span></span> <span data-ttu-id="942d8-113">Consultez [Utilisation de types Nullable](../../../csharp/programming-guide/nullable-types/using-nullable-types.md) pour plus d’informations.</span><span class="sxs-lookup"><span data-stu-id="942d8-113">See [Using Nullable Types](../../../csharp/programming-guide/nullable-types/using-nullable-types.md) for more information.</span></span>|  
|<span data-ttu-id="942d8-114">where T : class</span><span class="sxs-lookup"><span data-stu-id="942d8-114">where T : class</span></span>|<span data-ttu-id="942d8-115">L’argument de type doit être un type référence. Cela s’applique également à tout type de classe, d’interface, de délégué ou de tableau.</span><span class="sxs-lookup"><span data-stu-id="942d8-115">The type argument must be a reference type; this applies also to any class, interface, delegate, or array type.</span></span>|  
|<span data-ttu-id="942d8-116">where T : new()</span><span class="sxs-lookup"><span data-stu-id="942d8-116">where T : new()</span></span>|<span data-ttu-id="942d8-117">L’argument de type doit avoir un constructeur sans paramètre public.</span><span class="sxs-lookup"><span data-stu-id="942d8-117">The type argument must have a public parameterless constructor.</span></span> <span data-ttu-id="942d8-118">Quand vous utilisez la contrainte `new()` avec d’autres contraintes, elle doit être spécifiée en dernier.</span><span class="sxs-lookup"><span data-stu-id="942d8-118">When used together with other constraints, the `new()` constraint must be specified last.</span></span>|  
|<span data-ttu-id="942d8-119">where T : \<nom de classe de base></span><span class="sxs-lookup"><span data-stu-id="942d8-119">where T : \<base class name></span></span>|<span data-ttu-id="942d8-120">L’argument de type doit être la classe de base spécifiée ou en dériver.</span><span class="sxs-lookup"><span data-stu-id="942d8-120">The type argument must be or derive from the specified base class.</span></span>|  
|<span data-ttu-id="942d8-121">where T : \<nom d’interface></span><span class="sxs-lookup"><span data-stu-id="942d8-121">where T : \<interface name></span></span>|<span data-ttu-id="942d8-122">L’argument de type doit être ou implémenter l’interface spécifiée.</span><span class="sxs-lookup"><span data-stu-id="942d8-122">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="942d8-123">Plusieurs contraintes d’interface peuvent être spécifiées.</span><span class="sxs-lookup"><span data-stu-id="942d8-123">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="942d8-124">L’interface qui impose les contraintes peut également être générique.</span><span class="sxs-lookup"><span data-stu-id="942d8-124">The constraining interface can also be generic.</span></span>|  
|<span data-ttu-id="942d8-125">where T : U</span><span class="sxs-lookup"><span data-stu-id="942d8-125">where T : U</span></span>|<span data-ttu-id="942d8-126">L’argument de type fourni pour T doit être l’argument fourni pour U ou en dériver.</span><span class="sxs-lookup"><span data-stu-id="942d8-126">The type argument supplied for T must be or derive from the argument supplied for U.</span></span>|  
  
## <a name="why-use-constraints"></a><span data-ttu-id="942d8-127">Pourquoi utiliser des contraintes ?</span><span class="sxs-lookup"><span data-stu-id="942d8-127">Why Use Constraints</span></span>  
 <span data-ttu-id="942d8-128">Si vous souhaitez examiner un élément dans une liste générique afin de déterminer s’il est valide ou de le comparer à un autre élément, le compilateur doit avoir une certaine garantie que l’opérateur ou la méthode qu’il doit appeler par tous les arguments de type pouvant être spécifiés par le code client est pris en charge.</span><span class="sxs-lookup"><span data-stu-id="942d8-128">If you want to examine an item in a generic list to determine whether it is valid or to compare it to some other item, the compiler must have some guarantee that the operator or method it has to call will be supported by any type argument that might be specified by client code.</span></span> <span data-ttu-id="942d8-129">Cette garantie est obtenue en appliquant une ou plusieurs contraintes à votre définition de classe générique.</span><span class="sxs-lookup"><span data-stu-id="942d8-129">This guarantee is obtained by applying one or more constraints to your generic class definition.</span></span> <span data-ttu-id="942d8-130">Par exemple, la contrainte de classe de base indique au compilateur que seuls les objets de ce type ou dérivés de ce type seront utilisés comme arguments de type.</span><span class="sxs-lookup"><span data-stu-id="942d8-130">For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.</span></span> <span data-ttu-id="942d8-131">Une fois que le compilateur a cette garantie, il peut autoriser les méthodes de ce type à être appelées dans la classe générique.</span><span class="sxs-lookup"><span data-stu-id="942d8-131">Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.</span></span> <span data-ttu-id="942d8-132">Les contraintes sont appliquées à l’aide du mot clé contextuel `where`.</span><span class="sxs-lookup"><span data-stu-id="942d8-132">Constraints are applied by using the contextual keyword `where`.</span></span> <span data-ttu-id="942d8-133">L’exemple de code suivant illustre la fonctionnalité que nous pouvons ajouter à la classe `GenericList<T>` (dans [Introduction aux génériques](../../../csharp/programming-guide/generics/introduction-to-generics.md)) en appliquant une contrainte de classe de base.</span><span class="sxs-lookup"><span data-stu-id="942d8-133">The following code example demonstrates the functionality we can add to the `GenericList<T>` class (in [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)) by applying a base class constraint.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#11](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_1.cs)]  
  
 <span data-ttu-id="942d8-134">La contrainte permet à la classe générique d’utiliser la propriété `Employee.Name`, car il est garanti que tous les éléments de type T sont soit un objet `Employee`, soit un objet qui hérite d’`Employee`.</span><span class="sxs-lookup"><span data-stu-id="942d8-134">The constraint enables the generic class to use the `Employee.Name` property because all items of type T are guaranteed to be either an `Employee` object or an object that inherits from `Employee`.</span></span>  
  
 <span data-ttu-id="942d8-135">Plusieurs contraintes peuvent être appliquées au même paramètre de type, et les contraintes elles-mêmes peuvent être des types génériques, comme suit :</span><span class="sxs-lookup"><span data-stu-id="942d8-135">Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#12](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_2.cs)]  
  
 <span data-ttu-id="942d8-136">En limitant le paramètre de type, vous augmentez le nombre d’opérations et d’appels de méthode autorisés au niveau de celui pris en charge par le type de contrainte et tous les types dans sa hiérarchie d’héritage.</span><span class="sxs-lookup"><span data-stu-id="942d8-136">By constraining the type parameter, you increase the number of allowable operations and method calls to those supported by the constraining type and all types in its inheritance hierarchy.</span></span> <span data-ttu-id="942d8-137">Par conséquent, en concevant des classes ou des méthodes génériques, si vous exécutez des opérations sur les membres génériques au-delà de la simple assignation ou que vous appelez des méthodes non prises en charge par `System.Object`, vous devez appliquer des contraintes au paramètre de type.</span><span class="sxs-lookup"><span data-stu-id="942d8-137">Therefore, when you design generic classes or methods, if you will be performing any operation on the generic members beyond simple assignment or calling any methods not supported by `System.Object`, you will have to apply constraints to the type parameter.</span></span>  
  
 <span data-ttu-id="942d8-138">En appliquant la contrainte `where T : class`, évitez d’utiliser les opérateurs `==` et `!=` sur le paramètre de type, car ces opérateurs testent uniquement l’identité des références, et non l’égalité des valeurs.</span><span class="sxs-lookup"><span data-stu-id="942d8-138">When applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality.</span></span> <span data-ttu-id="942d8-139">C’est le cas même si ces opérateurs sont surchargés dans un type qui est utilisé comme argument.</span><span class="sxs-lookup"><span data-stu-id="942d8-139">This is the case even if these operators are overloaded in a type that is used as an argument.</span></span> <span data-ttu-id="942d8-140">Le code suivant illustre ce point ; la sortie a la valeur false même si la classe <xref:System.String> surcharge l’opérateur `==`.</span><span class="sxs-lookup"><span data-stu-id="942d8-140">The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#13](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_3.cs)]  
  
 <span data-ttu-id="942d8-141">La raison à ce comportement réside dans le fait que le compilateur, au moment de la compilation, sait uniquement que T est un type référence et doit par conséquent utiliser les opérateurs par défaut, valides pour tous les types référence.</span><span class="sxs-lookup"><span data-stu-id="942d8-141">The reason for this behavior is that, at compile time, the compiler only knows that T is a reference type, and therefore must use the default operators that are valid for all reference types.</span></span> <span data-ttu-id="942d8-142">Si vous devez tester l’égalité des valeurs, il est recommandé d’appliquer également la contrainte `where T : IComparable<T>` et d’implémenter cette interface dans toute classe qui sera utilisée pour construire la classe générique.</span><span class="sxs-lookup"><span data-stu-id="942d8-142">If you must test for value equality, the recommended way is to also apply the `where T : IComparable<T>` constraint and implement that interface in any class that will be used to construct the generic class.</span></span>  
  
## <a name="constraining-multiple-parameters"></a><span data-ttu-id="942d8-143">Utilisation de contraintes dans plusieurs paramètres</span><span class="sxs-lookup"><span data-stu-id="942d8-143">Constraining Multiple Parameters</span></span>  
 <span data-ttu-id="942d8-144">Vous pouvez appliquer des contraintes à plusieurs paramètres et plusieurs contraintes à un seul paramètre, comme indiqué dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="942d8-144">You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#64](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_4.cs)]  
  
## <a name="unbounded-type-parameters"></a><span data-ttu-id="942d8-145">Paramètres de type unbounded</span><span class="sxs-lookup"><span data-stu-id="942d8-145">Unbounded Type Parameters</span></span>  
 <span data-ttu-id="942d8-146">Les paramètres de type qui n’ont aucune contrainte, tels que T dans la classe publique `SampleClass<T>{}`, sont appelés paramètres de type unbounded.</span><span class="sxs-lookup"><span data-stu-id="942d8-146">Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters.</span></span> <span data-ttu-id="942d8-147">Les paramètres de type unbounded obéissent aux règles suivantes :</span><span class="sxs-lookup"><span data-stu-id="942d8-147">Unbounded type parameters have the following rules:</span></span>  
  
-   <span data-ttu-id="942d8-148">Les opérateurs `!=` et `==` ne peuvent pas être utilisés, car il n’est pas garanti que l’argument de type concret les prendra en charge.</span><span class="sxs-lookup"><span data-stu-id="942d8-148">The `!=` and `==` operators cannot be used because there is no guarantee that the concrete type argument will support these operators.</span></span>  
  
-   <span data-ttu-id="942d8-149">Ils peuvent être convertis vers et depuis `System.Object` ou être explicitement convertis vers tout type d’interface.</span><span class="sxs-lookup"><span data-stu-id="942d8-149">They can be converted to and from `System.Object` or explicitly converted to any interface type.</span></span>  
  
-   <span data-ttu-id="942d8-150">Vous pouvez les comparer à [null](../../../csharp/language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="942d8-150">You can compare to [null](../../../csharp/language-reference/keywords/null.md).</span></span> <span data-ttu-id="942d8-151">Si un paramètre unbounded est comparé à `null`, la comparaison retourne toujours la valeur false si l’argument de type est un type valeur.</span><span class="sxs-lookup"><span data-stu-id="942d8-151">If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type.</span></span>  
  
## <a name="type-parameters-as-constraints"></a><span data-ttu-id="942d8-152">Paramètres de type en tant que contraintes</span><span class="sxs-lookup"><span data-stu-id="942d8-152">Type Parameters as Constraints</span></span>  
 <span data-ttu-id="942d8-153">L’utilisation d’un paramètre de type générique comme contrainte est utile quand une fonction membre dotée de son propre paramètre de type doit contraindre ce paramètre au paramètre du type conteneur, comme le montre l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="942d8-153">The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#14](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_5.cs)]  
  
 <span data-ttu-id="942d8-154">Dans l’exemple précédent, `T` est une contrainte de type dans le contexte de la méthode `Add` et un paramètre de type unbounded dans le contexte de la classe `List`.</span><span class="sxs-lookup"><span data-stu-id="942d8-154">In the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class.</span></span>  
  
 <span data-ttu-id="942d8-155">Les paramètres de type peuvent également être utilisés comme contraintes dans les définitions de classes génériques.</span><span class="sxs-lookup"><span data-stu-id="942d8-155">Type parameters can also be used as constraints in generic class definitions.</span></span> <span data-ttu-id="942d8-156">Notez que le paramètre de type doit être déclaré entre crochets pointus, ainsi que tous les autres paramètres de type :</span><span class="sxs-lookup"><span data-stu-id="942d8-156">Note that the type parameter must be declared within the angle brackets together with any other type parameters:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#15](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_6.cs)]  
  
 <span data-ttu-id="942d8-157">L’utilité des paramètres de type en tant que contraintes avec les classes génériques est très limitée, car le compilateur ne peut rien deviner à propos du paramètre de type en dehors du fait qu’il dérive de `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="942d8-157">The usefulness of type parameters as constraints with generic classes is very limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`.</span></span> <span data-ttu-id="942d8-158">Utilisez des paramètres de type en tant que contraintes sur les classes génériques dans les scénarios dans lesquels vous souhaitez mettre en application une relation d’héritage entre deux paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="942d8-158">Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="942d8-159">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="942d8-159">See Also</span></span>  
 <xref:System.Collections.Generic>  
 [<span data-ttu-id="942d8-160">Guide de programmation C#</span><span class="sxs-lookup"><span data-stu-id="942d8-160">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="942d8-161">Introduction aux génériques</span><span class="sxs-lookup"><span data-stu-id="942d8-161">Introduction to Generics</span></span>](../../../csharp/programming-guide/generics/introduction-to-generics.md)  
 [<span data-ttu-id="942d8-162">Classes génériques</span><span class="sxs-lookup"><span data-stu-id="942d8-162">Generic Classes</span></span>](../../../csharp/programming-guide/generics/generic-classes.md)  
 [<span data-ttu-id="942d8-163">new, contrainte</span><span class="sxs-lookup"><span data-stu-id="942d8-163">new Constraint</span></span>](../../../csharp/language-reference/keywords/new-constraint.md)
