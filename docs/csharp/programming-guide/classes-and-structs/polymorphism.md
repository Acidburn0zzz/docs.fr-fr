---
title: Polymorphisme (Guide de programmation C#)
ms.date: 2015-07-20
ms.prod: .net
ms.technology:
- devlang-csharp
ms.topic: article
dev_langs:
- CSharp
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
caps.latest.revision: 31
author: BillWagner
ms.author: wiwagn
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: c278a6a931154af97cab5b1ff33124dd31a3fa2e
ms.contentlocale: fr-fr
ms.lasthandoff: 07/28/2017

---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="1c438-102">Polymorphisme (Guide de programmation C#)</span><span class="sxs-lookup"><span data-stu-id="1c438-102">Polymorphism (C# Programming Guide)</span></span>
<span data-ttu-id="1c438-103">Le polymorphisme est souvent considéré comme le troisième pilier d'une programmation orientée objet, après l'encapsulation et l'héritage.</span><span class="sxs-lookup"><span data-stu-id="1c438-103">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="1c438-104">Le polymorphisme est le mot grec qui signifie « plusieurs formes » et il prend deux aspects distincts :</span><span class="sxs-lookup"><span data-stu-id="1c438-104">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>  
  
-   <span data-ttu-id="1c438-105">Au moment de l'exécution, les objets d'une classe dérivée peuvent être traités comme des objets d'une classe de base dans les paramètres de méthode et les collections ou les tableaux.</span><span class="sxs-lookup"><span data-stu-id="1c438-105">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="1c438-106">Lorsque cela se passe, le type déclaré de l'objet n'est plus identique à son type au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="1c438-106">When this occurs, the object's declared type is no longer identical to its run-time type.</span></span>  
  
-   <span data-ttu-id="1c438-107">Les classes de base peuvent définir et implémenter des *méthodes* [virtuelles](../../../csharp/language-reference/keywords/virtual.md), et les classes dérivées peuvent les [substituer](../../../csharp/language-reference/keywords/override.md), ce qui signifie qu’elles fournissent leur propre définition et implémentation.</span><span class="sxs-lookup"><span data-stu-id="1c438-107">Base classes may define and implement [virtual](../../../csharp/language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../../csharp/language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="1c438-108">Au moment de l'exécution, quand le code client appelle la méthode, le CLR recherche le type au moment de l'exécution et appelle cette substitution de la méthode virtuelle.</span><span class="sxs-lookup"><span data-stu-id="1c438-108">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="1c438-109">C'est pourquoi, dans le code source vous pouvez appeler une méthode dans une classe de base, et provoquer l'exécution d'une version de la classe dérivée de la méthode.</span><span class="sxs-lookup"><span data-stu-id="1c438-109">Thus in your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>  
  
 <span data-ttu-id="1c438-110">Les méthodes virtuelles vous permettent d'utiliser des groupes d'objets liés de façon uniforme.</span><span class="sxs-lookup"><span data-stu-id="1c438-110">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="1c438-111">Par exemple, si vous avez une application de dessin qui permet à un utilisateur de créer différents types de formes sur une surface de dessin.</span><span class="sxs-lookup"><span data-stu-id="1c438-111">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="1c438-112">Vous ne savez pas au moment de la compilation les types de formes spécifiques que l'utilisateur va créer.</span><span class="sxs-lookup"><span data-stu-id="1c438-112">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="1c438-113">Cependant, l'application doit conserver une trace des différents types de formes créés et les mettre à jour en réponse aux actions de la souris.</span><span class="sxs-lookup"><span data-stu-id="1c438-113">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="1c438-114">Vous pouvez utiliser le polymorphisme pour résoudre ce problème en deux étapes :</span><span class="sxs-lookup"><span data-stu-id="1c438-114">You can use polymorphism to solve this problem in two basic steps:</span></span>  
  
1.  <span data-ttu-id="1c438-115">Créer une hiérarchie de classe dans laquelle chaque classe de forme dérive d'une classe de base commune.</span><span class="sxs-lookup"><span data-stu-id="1c438-115">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>  
  
2.  <span data-ttu-id="1c438-116">Utiliser une méthode virtuelle pour appeler la méthode appropriée dans une classe dérivée via un seul appel à la méthode de classe de base.</span><span class="sxs-lookup"><span data-stu-id="1c438-116">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>  
  
 <span data-ttu-id="1c438-117">Tout d'abord, créez une classe de base appelée `Shape`, et des classes dérivées telles que `Rectangle`, `Circle`, et `Triangle`.</span><span class="sxs-lookup"><span data-stu-id="1c438-117">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="1c438-118">Donnez à la classe `Shape` une méthode virtuelle appelée `Draw`, et substituez-la dans chaque classe dérivée pour dessiner une forme spécifique représentée par la classe.</span><span class="sxs-lookup"><span data-stu-id="1c438-118">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="1c438-119">Créez un objet `List<Shape>` et ajoutez-lui un cercle, un triangle et un rectangle.</span><span class="sxs-lookup"><span data-stu-id="1c438-119">Create a `List<Shape>` object and add a Circle, Triangle and Rectangle to it.</span></span> <span data-ttu-id="1c438-120">Pour mettre à jour la surface de dessin, utilisez une boucle [foreach](../../../csharp/language-reference/keywords/foreach-in.md) pour l’itération dans la liste et appelez la méthode `Draw` sur chaque objet `Shape` de la liste.</span><span class="sxs-lookup"><span data-stu-id="1c438-120">To update the drawing surface, use a [foreach](../../../csharp/language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="1c438-121">Même si chaque objet de la liste a un type déclaré égal à `Shape`, il s'agit du type au moment de l'exécution (la version substituée de la méthode dans chaque classe dérivée) qui est appelé.</span><span class="sxs-lookup"><span data-stu-id="1c438-121">Even though each object in the list has a declared type of `Shape`, it is the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>  
  
 <span data-ttu-id="1c438-122">[!code-cs[csProgGuideInheritance#50](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_1.cs)]</span><span class="sxs-lookup"><span data-stu-id="1c438-122">[!code-cs[csProgGuideInheritance#50](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_1.cs)]</span></span>  
  
 <span data-ttu-id="1c438-123">En C#, chaque type est polymorphique, car tous les types, y compris les types définis par l'utilisateur, héritent de <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="1c438-123">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  
  
## <a name="polymorphism-overview"></a><span data-ttu-id="1c438-124">Vue d'ensemble du polymorphisme</span><span class="sxs-lookup"><span data-stu-id="1c438-124">Polymorphism Overview</span></span>  
  
### <a name="virtual-members"></a><span data-ttu-id="1c438-125">Membres virtuels</span><span class="sxs-lookup"><span data-stu-id="1c438-125">Virtual Members</span></span>  
 <span data-ttu-id="1c438-126">Quand une classe dérivée hérite d'une classe de base, elle gagne toutes les méthodes, les champs, les propriétés et les événements de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="1c438-126">When a derived class inherits from a base class, it gains all the methods, fields, properties and events of the base class.</span></span> <span data-ttu-id="1c438-127">Le concepteur de la classe dérivée peut choisir</span><span class="sxs-lookup"><span data-stu-id="1c438-127">The designer of the derived class can choose whether to</span></span>  
  
-   <span data-ttu-id="1c438-128">de substituer les membres virtuels dans la classe de base,</span><span class="sxs-lookup"><span data-stu-id="1c438-128">override virtual members in the base class,</span></span>  
  
-   <span data-ttu-id="1c438-129">d'hériter de la méthode de classe de base la plus proche sans la substituer</span><span class="sxs-lookup"><span data-stu-id="1c438-129">inherit the closest base class method without overriding it</span></span>  
  
-   <span data-ttu-id="1c438-130">de définir une nouvelle implémentation non virtuelle de ces membres qui masque les implémentations de la classe de base</span><span class="sxs-lookup"><span data-stu-id="1c438-130">define new non-virtual implementation of those members that hide the base class implementations</span></span>  
  
 <span data-ttu-id="1c438-131">Une classe dérivée ne peut substituer un membre de classe de base que si le membre de classe de base est déclaré comme étant [virtual](../../../csharp/language-reference/keywords/virtual.md) ou [abstract](../../../csharp/language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="1c438-131">A derived class can override a base class member only if the base class member is declared as [virtual](../../../csharp/language-reference/keywords/virtual.md) or [abstract](../../../csharp/language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="1c438-132">Le membre dérivé doit utiliser le mot clé [override](../../../csharp/language-reference/keywords/override.md) pour indiquer explicitement que la méthode est conçue pour participer à l’appel virtuel.</span><span class="sxs-lookup"><span data-stu-id="1c438-132">The derived member must use the [override](../../../csharp/language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="1c438-133">Le code suivant est fourni à titre d'exemple :</span><span class="sxs-lookup"><span data-stu-id="1c438-133">The following code provides an example:</span></span>  
  
 <span data-ttu-id="1c438-134">[!code-cs[csProgGuideInheritance#20](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_2.cs)]</span><span class="sxs-lookup"><span data-stu-id="1c438-134">[!code-cs[csProgGuideInheritance#20](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_2.cs)]</span></span>  
  
 <span data-ttu-id="1c438-135">Les champs ne peuvent pas être virtuels ; seuls les méthodes, propriétés, événements et indexeurs peuvent être virtuels.</span><span class="sxs-lookup"><span data-stu-id="1c438-135">Fields cannot be virtual; only methods, properties, events and indexers can be virtual.</span></span> <span data-ttu-id="1c438-136">Quand une classe dérivée est substituée à un membre virtuel, ce membre est appelé lors de l'accès à une instance de cette classe en tant qu'instance de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="1c438-136">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="1c438-137">Le code suivant est fourni à titre d'exemple :</span><span class="sxs-lookup"><span data-stu-id="1c438-137">The following code provides an example:</span></span>  
  
 <span data-ttu-id="1c438-138">[!code-cs[csProgGuideInheritance#21](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_3.cs)]</span><span class="sxs-lookup"><span data-stu-id="1c438-138">[!code-cs[csProgGuideInheritance#21](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_3.cs)]</span></span>  
  
 <span data-ttu-id="1c438-139">Les méthodes et propriétés virtuelles permettent aux classes dérivées d'étendre une classe de base sans avoir besoin d'utiliser l'implémentation de classe de base d'une méthode.</span><span class="sxs-lookup"><span data-stu-id="1c438-139">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="1c438-140">Pour plus d’informations, consultez [Versioning avec les mots clés override et new](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="1c438-140">For more information, see [Versioning with the Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="1c438-141">Une interface fournit un autre moyen pour définir une méthode ou un ensemble de méthodes dont l'implémentation est confiée aux classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="1c438-141">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="1c438-142">Pour plus d’informations, consultez [Interfaces](../../../csharp/programming-guide/interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="1c438-142">For more information, see [Interfaces](../../../csharp/programming-guide/interfaces/index.md).</span></span>  
  
### <a name="hiding-base-class-members-with-new-members"></a><span data-ttu-id="1c438-143">Masquage des membres de classe de base par de nouveaux membres</span><span class="sxs-lookup"><span data-stu-id="1c438-143">Hiding Base Class Members with New Members</span></span>  
 <span data-ttu-id="1c438-144">Si vous voulez que votre membre dérivé ait le même nom qu’un membre d’une classe de base, mais que vous ne voulez pas qu’il participe à l’appel virtuel, vous pouvez utiliser le mot clé [new](../../../csharp/language-reference/keywords/new.md).</span><span class="sxs-lookup"><span data-stu-id="1c438-144">If you want your derived member to have the same name as a member in a base class, but you do not want it to participate in virtual invocation, you can use the [new](../../../csharp/language-reference/keywords/new.md) keyword.</span></span> <span data-ttu-id="1c438-145">Le mot clé `new` est placé avec le type de retour d'un membre de classe qui est remplacé.</span><span class="sxs-lookup"><span data-stu-id="1c438-145">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="1c438-146">Le code suivant est fourni à titre d'exemple :</span><span class="sxs-lookup"><span data-stu-id="1c438-146">The following code provides an example:</span></span>  
  
 <span data-ttu-id="1c438-147">[!code-cs[csProgGuideInheritance#18](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_4.cs)]</span><span class="sxs-lookup"><span data-stu-id="1c438-147">[!code-cs[csProgGuideInheritance#18](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_4.cs)]</span></span>  
  
 <span data-ttu-id="1c438-148">Les membres de classe de base masqués sont toujours accessibles à partir du code client en effectuant un cast de l'instance de la classe dérivée vers une instance de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="1c438-148">Hidden base class members can still be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="1c438-149">Exemple :</span><span class="sxs-lookup"><span data-stu-id="1c438-149">For example:</span></span>  
  
 <span data-ttu-id="1c438-150">[!code-cs[csProgGuideInheritance#19](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_5.cs)]</span><span class="sxs-lookup"><span data-stu-id="1c438-150">[!code-cs[csProgGuideInheritance#19](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_5.cs)]</span></span>  
  
### <a name="preventing-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="1c438-151">Empêcher les classes dérivées de remplacer les membres virtuels</span><span class="sxs-lookup"><span data-stu-id="1c438-151">Preventing Derived Classes from Overriding Virtual Members</span></span>  
 <span data-ttu-id="1c438-152">Les membres virtuels restent virtuels indéfiniment, quel que soit le nombre de classes déclarées entre le membre virtuel et la classe qui l'a déclaré à l'origine.</span><span class="sxs-lookup"><span data-stu-id="1c438-152">Virtual members remain virtual indefinitely, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="1c438-153">Si la classe A déclare un membre virtuel, et la classe B dérive de A, et la classe C dérive de B, la classe C hérite du membre virtuel et peut le remplacer, que la classe B ait ou non déclarée une substitution pour ce membre.</span><span class="sxs-lookup"><span data-stu-id="1c438-153">If class A declares a virtual member, and class B derives from A, and class C derives from B, class C inherits the virtual member, and has the option to override it, regardless of whether class B declared an override for that member.</span></span> <span data-ttu-id="1c438-154">Le code suivant est fourni à titre d'exemple :</span><span class="sxs-lookup"><span data-stu-id="1c438-154">The following code provides an example:</span></span>  
  
 <span data-ttu-id="1c438-155">[!code-cs[csProgGuideInheritance#22](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_6.cs)]</span><span class="sxs-lookup"><span data-stu-id="1c438-155">[!code-cs[csProgGuideInheritance#22](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_6.cs)]</span></span>  
  
 <span data-ttu-id="1c438-156">Une classe dérivée peut arrêter l’héritage virtuel en déclarant une substitution comme étant [sealed](../../../csharp/language-reference/keywords/sealed.md).</span><span class="sxs-lookup"><span data-stu-id="1c438-156">A derived class can stop virtual inheritance by declaring an override as [sealed](../../../csharp/language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="1c438-157">Cela nécessite l'ajout du mot clé `sealed` avant le mot clé `override` dans la déclaration de membre de classe.</span><span class="sxs-lookup"><span data-stu-id="1c438-157">This requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="1c438-158">Le code suivant est fourni à titre d'exemple :</span><span class="sxs-lookup"><span data-stu-id="1c438-158">The following code provides an example:</span></span>  
  
 <span data-ttu-id="1c438-159">[!code-cs[csProgGuideInheritance#24](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_7.cs)]</span><span class="sxs-lookup"><span data-stu-id="1c438-159">[!code-cs[csProgGuideInheritance#24](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_7.cs)]</span></span>  
  
 <span data-ttu-id="1c438-160">Dans l’exemple précédent, la méthode `DoWork` n’est plus virtuelle vis-à-vis des classes dérivées de C. Elle l’est toujours pour les instances de C, même si elles sont converties en type B ou A. Les méthodes sealed peuvent être remplacées par des classes dérivées à l’aide du mot clé `new`, comme le montre l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="1c438-160">In the previous example, the method `DoWork` is no longer virtual to any class derived from C. It is still virtual for instances of C, even if they are cast to type B or type A. Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>  
  
 <span data-ttu-id="1c438-161">[!code-cs[csProgGuideInheritance#25](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_8.cs)]</span><span class="sxs-lookup"><span data-stu-id="1c438-161">[!code-cs[csProgGuideInheritance#25](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_8.cs)]</span></span>  
  
 <span data-ttu-id="1c438-162">Dans ce cas, si `DoWork` est appelé sur D à l'aide d'une variable de type D, le nouveau `DoWork` est appelé.</span><span class="sxs-lookup"><span data-stu-id="1c438-162">In this case, if `DoWork` is called on D using a variable of type D, the new `DoWork` is called.</span></span> <span data-ttu-id="1c438-163">Si une variable de type C, B, ou A est utilisée pour accéder à une instance de D, un appel à `DoWork` suivra les règles de l'héritage virtuel, en routant ces appels vers l'implémentation de `DoWork` dans la classe C.</span><span class="sxs-lookup"><span data-stu-id="1c438-163">If a variable of type C, B, or A is used to access an instance of D, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class C.</span></span>  
  
### <a name="accessing-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="1c438-164">Accès aux membres virtuels de la classe de base à partir de classes dérivées</span><span class="sxs-lookup"><span data-stu-id="1c438-164">Accessing Base Class Virtual Members from Derived Classes</span></span>  
 <span data-ttu-id="1c438-165">Une classe dérivée qui a remplacé ou substitué une méthode ou une propriété peut encore accéder à la méthode ou la propriété dans la classe de base à l'aide du mot clé base.</span><span class="sxs-lookup"><span data-stu-id="1c438-165">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the base keyword.</span></span> <span data-ttu-id="1c438-166">Le code suivant est fourni à titre d'exemple :</span><span class="sxs-lookup"><span data-stu-id="1c438-166">The following code provides an example:</span></span>  
  
 <span data-ttu-id="1c438-167">[!code-cs[csProgGuideInheritance#26](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_9.cs)]</span><span class="sxs-lookup"><span data-stu-id="1c438-167">[!code-cs[csProgGuideInheritance#26](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_9.cs)]</span></span>  
  
 <span data-ttu-id="1c438-168">Pour plus d’informations, consultez [base](../../../csharp/language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="1c438-168">For more information, see [base](../../../csharp/language-reference/keywords/base.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1c438-169">Il est recommandé que les membres virtuels utilisent `base` pour appeler l'implémentation de classe de base de ce membre dans leur propre implémentation.</span><span class="sxs-lookup"><span data-stu-id="1c438-169">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="1c438-170">L'exécution du comportement de classe de base permet à la classe dérivée de se concentrer sur l'implémentation du comportement spécifique à la classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="1c438-170">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="1c438-171">Si l'implémentation de classe de base n'est pas appelée, la classe dérivée doit rendre son comportement compatible avec le comportement de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="1c438-171">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>  
  
## <a name="in-this-section"></a><span data-ttu-id="1c438-172">Dans cette section</span><span class="sxs-lookup"><span data-stu-id="1c438-172">In This Section</span></span>  
  
-   [<span data-ttu-id="1c438-173">Versioning avec les mots clés override et new</span><span class="sxs-lookup"><span data-stu-id="1c438-173">Versioning with the Override and New Keywords</span></span>](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md)  
  
-   [<span data-ttu-id="1c438-174">Savoir quand utiliser les mots clés override et new</span><span class="sxs-lookup"><span data-stu-id="1c438-174">Knowing When to Use Override and New Keywords</span></span>](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md)  
  
-   [<span data-ttu-id="1c438-175">Guide pratique pour substituer la méthode ToString</span><span class="sxs-lookup"><span data-stu-id="1c438-175">How to: Override the ToString Method</span></span>](../../../csharp/programming-guide/classes-and-structs/how-to-override-the-tostring-method.md)  
  
## <a name="see-also"></a><span data-ttu-id="1c438-176">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="1c438-176">See Also</span></span>  
 <span data-ttu-id="1c438-177">[Guide de programmation C#](../../../csharp/programming-guide/index.md) </span><span class="sxs-lookup"><span data-stu-id="1c438-177">[C# Programming Guide](../../../csharp/programming-guide/index.md) </span></span>  
 <span data-ttu-id="1c438-178">[Guide de programmation C#](../../../csharp/programming-guide/index.md) </span><span class="sxs-lookup"><span data-stu-id="1c438-178">[C# Programming Guide](../../../csharp/programming-guide/index.md) </span></span>  
 <span data-ttu-id="1c438-179">[Héritage](../../../csharp/programming-guide/classes-and-structs/inheritance.md) </span><span class="sxs-lookup"><span data-stu-id="1c438-179">[Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md) </span></span>  
 <span data-ttu-id="1c438-180">[Classes abstract et sealed et membres de classe](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md) </span><span class="sxs-lookup"><span data-stu-id="1c438-180">[Abstract and Sealed Classes and Class Members](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md) </span></span>  
 <span data-ttu-id="1c438-181">[Méthodes](../../../csharp/programming-guide/classes-and-structs/methods.md) </span><span class="sxs-lookup"><span data-stu-id="1c438-181">[Methods](../../../csharp/programming-guide/classes-and-structs/methods.md) </span></span>  
 <span data-ttu-id="1c438-182">[Événements](../../../csharp/programming-guide/events/index.md) </span><span class="sxs-lookup"><span data-stu-id="1c438-182">[Events](../../../csharp/programming-guide/events/index.md) </span></span>  
 <span data-ttu-id="1c438-183">[Propriétés](../../../csharp/programming-guide/classes-and-structs/properties.md) </span><span class="sxs-lookup"><span data-stu-id="1c438-183">[Properties](../../../csharp/programming-guide/classes-and-structs/properties.md) </span></span>  
 <span data-ttu-id="1c438-184">[Indexeurs](../../../csharp/programming-guide/indexers/index.md) </span><span class="sxs-lookup"><span data-stu-id="1c438-184">[Indexers](../../../csharp/programming-guide/indexers/index.md) </span></span>  
 [<span data-ttu-id="1c438-185">Types</span><span class="sxs-lookup"><span data-stu-id="1c438-185">Types</span></span>](../../../csharp/programming-guide/types/index.md)

