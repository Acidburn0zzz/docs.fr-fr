---
title: "Guide pratique pour itérer au sein d’une arborescence de répertoires (Guide de programmation C#)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology:
- devlang-csharp
ms.topic: article
helpviewer_keywords:
- iterating through folders [C#]
- file iteration [C#]
ms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7
caps.latest.revision: 
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: 7f45bdc4a08922842b079be3ef9d112693ca5d7a
ms.sourcegitcommit: 75a180acb5d8a2dbd4a52915ce8e980749fb1d05
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/24/2018
---
# <a name="how-to-iterate-through-a-directory-tree-c-programming-guide"></a><span data-ttu-id="b99fd-102">Guide pratique pour itérer au sein d’une arborescence de répertoires (Guide de programmation C#)</span><span class="sxs-lookup"><span data-stu-id="b99fd-102">How to: Iterate Through a Directory Tree (C# Programming Guide)</span></span>
<span data-ttu-id="b99fd-103">L’expression « itérer au sein d’une arborescence de répertoires » signifie accéder à chaque fichier dans chaque sous-répertoire imbriqué sous un dossier racine spécifié, à n’importe quelle profondeur.</span><span class="sxs-lookup"><span data-stu-id="b99fd-103">The phrase "iterate a directory tree" means to access each file in each nested subdirectory under a specified root folder, to any depth.</span></span> <span data-ttu-id="b99fd-104">Vous ne devez pas nécessairement ouvrir chaque fichier.</span><span class="sxs-lookup"><span data-stu-id="b99fd-104">You do not necessarily have to open each file.</span></span> <span data-ttu-id="b99fd-105">Vous pouvez simplement récupérer le nom du fichier ou du sous-répertoire sous forme de `string`, ou vous pouvez récupérer des informations supplémentaires sous la forme d’un objet <xref:System.IO.FileInfo?displayProperty=nameWithType> ou <xref:System.IO.DirectoryInfo?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b99fd-105">You can just retrieve the name of the file or subdirectory as a `string`, or you can retrieve additional information in the form of a <xref:System.IO.FileInfo?displayProperty=nameWithType> or <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b99fd-106">Dans Windows, les termes « répertoire » et « dossier » sont utilisés indifféremment.</span><span class="sxs-lookup"><span data-stu-id="b99fd-106">In Windows, the terms "directory" and "folder" are used interchangeably.</span></span> <span data-ttu-id="b99fd-107">La plus grande partie de la documentation et du texte d’interface utilisateur utilise le terme « dossier », mais la bibliothèque de classes [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] utilise le terme « répertoire ».</span><span class="sxs-lookup"><span data-stu-id="b99fd-107">Most documentation and user interface text uses the term "folder," but the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] class library uses the term "directory."</span></span>  
  
 <span data-ttu-id="b99fd-108">Dans le cas le plus simple, où vous êtes sûr de disposer des autorisations d’accès à tous les répertoires situés sous une racine spécifiée, vous pouvez utiliser l’indicateur `System.IO.SearchOption.AllDirectories`.</span><span class="sxs-lookup"><span data-stu-id="b99fd-108">In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the `System.IO.SearchOption.AllDirectories` flag.</span></span> <span data-ttu-id="b99fd-109">Cet indicateur retourne tous les sous-répertoires imbriqués qui correspondent au modèle spécifié.</span><span class="sxs-lookup"><span data-stu-id="b99fd-109">This flag returns all the nested subdirectories that match the specified pattern.</span></span> <span data-ttu-id="b99fd-110">L’exemple suivant montre comment utiliser cet indicateur.</span><span class="sxs-lookup"><span data-stu-id="b99fd-110">The following example shows how to use this flag.</span></span>  
  
```csharp  
root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);  
```  
  
 <span data-ttu-id="b99fd-111">La faiblesse de cette approche est que si l’un des sous-répertoires sous la racine spécifiée provoque une exception <xref:System.IO.DirectoryNotFoundException> ou <xref:System.UnauthorizedAccessException>, la totalité de la méthode échoue et ne retourne pas de répertoire.</span><span class="sxs-lookup"><span data-stu-id="b99fd-111">The weakness in this approach is that if any one of the subdirectories under the specified root causes a <xref:System.IO.DirectoryNotFoundException> or <xref:System.UnauthorizedAccessException>, the whole method fails and returns no directories.</span></span> <span data-ttu-id="b99fd-112">Il en va de même quand vous utilisez la méthode <xref:System.IO.DirectoryInfo.GetFiles%2A>.</span><span class="sxs-lookup"><span data-stu-id="b99fd-112">The same is true when you use the <xref:System.IO.DirectoryInfo.GetFiles%2A> method.</span></span> <span data-ttu-id="b99fd-113">Si vous devez gérer ces exceptions dans des sous-dossiers spécifiques, vous devez parcourir manuellement l’arborescence de répertoires, comme illustré dans les exemples suivants.</span><span class="sxs-lookup"><span data-stu-id="b99fd-113">If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.</span></span>  
  
 <span data-ttu-id="b99fd-114">Quand vous parcourez manuellement une arborescence de répertoires, vous pouvez gérer d’abord les sous-répertoires (*balayage pré-ordre*), ou d’abord les fichiers (*balayage post-ordre*).</span><span class="sxs-lookup"><span data-stu-id="b99fd-114">When you manually walk a directory tree, you can handle the subdirectories first (*pre-order traversal*), or the files first (*post-order traversal*).</span></span> <span data-ttu-id="b99fd-115">Si vous effectuez un balayage pré-ordre, vous parcourez l’arborescence entière sous le dossier actif avant d’itérer au sein des fichiers qui sont directement dans le dossier lui-même.</span><span class="sxs-lookup"><span data-stu-id="b99fd-115">If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself.</span></span> <span data-ttu-id="b99fd-116">Les exemples fournis plus loin dans ce document effectuent un balayage post-ordre, mais vous pouvez les modifier facilement pour effectuer un balayage pré-ordre.</span><span class="sxs-lookup"><span data-stu-id="b99fd-116">The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.</span></span>  
  
 <span data-ttu-id="b99fd-117">Une autre option consiste à utiliser la récurrence ou un balayage de pile.</span><span class="sxs-lookup"><span data-stu-id="b99fd-117">Another option is whether to use recursion or a stack-based traversal.</span></span> <span data-ttu-id="b99fd-118">Les exemples fournis plus loin dans ce document illustrent les deux approches.</span><span class="sxs-lookup"><span data-stu-id="b99fd-118">The examples later in this document show both approaches.</span></span>  
  
 <span data-ttu-id="b99fd-119">Si vous devez effectuer diverses opérations sur des fichiers et des dossiers, vous pouvez modulariser ces exemples en refactorisant l’opération dans des fonctions distinctes que vous pouvez appeler à l’aide d’un délégué unique.</span><span class="sxs-lookup"><span data-stu-id="b99fd-119">If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b99fd-120">Les systèmes de fichiers NTFS peuvent contenir des *points d’analyse* sous la forme de *points de jonction*, de *liens symboliques* et de *liens physiques*.</span><span class="sxs-lookup"><span data-stu-id="b99fd-120">NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*.</span></span> <span data-ttu-id="b99fd-121">Les méthodes .NET Framework telles que <xref:System.IO.DirectoryInfo.GetFiles%2A> et <xref:System.IO.DirectoryInfo.GetDirectories%2A> ne retournent pas de sous-répertoires situés sous un point d’analyse.</span><span class="sxs-lookup"><span data-stu-id="b99fd-121">The .NET Framework methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point.</span></span> <span data-ttu-id="b99fd-122">Ce comportement vous protège contre le risque d’entrer dans une boucle infinie quand deux points d’analyse se référencent l’un l’autre.</span><span class="sxs-lookup"><span data-stu-id="b99fd-122">This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other.</span></span> <span data-ttu-id="b99fd-123">En général, lors de l’utilisation de points d’analyse vous devez faire attention à ne pas involontairement modifier ou supprimer des fichiers.</span><span class="sxs-lookup"><span data-stu-id="b99fd-123">In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files.</span></span> <span data-ttu-id="b99fd-124">Si vous avez besoin d’un contrôle précis sur les points d’analyse, utilisez du code natif ou un appel de code non managé pour appeler directement les méthodes de système de fichiers Win32 appropriées.</span><span class="sxs-lookup"><span data-stu-id="b99fd-124">If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="b99fd-125">Exemple</span><span class="sxs-lookup"><span data-stu-id="b99fd-125">Example</span></span>  
 <span data-ttu-id="b99fd-126">L’exemple suivant montre comment parcourir une arborescence de répertoires à l’aide de la récurrence.</span><span class="sxs-lookup"><span data-stu-id="b99fd-126">The following example shows how to walk a directory tree by using recursion.</span></span> <span data-ttu-id="b99fd-127">L’approche récursive est élégante, mais susceptible de provoquer une exception de dépassement de capacité de la pile si l’arborescence de répertoires est volumineuse et profondément imbriquée.</span><span class="sxs-lookup"><span data-stu-id="b99fd-127">The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.</span></span>  
  
 <span data-ttu-id="b99fd-128">Les exceptions particulières gérées et les actions qui sont effectuées sur chaque fichier ou dossier sont fournies à titre d’exemple uniquement.</span><span class="sxs-lookup"><span data-stu-id="b99fd-128">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="b99fd-129">Vous devez modifier ce code pour répondre à vos besoins spécifiques.</span><span class="sxs-lookup"><span data-stu-id="b99fd-129">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="b99fd-130">Pour plus d’informations, consultez les commentaires du code.</span><span class="sxs-lookup"><span data-stu-id="b99fd-130">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#1](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_1.cs)]  
  
## <a name="example"></a><span data-ttu-id="b99fd-131">Exemple</span><span class="sxs-lookup"><span data-stu-id="b99fd-131">Example</span></span>  
 <span data-ttu-id="b99fd-132">L’exemple suivant montre comment itérer au sein des fichiers et des dossiers dans une arborescence de répertoires sans utiliser la récurrence.</span><span class="sxs-lookup"><span data-stu-id="b99fd-132">The following example shows how to iterate through files and folders in a directory tree without using recursion.</span></span> <span data-ttu-id="b99fd-133">Cette technique utilise le type de collection <xref:System.Collections.Generic.Stack%601> générique, qui est une pile LIFO (dernier entré, premier sorti).</span><span class="sxs-lookup"><span data-stu-id="b99fd-133">This technique uses the generic <xref:System.Collections.Generic.Stack%601> collection type, which is a last in first out (LIFO) stack.</span></span>  
  
 <span data-ttu-id="b99fd-134">Les exceptions particulières gérées et les actions qui sont effectuées sur chaque fichier ou dossier sont fournies à titre d’exemple uniquement.</span><span class="sxs-lookup"><span data-stu-id="b99fd-134">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="b99fd-135">Vous devez modifier ce code pour répondre à vos besoins spécifiques.</span><span class="sxs-lookup"><span data-stu-id="b99fd-135">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="b99fd-136">Pour plus d’informations, consultez les commentaires du code.</span><span class="sxs-lookup"><span data-stu-id="b99fd-136">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#2](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_2.cs)]  
  
 <span data-ttu-id="b99fd-137">Cela prend généralement trop de temps de tester chaque dossier pour déterminer si votre application est autorisée à l’ouvrir.</span><span class="sxs-lookup"><span data-stu-id="b99fd-137">It is generally too time-consuming to test every folder to determine whether your application has permission to open it.</span></span> <span data-ttu-id="b99fd-138">Par conséquent, l’exemple de code englobe simplement cette partie de l’opération dans un bloc `try/catch`.</span><span class="sxs-lookup"><span data-stu-id="b99fd-138">Therefore, the code example just encloses that part of the operation in a `try/catch` block.</span></span> <span data-ttu-id="b99fd-139">Vous pouvez modifier le bloc `catch` pour que, quand l’accès à un dossier vous est refusé, vous essayiez d’élever vos autorisations et d’y accéder à nouveau.</span><span class="sxs-lookup"><span data-stu-id="b99fd-139">You can modify the `catch` block so that when you are denied access to a folder, you try to elevate your permissions and then access it again.</span></span> <span data-ttu-id="b99fd-140">En règle générale, vous devez intercepter uniquement les exceptions que vous pouvez gérer sans laisser votre application dans un état inconnu.</span><span class="sxs-lookup"><span data-stu-id="b99fd-140">As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.</span></span>  
  
 <span data-ttu-id="b99fd-141">Si vous devez stocker le contenu d’une arborescence de répertoires en mémoire ou sur disque, la meilleure option consiste à stocker uniquement la propriété <xref:System.IO.FileSystemInfo.FullName%2A> (de type `string`) pour chaque fichier.</span><span class="sxs-lookup"><span data-stu-id="b99fd-141">If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <xref:System.IO.FileSystemInfo.FullName%2A> property (of type `string`) for each file.</span></span> <span data-ttu-id="b99fd-142">Vous pouvez ensuite utiliser cette chaîne pour créer un objet <xref:System.IO.FileInfo> ou <xref:System.IO.DirectoryInfo>, si nécessaire, ou ouvrir les fichiers qui nécessitent un traitement supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="b99fd-142">You can then use this string to create a new <xref:System.IO.FileInfo> or <xref:System.IO.DirectoryInfo> object as necessary, or open any file that requires additional processing.</span></span>  
  
## <a name="robust-programming"></a><span data-ttu-id="b99fd-143">Programmation fiable</span><span class="sxs-lookup"><span data-stu-id="b99fd-143">Robust Programming</span></span>  
 <span data-ttu-id="b99fd-144">Tout code d’itération de fichiers fiable doit tenir compte de nombreuses complexités du système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="b99fd-144">Robust file iteration code must take into account many complexities of the file system.</span></span> <span data-ttu-id="b99fd-145">Pour plus d’informations sur le système de fichiers Windows, consultez [Référence technique sur NTFS](https://technet.microsoft.com/library/81cc8a8a-bd32-4786-a849-03245d68d8e4).</span><span class="sxs-lookup"><span data-stu-id="b99fd-145">For more information on the Windows file system, see [NTFS Technical Reference](https://technet.microsoft.com/library/81cc8a8a-bd32-4786-a849-03245d68d8e4).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b99fd-146">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="b99fd-146">See Also</span></span>  
 <xref:System.IO>  
 [<span data-ttu-id="b99fd-147">LINQ et répertoires de fichiers</span><span class="sxs-lookup"><span data-stu-id="b99fd-147">LINQ and File Directories</span></span>](../../../csharp/programming-guide/concepts/linq/linq-and-file-directories.md)  
 [<span data-ttu-id="b99fd-148">Système de fichiers et Registre (Guide de programmation C#)</span><span class="sxs-lookup"><span data-stu-id="b99fd-148">File System and the Registry (C# Programming Guide)</span></span>](../../../csharp/programming-guide/file-system/index.md)
