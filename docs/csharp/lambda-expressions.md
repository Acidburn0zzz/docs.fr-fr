---
title: Expressions lambda
description: Découvrez comment utiliser des expressions lambda, qui sont des blocs de code exécutable qui peuvent être passés comme arguments.
ms.author: ronpet
author: rpetrusha
ms.date: 11/22/2016
ms.assetid: b6a0539a-8ce5-4da7-adcf-44be345a2714
ms.openlocfilehash: 2469e8a0fbf8181a720201637ab5ac5ef02055d4
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/01/2018
ms.locfileid: "43400863"
---
# <a name="lambda-expressions"></a><span data-ttu-id="1f837-103">Expressions lambda</span><span class="sxs-lookup"><span data-stu-id="1f837-103">Lambda expressions</span></span> #

<span data-ttu-id="1f837-104">Une *expression lambda* est un bloc de code (une expression ou un bloc d’instructions) qui est traité comme un objet.</span><span class="sxs-lookup"><span data-stu-id="1f837-104">A *lambda expression* is a block of code (an expression or a statement block) that is treated as an object.</span></span> <span data-ttu-id="1f837-105">Elle peut être passée comme argument à des méthodes, et peut aussi être retournée par des appels de méthode.</span><span class="sxs-lookup"><span data-stu-id="1f837-105">It can be passed as an argument to methods, and it can also be returned by method calls.</span></span> <span data-ttu-id="1f837-106">Les expressions lambda sont largement utilisées pour :</span><span class="sxs-lookup"><span data-stu-id="1f837-106">Lambda expressions are used extensively for:</span></span>

- <span data-ttu-id="1f837-107">Passer le code à exécuter à des méthodes asynchrones, comme <xref:System.Threading.Tasks.Task.Run(System.Action)>.</span><span class="sxs-lookup"><span data-stu-id="1f837-107">Passing the code that is to be executed to asynchronous methods, such as <xref:System.Threading.Tasks.Task.Run(System.Action)>.</span></span>

- <span data-ttu-id="1f837-108">Écrire des [expressions de requête LINQ](linq/index.md).</span><span class="sxs-lookup"><span data-stu-id="1f837-108">Writing [LINQ query expressions](linq/index.md).</span></span>

- <span data-ttu-id="1f837-109">Créer des [arborescences d’expressions](expression-trees-building.md).</span><span class="sxs-lookup"><span data-stu-id="1f837-109">Creating [expression trees](expression-trees-building.md).</span></span>

<span data-ttu-id="1f837-110">Les expressions lambda sont du code qui peut être représenté comme un délégué, ou comme une arborescence d’expressions qui est compilée en délégué.</span><span class="sxs-lookup"><span data-stu-id="1f837-110">Lambda expressions are code that can be represented either as a delegate, or as an expression tree that compiles to a delegate.</span></span> <span data-ttu-id="1f837-111">Le type délégué spécifique d’une expression lambda dépend de ses paramètres et de sa valeur de retour.</span><span class="sxs-lookup"><span data-stu-id="1f837-111">The specific delegate type of a lambda expression depends on its parameters and return value.</span></span> <span data-ttu-id="1f837-112">Les expressions lambda qui ne retournent pas de valeur correspondent à un délégué `Action` spécifique, en fonction du nombre de ses paramètres.</span><span class="sxs-lookup"><span data-stu-id="1f837-112">Lambda expressions that don't return a value correspond to a specific `Action` delegate, depending on its number of parameters.</span></span> <span data-ttu-id="1f837-113">Les expressions lambda qui retournent une valeur correspondent à un délégué `Func` spécifique, en fonction du nombre de ses paramètres.</span><span class="sxs-lookup"><span data-stu-id="1f837-113">Lambda expressions that return a value correspond to a specific `Func` delegate, depending on its number of parameters.</span></span> <span data-ttu-id="1f837-114">Par exemple, une expression lambda qui a deux paramètres, mais qui ne retourne aucune valeur correspond à un délégué <xref:System.Action%602>.</span><span class="sxs-lookup"><span data-stu-id="1f837-114">For example, a lambda expression that has two parameters but returns no value corresponds to an <xref:System.Action%602> delegate.</span></span> <span data-ttu-id="1f837-115">Une expression lambda qui a un paramètre et qui retourne une valeur correspond à un délégué <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="1f837-115">A lambda expression that has one parameter and returns a value corresponds to <xref:System.Func%602> delegate.</span></span>

<span data-ttu-id="1f837-116">Une expression lambda utilise `=>`, l’[opérateur de déclaration lambda](language-reference/operators/lambda-operator.md), pour séparer la liste des paramètres de l’expression lambda de son code exécutable.</span><span class="sxs-lookup"><span data-stu-id="1f837-116">A lambda expression uses `=>`, the [lambda declaration operator](language-reference/operators/lambda-operator.md), to separate the lambda's parameter list from its executable code.</span></span> <span data-ttu-id="1f837-117">Pour créer une expression lambda, vous spécifiez des paramètres d’entrée (le cas échéant) du côté gauche de l’opérateur lambda, et vous placez l’expression ou le bloc d’instructions de l’autre côté.</span><span class="sxs-lookup"><span data-stu-id="1f837-117">To create a lambda expression, you specify input parameters (if any) on the left side of the lambda operator, and you put the expression or statement block on the other side.</span></span> <span data-ttu-id="1f837-118">Par exemple, l’expression lambda d’une seule ligne `x => x * x` spécifie un paramètre nommé `x` et retourne la valeur `x` élevée au carré.</span><span class="sxs-lookup"><span data-stu-id="1f837-118">For example, the single-line lambda expression `x => x * x` specifies a parameter that’s named `x` and returns the value of `x` squared.</span></span> <span data-ttu-id="1f837-119">Vous pouvez assigner cette expression à un type délégué, comme dans l'exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="1f837-119">You can assign this expression to a delegate type, as the following example shows:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/lambda1.cs#1)]

<span data-ttu-id="1f837-120">Vous pouvez aussi le passer directement comme argument de méthode :</span><span class="sxs-lookup"><span data-stu-id="1f837-120">Or you can pass it directly as a method argument:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/lambda2.cs#2)]

## <a name="expression-lambdas"></a><span data-ttu-id="1f837-121">Expressions lambdas</span><span class="sxs-lookup"><span data-stu-id="1f837-121">Expression lambdas</span></span> ##

 <span data-ttu-id="1f837-122">Une expression lambda avec une expression du côté droit de l’opérateur => est appelée *expression lambda*.</span><span class="sxs-lookup"><span data-stu-id="1f837-122">A lambda expression with an expression on the right side of the => operator is called an *expression lambda*.</span></span> <span data-ttu-id="1f837-123">Les expressions lambda sont utilisées en grand nombre dans la construction d’[arborescences d’expressions](expression-trees.md).</span><span class="sxs-lookup"><span data-stu-id="1f837-123">Expression lambdas are used extensively in the construction of [expression trees](expression-trees.md).</span></span> <span data-ttu-id="1f837-124">Une expression lambda retourne le résultat de l'expression et prend la forme de base suivante :</span><span class="sxs-lookup"><span data-stu-id="1f837-124">An expression lambda returns the result of the expression and takes the following basic form:</span></span>

```csharp
(input parameters) => expression
```

<span data-ttu-id="1f837-125">Les parenthèses sont facultatives uniquement si le lambda comporte un paramètre d'entrée ; sinon, elles sont obligatoires.</span><span class="sxs-lookup"><span data-stu-id="1f837-125">The parentheses are optional only if the lambda has one input parameter; otherwise they are required.</span></span> <span data-ttu-id="1f837-126">Utilisez des parenthèses vides s'il n'y a aucun paramètre d'entrée :</span><span class="sxs-lookup"><span data-stu-id="1f837-126">Specify zero input parameters with empty parentheses:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/expression3.cs#1)]

<span data-ttu-id="1f837-127">Les paramètres d'entrée sont séparés par des virgules entre parenthèses :</span><span class="sxs-lookup"><span data-stu-id="1f837-127">Two or more input parameters are separated by commas enclosed in parentheses:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/expression3.cs#2)]

<span data-ttu-id="1f837-128">En règle générale, le compilateur utilise l’inférence de type pour déterminer les types des paramètres.</span><span class="sxs-lookup"><span data-stu-id="1f837-128">Ordinarily, the compiler uses type inference in determining parameter types.</span></span> <span data-ttu-id="1f837-129">Il est cependant parfois difficile, voire impossible, pour le compilateur d’inférer les types en entrée.</span><span class="sxs-lookup"><span data-stu-id="1f837-129">However, sometimes it is difficult or impossible for the compiler to infer the input types.</span></span> <span data-ttu-id="1f837-130">Dans ce cas, vous pouvez spécifier les types explicitement, comme dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="1f837-130">When this occurs, you can specify the types explicitly, as in the following example:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/expression3.cs#3)]

<span data-ttu-id="1f837-131">Notez dans l'exemple précédent que le corps d'une expression lambda peut se composer d'un appel de méthode.</span><span class="sxs-lookup"><span data-stu-id="1f837-131">Note in the previous example that the body of an expression lambda can consist of a method call.</span></span> <span data-ttu-id="1f837-132">Toutefois, si vous créez des arborescences d’expressions qui sont évaluées en dehors du .NET Framework, comme dans SQL Server ou Entity Framework (EF), vous devez éviter d’utiliser les appels de méthode dans les expressions lambda, car les méthodes peuvent n’avoir aucune signification en dehors du contexte de l’implémentation .NET.</span><span class="sxs-lookup"><span data-stu-id="1f837-132">However, if you are creating expression trees that are evaluated outside of the .NET Framework, such as in SQL Server or Entity Framework (EF), you should refrain from using method calls in lambda expressions, since the methods may have no meaning outside the context of the .NET implementation.</span></span> <span data-ttu-id="1f837-133">Si vous choisissez d’utiliser des appels de méthode dans ce cas, veillez à les tester minutieusement pour vérifier que ces appels de méthode peuvent être résolus correctement.</span><span class="sxs-lookup"><span data-stu-id="1f837-133">If you do choose to use method calls in this case, be sure to test them thoroughly to ensure that the method calls can be successfuly resolved.</span></span>

## <a name="statement-lambdas"></a><span data-ttu-id="1f837-134">Instructions lambda</span><span class="sxs-lookup"><span data-stu-id="1f837-134">Statement lambdas</span></span> ##

<span data-ttu-id="1f837-135">Une instruction lambda ressemble à une expression lambda, mais l'instruction ou les instructions sont mises entre accolades :</span><span class="sxs-lookup"><span data-stu-id="1f837-135">A statement lambda resembles an expression lambda except that the statement(s) is enclosed in braces:</span></span>

```csharp
(input parameters) => { statement; }
```

<span data-ttu-id="1f837-136">Le corps d'une instruction lambda peut se composer d'un nombre illimité d'instructions ; toutefois, en pratique, leur nombre est généralement de deux ou trois.</span><span class="sxs-lookup"><span data-stu-id="1f837-136">The body of a statement lambda can consist of any number of statements; however, in practice there are typically no more than two or three.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/statement1.cs#1)]

<span data-ttu-id="1f837-137">Les instructions lambda, comme les méthodes anonymes, ne peuvent pas être utilisées pour créer des arborescences d'expressions.</span><span class="sxs-lookup"><span data-stu-id="1f837-137">Statement lambdas, like anonymous methods, cannot be used to create expression trees.</span></span>

## <a name="async-lambdas"></a><span data-ttu-id="1f837-138">Lambdas asynchrones</span><span class="sxs-lookup"><span data-stu-id="1f837-138">Async lambdas</span></span> ##

<span data-ttu-id="1f837-139">Vous pouvez facilement créer des expressions et des instructions lambda qui incorporent un traitement asynchrone en utilisant les mots clés [async](language-reference/keywords/async.md) et [await](language-reference/keywords/await.md).</span><span class="sxs-lookup"><span data-stu-id="1f837-139">You can easily create lambda expressions and statements that incorporate asynchronous processing by using the [async](language-reference/keywords/async.md) and [await](language-reference/keywords/await.md) keywords.</span></span> <span data-ttu-id="1f837-140">Ainsi, l’exemple appelle une méthode `ShowSquares` qui s’exécute de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="1f837-140">For example, the example calls a `ShowSquares` method that executes asynchronously.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/async1.cs#1)]

<span data-ttu-id="1f837-141">Pour plus d’informations sur la création et l’utilisation des méthodes asyncrones, consultez [Programmation asynchrone avec async et await](programming-guide/concepts/async/index.md).</span><span class="sxs-lookup"><span data-stu-id="1f837-141">For more information about how to create and use async methods, see [Asynchronous programming with async and await](programming-guide/concepts/async/index.md).</span></span>

## <a name="lambda-expressions-and-tuples"></a><span data-ttu-id="1f837-142">Expressions lambda et tuples</span><span class="sxs-lookup"><span data-stu-id="1f837-142">Lambda expressions and tuples</span></span> ##

<span data-ttu-id="1f837-143">À compter sa version 7.0, le langage C# offre la prise en charge intégrée des tuples.</span><span class="sxs-lookup"><span data-stu-id="1f837-143">Starting with C# 7.0, the C# language provides built-in support for tuples.</span></span> <span data-ttu-id="1f837-144">Vous pouvez fournir un tuple comme argument à une expression lambda, et votre expression lambda peut aussi retourner un tuple.</span><span class="sxs-lookup"><span data-stu-id="1f837-144">You can provide a tuple as an argument to a lambda expression, and your lambda expression can also return a tuple.</span></span> <span data-ttu-id="1f837-145">Dans certains cas, le compilateur C# utilise l’inférence de type pour déterminer les types des composants du tuple.</span><span class="sxs-lookup"><span data-stu-id="1f837-145">In some cases, the C# compiler uses type inference to determine the types of tuple components.</span></span>

<span data-ttu-id="1f837-146">Vous définissez un tuple en plaçant entre des parenthèses une liste de ses composants avec des virgules comme séparateur.</span><span class="sxs-lookup"><span data-stu-id="1f837-146">You define a tuple by enclosing a comma-delimited list of its components in parentheses.</span></span> <span data-ttu-id="1f837-147">L’exemple suivant utilise un tuple avec 5 composants pour passer une séquence de nombres à une expression lambda, qui double chaque valeur et retourne un tuple avec 5 composants qui contient le résultat des multiplications.</span><span class="sxs-lookup"><span data-stu-id="1f837-147">The following example uses tuple with 5 components to pass a sequence of numbers to a lambda expression, which doubles each value and returns a tuple with 5 components that contains the result of the multiplications.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/tuples1.cs#1)]

<span data-ttu-id="1f837-148">En général, les champs d’un tuple sont nommés `Item1`, `Item2`, etc. Vous pouvez cependant définir un tuple avec des composants nommés, comme dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="1f837-148">Ordinarily, the fields of a tuple are named `Item1`, `Item2`, etc. You can, however, define a tuple with named components, as the following example does.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/tuples2.cs#1)]

<span data-ttu-id="1f837-149">Pour plus d’informations sur la prise en charge des tuples en C#, consultez [Types tuple de C#](tuples.md).</span><span class="sxs-lookup"><span data-stu-id="1f837-149">For more information on support for tuples in C#, see [C# Tuple types](tuples.md).</span></span>

## <a name="lambdas-with-the-standard-query-operators"></a><span data-ttu-id="1f837-150">Lambdas avec les opérateurs de requête standard</span><span class="sxs-lookup"><span data-stu-id="1f837-150">Lambdas with the standard query operators</span></span> ##

<span data-ttu-id="1f837-151">LINQ to Objects, parmi d’autres implémentations, a un paramètre d’entrée dont le type fait partie de la famille <xref:System.Func%601> de délégués génériques.</span><span class="sxs-lookup"><span data-stu-id="1f837-151">LINQ to Objects, among other implementations, have an input parameter whose type is one of the <xref:System.Func%601> family of generic delegates.</span></span> <span data-ttu-id="1f837-152">Ces délégués utilisent des paramètres de type pour définir le nombre et le type des paramètres d’entrée, ainsi que le type de retour du délégué.</span><span class="sxs-lookup"><span data-stu-id="1f837-152">These delegates use type parameters to define the number and type of input parameters, and the return type of the delegate.</span></span> <span data-ttu-id="1f837-153">Les délégués `Func` sont très utiles pour l'encapsulation des expressions définies par l'utilisateur appliquées à chaque élément dans un jeu de données sources.</span><span class="sxs-lookup"><span data-stu-id="1f837-153">`Func` delegates are very useful for encapsulating user-defined expressions that are applied to each element in a set of source data.</span></span> <span data-ttu-id="1f837-154">Par exemple, considérez le délégué <xref:System.Func%601>, dont la syntaxe est :</span><span class="sxs-lookup"><span data-stu-id="1f837-154">For example, consider the <xref:System.Func%601> delegate, whose syntax is:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#1)]

<span data-ttu-id="1f837-155">Le délégué peut être instancié avec du code similaire à celui-ci,</span><span class="sxs-lookup"><span data-stu-id="1f837-155">The delegate can be instantiated with code like the following</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#2)]

<span data-ttu-id="1f837-156">où `int` est un paramètre d’entrée et `bool` est la valeur de retour.</span><span class="sxs-lookup"><span data-stu-id="1f837-156">where `int` is an input parameter, and `bool` is the return value.</span></span> <span data-ttu-id="1f837-157">La valeur de retour est toujours spécifiée dans le dernier paramètre de type.</span><span class="sxs-lookup"><span data-stu-id="1f837-157">The return value is always specified in the last type parameter.</span></span> <span data-ttu-id="1f837-158">Quand le délégué `Func` suivant est appelé, il retourne la valeur true ou false pour indiquer si le paramètre d’entrée est égal à 5 :</span><span class="sxs-lookup"><span data-stu-id="1f837-158">When the following `Func` delegate is invoked, it returns true or false to indicate whether the input parameter is equal to 5:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#3)]

<span data-ttu-id="1f837-159">Vous pouvez aussi fournir une expression lambda quand le type d’argument est <xref:System.Linq.Expressions.Expression%601>, par exemple, dans les opérateurs de requête standard définis dans le type <xref:System.Linq.Queryable>.</span><span class="sxs-lookup"><span data-stu-id="1f837-159">You can also supply a lambda expression when the argument type is an <xref:System.Linq.Expressions.Expression%601>, for example in the standard query operators that are defined in the <xref:System.Linq.Queryable> type.</span></span> <span data-ttu-id="1f837-160">Quand vous spécifiez un argument <xref:System.Linq.Expressions.Expression%601>, l’expression lambda est compilée en arborescence de l’expression.</span><span class="sxs-lookup"><span data-stu-id="1f837-160">When you specify an <xref:System.Linq.Expressions.Expression%601> argument, the lambda is compiled to an expression tree.</span></span> <span data-ttu-id="1f837-161">L’exemple suivant utilise l’opérateur de requête standard [System.Linq.Enumerable.Count](xref:System.Linq.Enumerable.Count%60%601(System.Collections.Generic.IEnumerable{%60%600})).</span><span class="sxs-lookup"><span data-stu-id="1f837-161">The following example uses the [System.Linq.Enumerable.Count](xref:System.Linq.Enumerable.Count%60%601(System.Collections.Generic.IEnumerable{%60%600})) standard query operator.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#4)]

<span data-ttu-id="1f837-162">Le compilateur peut déduire le type du paramètre d'entrée, ou vous pouvez également le spécifier explicitement.</span><span class="sxs-lookup"><span data-stu-id="1f837-162">The compiler can infer the type of the input parameter, or you can also specify it explicitly.</span></span> <span data-ttu-id="1f837-163">Cette expression lambda particulière compte ces entiers (`n`) qui, quand ils sont divisés par deux, ont un reste égal à 1.</span><span class="sxs-lookup"><span data-stu-id="1f837-163">This particular lambda expression counts those integers (`n`) that, when divided by two, have a remainder of 1.</span></span>

<span data-ttu-id="1f837-164">L’exemple suivant produit une séquence qui contient tous les éléments du tableau `numbers` qui précèdent le 9, car c’est le premier nombre de la séquence qui ne satisfait pas la condition.</span><span class="sxs-lookup"><span data-stu-id="1f837-164">The following example produces a sequence that contains all elements in the `numbers` array that precede the 9, because that's the first number in the sequence that doesn't meet the condition.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#5)]

<span data-ttu-id="1f837-165">L’exemple suivant spécifie plusieurs paramètres d’entrée en les plaçant entre parenthèses.</span><span class="sxs-lookup"><span data-stu-id="1f837-165">The following example specifies multiple input parameters by enclosing them in parentheses.</span></span> <span data-ttu-id="1f837-166">La méthode retourne tous les éléments du tableau de nombres jusqu’à ce qu’elle rencontre un nombre dont la valeur est inférieure à sa position ordinale dans le tableau.</span><span class="sxs-lookup"><span data-stu-id="1f837-166">The method returns all the elements in the numbers array until it encounters a number whose value is less than its ordinal position in the array.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#6)]

## <a name="type-inference-in-lambda-expressions"></a><span data-ttu-id="1f837-167">Inférence de type et expressions lambda</span><span class="sxs-lookup"><span data-stu-id="1f837-167">Type inference in lambda expressions</span></span> ##

<span data-ttu-id="1f837-168">Quand vous écrivez des lambdas, vous n’avez généralement pas à spécifier un type pour les paramètres d’entrée, car le compilateur peut inférer le type en fonction du corps du lambda, des types de paramètre et d’autres facteurs, comme décrit dans la spécification du langage C#.</span><span class="sxs-lookup"><span data-stu-id="1f837-168">When writing lambdas, you often do not have to specify a type for the input parameters because the compiler can infer the type based on the lambda body, the parameter types, and other factors, as described in the C# Language Specification.</span></span> <span data-ttu-id="1f837-169">Pour la plupart des opérateurs de requête standard, la première entrée est le type des éléments dans la séquence source.</span><span class="sxs-lookup"><span data-stu-id="1f837-169">For most of the standard query operators, the first input is the type of the elements in the source sequence.</span></span> <span data-ttu-id="1f837-170">Si vous interrogez un `IEnumerable<Customer>`, le type de la variable d’entrée est inféré comme étant un objet `Customer`, ce qui signifie que vous avez accès à ses méthodes et à ses propriétés :</span><span class="sxs-lookup"><span data-stu-id="1f837-170">If you are querying an `IEnumerable<Customer>`, then the input variable is inferred to be a `Customer` object, which means you have access to its methods and properties:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/infer1.cs#1)]

<span data-ttu-id="1f837-171">Les règles générales de l’inférence de type pour les lambdas sont :</span><span class="sxs-lookup"><span data-stu-id="1f837-171">The general rules for type inference for lambdas are:</span></span>

- <span data-ttu-id="1f837-172">Le lambda doit contenir le même nombre de paramètres que le type délégué.</span><span class="sxs-lookup"><span data-stu-id="1f837-172">The lambda must contain the same number of parameters as the delegate type.</span></span>

- <span data-ttu-id="1f837-173">Chaque argument d’entrée dans le lambda doit être implicitement convertible en son paramètre de délégué correspondant.</span><span class="sxs-lookup"><span data-stu-id="1f837-173">Each input argument in the lambda must be implicitly convertible to its corresponding delegate parameter.</span></span>

- <span data-ttu-id="1f837-174">La valeur de retour du lambda (le cas échéant) doit être implicitement convertible en type de retour du délégué.</span><span class="sxs-lookup"><span data-stu-id="1f837-174">The return value of the lambda (if any) must be implicitly convertible to the delegate's return type.</span></span>

<span data-ttu-id="1f837-175">Notez que les expressions lambda en elles-mêmes n'ont pas de type, car le système de type commun (CTS, Common Type System) ne comporte aucun concept intrinsèque « d'expression lambda ».</span><span class="sxs-lookup"><span data-stu-id="1f837-175">Note that lambda expressions in themselves do not have a type because the common type system has no intrinsic concept of "lambda expression."</span></span> <span data-ttu-id="1f837-176">Toutefois, il est parfois commode de parler de manière informelle du « type » d'une expression lambda.</span><span class="sxs-lookup"><span data-stu-id="1f837-176">However, it is sometimes convenient to speak informally of the "type" of a lambda expression.</span></span> <span data-ttu-id="1f837-177">Dans ce cas, le type fait référence au type délégué ou au type <xref:System.Linq.Expressions.Expression> dans lequel est convertie l'expression lambda.</span><span class="sxs-lookup"><span data-stu-id="1f837-177">In these cases the type refers to the delegate type or <xref:System.Linq.Expressions.Expression> type to which the lambda expression is converted.</span></span>

## <a name="variable-scope-in-lambda-expressions"></a><span data-ttu-id="1f837-178">Portée variable dans les expressions lambda</span><span class="sxs-lookup"><span data-stu-id="1f837-178">Variable Scope in Lambda Expressions</span></span> ##

<span data-ttu-id="1f837-179">Les lambdas peuvent faire référence à des *variables externes* (consultez [Méthodes anonymes](programming-guide/statements-expressions-operators/anonymous-methods.md)) qui se trouvent dans l’étendue de la méthode qui définit la fonction lambda, ou dans l’étendue du type qui contient l’expression lambda.</span><span class="sxs-lookup"><span data-stu-id="1f837-179">Lambdas can refer to *outer variables* (see [Anonymous methods](programming-guide/statements-expressions-operators/anonymous-methods.md)) that are in scope in the method that defines the lambda function, or in scope in the type that contains the lambda expression.</span></span> <span data-ttu-id="1f837-180">Les variables capturées de cette manière sont stockées pour une utilisation dans l'expression lambda, même si les variables se trouvent en dehors de la portée et sont récupérées par le garbage collector.</span><span class="sxs-lookup"><span data-stu-id="1f837-180">Variables that are captured in this manner are stored for use in the lambda expression even if the variables would otherwise go out of scope and be garbage collected.</span></span> <span data-ttu-id="1f837-181">Une variable externe doit être assignée de manière précise pour pouvoir être utilisée dans une expression lambda.</span><span class="sxs-lookup"><span data-stu-id="1f837-181">An outer variable must be definitely assigned before it can be consumed in a lambda expression.</span></span> <span data-ttu-id="1f837-182">L’exemple suivant illustre ces règles.</span><span class="sxs-lookup"><span data-stu-id="1f837-182">The following example demonstrates these rules.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/scope.cs#1)]

 <span data-ttu-id="1f837-183">Les règles suivantes s'appliquent à la portée des variables dans les expressions lambda :</span><span class="sxs-lookup"><span data-stu-id="1f837-183">The following rules apply to variable scope in lambda expressions:</span></span>

- <span data-ttu-id="1f837-184">Une variable qui est capturée ne sera pas récupérée par le garbage collector avant que le délégué qui le référence soit disponible pour le garbage collection.</span><span class="sxs-lookup"><span data-stu-id="1f837-184">A variable that is captured will not be garbage-collected until the delegate that references it becomes eligible for garbage collection.</span></span>

- <span data-ttu-id="1f837-185">Les variables introduites dans une expression lambda ne sont pas visibles dans la méthode externe.</span><span class="sxs-lookup"><span data-stu-id="1f837-185">Variables introduced within a lambda expression are not visible in the outer method.</span></span>

- <span data-ttu-id="1f837-186">Une expression lambda ne peut pas capturer directement un paramètre `in`, `ref` ou `out` dans une méthode englobante.</span><span class="sxs-lookup"><span data-stu-id="1f837-186">A lambda expression cannot directly capture an `in`, `ref`, or `out` parameter from an enclosing method.</span></span>

- <span data-ttu-id="1f837-187">Une instruction return dans une expression lambda ne provoque pas le retour de la méthode englobante.</span><span class="sxs-lookup"><span data-stu-id="1f837-187">A return statement in a lambda expression does not cause the enclosing method to return.</span></span>

- <span data-ttu-id="1f837-188">Une expression lambda ne peut pas contenir une instruction `goto` , une instruction `break` , ou une instruction `continue` à l'intérieur de la fonction lambda si la cible de l'instruction de saut est hors du bloc.</span><span class="sxs-lookup"><span data-stu-id="1f837-188">A lambda expression cannot contain a `goto` statement, `break` statement, or `continue` statement that is inside the lambda function if the jump statement’s target is outside the block.</span></span> <span data-ttu-id="1f837-189">C'est également une erreur d'avoir une instruction de saut en dehors du bloc de la fonction lambda si la cible est à l'intérieur du bloc.</span><span class="sxs-lookup"><span data-stu-id="1f837-189">It is also an error to have a jump statement outside the lambda function block if the target is inside the block.</span></span>

## <a name="see-also"></a><span data-ttu-id="1f837-190">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="1f837-190">See also</span></span> ##

- [<span data-ttu-id="1f837-191">LINQ (Language Integrated Query)</span><span class="sxs-lookup"><span data-stu-id="1f837-191">LINQ (Language-Integrated Query)</span></span>](../standard/using-linq.md)
- [<span data-ttu-id="1f837-192">Méthodes anonymes</span><span class="sxs-lookup"><span data-stu-id="1f837-192">Anonymous methods</span></span>](programming-guide/statements-expressions-operators/anonymous-methods.md)
- [<span data-ttu-id="1f837-193">Arborescences d’expressions</span><span class="sxs-lookup"><span data-stu-id="1f837-193">Expression trees</span></span>](expression-trees.md)
