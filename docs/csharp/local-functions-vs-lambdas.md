---
title: Fonctions locales et expressions lambda
description: "Découvrez pourquoi des fonctions locales peuvent être un meilleur choix que les expressions lambda."
keywords: "C#, .NET, .NET Core, dernières fonctionnalités, nouveautés, fonctions locales, expressions lambda"
author: BillWagner
ms.author: wiwagn
ms.date: 06/27/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 20312b58a24dc991791edad4bb92d3a8ca6d501a
ms.sourcegitcommit: 5fb6646b5ee3769ffb214e672041833ea4ceeb26
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/08/2017
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="b4fce-104">Fonctions locales par rapport aux expressions lambda</span><span class="sxs-lookup"><span data-stu-id="b4fce-104">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="b4fce-105">À première vue, les [fonctions locales](programming-guide/classes-and-structs/local-functions.md) et les [expressions lambda](lambda-expressions.md) sont très similaires.</span><span class="sxs-lookup"><span data-stu-id="b4fce-105">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="b4fce-106">Dans de nombreux cas, le choix entre l’utilisation d’expressions lambda et les fonctions locales est une question de style et préférences personnelles.</span><span class="sxs-lookup"><span data-stu-id="b4fce-106">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="b4fce-107">Toutefois, il existe des différences réels où vous pouvez utiliser un ou l’autre que vous devez être conscient de.</span><span class="sxs-lookup"><span data-stu-id="b4fce-107">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="b4fce-108">Examinons les différences entre l’implémentation de l’algorithme factoriel avec une fonction locale et une expression lambda.</span><span class="sxs-lookup"><span data-stu-id="b4fce-108">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="b4fce-109">Voici tout d’abord la version utilisant une fonction locale :</span><span class="sxs-lookup"><span data-stu-id="b4fce-109">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="b4fce-110">Comparez cette implémentation avec une version qui utilise des expressions lambda :</span><span class="sxs-lookup"><span data-stu-id="b4fce-110">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="b4fce-111">Les fonctions locales ont des noms.</span><span class="sxs-lookup"><span data-stu-id="b4fce-111">The local functions have names.</span></span> <span data-ttu-id="b4fce-112">Les expressions lambda sont des méthodes anonymes sont affectées aux variables qui sont `Func` ou `Action` types.</span><span class="sxs-lookup"><span data-stu-id="b4fce-112">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="b4fce-113">Lorsque vous déclarez une fonction locale, les types d’arguments et le type de retour sont partie de la déclaration de fonction.</span><span class="sxs-lookup"><span data-stu-id="b4fce-113">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="b4fce-114">Au lieu de faire partie du corps de l’expression lambda expression, les types d’arguments et le type de retour sont partie de déclaration de type de variable de l’expression lambda.</span><span class="sxs-lookup"><span data-stu-id="b4fce-114">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="b4fce-115">Ces deux différences risque de code plus claire.</span><span class="sxs-lookup"><span data-stu-id="b4fce-115">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="b4fce-116">Fonctions locales ont des règles différentes pour l’assignation à des expressions lambda.</span><span class="sxs-lookup"><span data-stu-id="b4fce-116">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="b4fce-117">Une déclaration de fonction locale peut être référencée à partir de n’importe quel emplacement de code où il est dans la portée.</span><span class="sxs-lookup"><span data-stu-id="b4fce-117">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="b4fce-118">Une expression lambda doit être affectée à une variable de délégué avant de pouvoir être accessible (ou appelé par le biais du delgate faisant référence à l’expression lambda.) Notez que la version utilisant l’expression lambda doit déclarer et initialiser l’expression lambda `nthFactorial` avant de la définir.</span><span class="sxs-lookup"><span data-stu-id="b4fce-118">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delgate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="b4fce-119">Si ce n’est pas le cas, cela entraîne une erreur de compilation due au fait que vous référencez `nthFactorial` avant de lui affecter une valeur.</span><span class="sxs-lookup"><span data-stu-id="b4fce-119">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="b4fce-120">Ces différences font que les algorithmes récursifs sont plus faciles à créer à l’aide des fonctions locales.</span><span class="sxs-lookup"><span data-stu-id="b4fce-120">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="b4fce-121">Vous pouvez déclarer et définir une fonction locale qui s’appelle elle-même.</span><span class="sxs-lookup"><span data-stu-id="b4fce-121">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="b4fce-122">Expressions lambda doivent être déclarées et une valeur par défaut assignées avant de pouvoir être réaffectés à un corps qui fait référence à la même expression lambda.</span><span class="sxs-lookup"><span data-stu-id="b4fce-122">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="b4fce-123">Règles d’assignation définie affectent également toutes les variables qui sont capturées par l’epression de fonction ou un objet lambda locale.</span><span class="sxs-lookup"><span data-stu-id="b4fce-123">Definite assignment rules also affect any variables that are captured by the local function or lamdba epression.</span></span> <span data-ttu-id="b4fce-124">Les fonctions locales et les règles d’expression lambda exigent que toutes les variables capturées sont définitivement assignés au point lorsque l’expression lambda ou de fonction locale est convertie en un délégué.</span><span class="sxs-lookup"><span data-stu-id="b4fce-124">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="b4fce-125">La différence est que les expressions lambda sont converties en délégués lorsqu’ils sont déclarés.</span><span class="sxs-lookup"><span data-stu-id="b4fce-125">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="b4fce-126">Fonctions locales sont converties en délégués uniquement lorsqu’elle sert d’un délégué.</span><span class="sxs-lookup"><span data-stu-id="b4fce-126">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="b4fce-127">Si vous déclarez une fonction locale et à le référencez uniquement en l’appelant comme une méthode, il ne sera pas converti en un délégué.</span><span class="sxs-lookup"><span data-stu-id="b4fce-127">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="b4fce-128">Cette règle permet de déclarer une fonction locale à n’importe quel emplacement pratique dans sa portée englobante.</span><span class="sxs-lookup"><span data-stu-id="b4fce-128">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="b4fce-129">Il est courant de déclarer des fonctions locales à la fin de la méthode parente, après les instructions return.</span><span class="sxs-lookup"><span data-stu-id="b4fce-129">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="b4fce-130">Enfin, le compilateur peut effectuer une analyse statique qui active des fonctions locales sans aucun doute affecter les variables capturées dans la portée englobante.</span><span class="sxs-lookup"><span data-stu-id="b4fce-130">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="b4fce-131">Considérez cet exemple :</span><span class="sxs-lookup"><span data-stu-id="b4fce-131">Consider this example:</span></span>

```csharp
bool M()
{
    int y;
    Local();
    return y;

    void Local() => y = 0;
}
```

<span data-ttu-id="b4fce-132">Le compilateur peut déterminer que `Local` définitivement assigne `y` lorsqu’elle est appelée.</span><span class="sxs-lookup"><span data-stu-id="b4fce-132">The compiler can determine that `Local` definitely assigns `y` when called.</span></span> <span data-ttu-id="b4fce-133">Étant donné que `Local` est appelée avant la `return` instruction, `y` definitiely affecté à la `return` instruction.</span><span class="sxs-lookup"><span data-stu-id="b4fce-133">Because `Local` is called before the `return` statement, `y` is definitiely assigned at the `return` statement.</span></span>

<span data-ttu-id="b4fce-134">L’analyse qui permet cette analyse permet à la différence du quatrième.</span><span class="sxs-lookup"><span data-stu-id="b4fce-134">The analysis that enables that analysis enables the fourth difference.</span></span>
<span data-ttu-id="b4fce-135">En fonction de leur utilisation, fonctions locales peuvent éviter les allocations de tas sont toujours nécessaires pour les expressions lambda.</span><span class="sxs-lookup"><span data-stu-id="b4fce-135">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="b4fce-136">Si une fonction locale n’est jamais convertie en un délégué, et qu’aucun des variables capturées par la fonction locale est capturé par d’autres expressions lambda ou les fonctions locales qui sont converties en délégués, le compilateur peut éviter les allocations de tas.</span><span class="sxs-lookup"><span data-stu-id="b4fce-136">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span> 

<span data-ttu-id="b4fce-137">Penchons-nous sur cet exemple asynchrone :</span><span class="sxs-lookup"><span data-stu-id="b4fce-137">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="b4fce-138">La fermeture de cette expression lambda contient les variables `address`, `index` et `name`.</span><span class="sxs-lookup"><span data-stu-id="b4fce-138">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="b4fce-139">Dans le cas des fonctions locales, l’objet qui implémente la fermeture peut être un type `struct`.</span><span class="sxs-lookup"><span data-stu-id="b4fce-139">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="b4fce-140">Ce type de structure peuvent être transmis par référence à la fonction locale.</span><span class="sxs-lookup"><span data-stu-id="b4fce-140">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="b4fce-141">Cette différence de mise en œuvre serait enregistrer sur une allocation.</span><span class="sxs-lookup"><span data-stu-id="b4fce-141">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="b4fce-142">L’instanciation nécessaire pour les expressions lambda signifie que les allocations de mémoire supplémentaire, qui peuvent être un facteur de performances dans les chemins d’accès du code à durée critique.</span><span class="sxs-lookup"><span data-stu-id="b4fce-142">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="b4fce-143">Les fonctions locales n’entraînent pas cette charge supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="b4fce-143">Local functions do not incur this overhead.</span></span> <span data-ttu-id="b4fce-144">Dans l’exemple ci-dessus, la version à fonction locale a 2 allocations de moins que la version à expression lambda.</span><span class="sxs-lookup"><span data-stu-id="b4fce-144">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="b4fce-145">L’équivalent de cette méthode avec une fonction locale fait aussi appel à une classe pour la fermeture.</span><span class="sxs-lookup"><span data-stu-id="b4fce-145">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="b4fce-146">Le fait que la fermeture d’une fonction locale soit implémentée en tant que `class` ou `struct` est un détail d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="b4fce-146">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="b4fce-147">Une fonction locale peut utiliser un type `struct` contrairement à une expression lambda qui utilise toujours un type `class`.</span><span class="sxs-lookup"><span data-stu-id="b4fce-147">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "Task returning method with local function")]

<span data-ttu-id="b4fce-148">Ultime avantage non décrit dans cet exemple : les fonctions locales peuvent être implémentées en tant qu’itérateurs, en utilisant la syntaxe `yield return` pour produire une séquence de valeurs.</span><span class="sxs-lookup"><span data-stu-id="b4fce-148">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="b4fce-149">La `yield return` instruction n’est pas autorisée dans les expressions lambda.</span><span class="sxs-lookup"><span data-stu-id="b4fce-149">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="b4fce-150">Alors que les fonctions locales peuvent sembler redondantes par rapport aux expressions lambda, elles ont en réalité des objectifs différents et des utilisations différentes.</span><span class="sxs-lookup"><span data-stu-id="b4fce-150">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="b4fce-151">Les fonctions locales sont plus efficaces dans le cas où vous voulez écrire une fonction qui est appelée seulement dans le contexte d’une autre méthode.</span><span class="sxs-lookup"><span data-stu-id="b4fce-151">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>
