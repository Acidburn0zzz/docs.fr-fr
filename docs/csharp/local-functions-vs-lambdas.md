---
title: Fonctions locales et expressions lambda
description: "Découvrez pourquoi des fonctions locales peuvent être un meilleur choix que les expressions lambda."
keywords: "C#, .NET, .NET Core, dernières fonctionnalités, nouveautés, fonctions locales, expressions lambda"
author: BillWagner
ms.author: wiwagn
ms.date: 06/27/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.translationtype: HT
ms.sourcegitcommit: 9bb17207ba72bb22f5d6db55e9d1bd77e3013445
ms.openlocfilehash: 0730e7b7d6e3ef7b5c534d16baacde6a7dafacfc
ms.contentlocale: fr-fr
ms.lasthandoff: 08/25/2017

---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="e30f2-104">Fonctions locales comparées aux expressions lambda</span><span class="sxs-lookup"><span data-stu-id="e30f2-104">Local functions compared to Lambda expressions</span></span>

<span data-ttu-id="e30f2-105">À première vue, les [fonctions locales](programming-guide/classes-and-structs/local-functions.md) et les [expressions lambda](lambda-expressions.md) sont très similaires.</span><span class="sxs-lookup"><span data-stu-id="e30f2-105">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](lambda-expressions.md) are very similar.</span></span>
<span data-ttu-id="e30f2-106">Or, selon vos besoins, les fonctions locales peuvent offrir une solution beaucoup plus efficace et simple.</span><span class="sxs-lookup"><span data-stu-id="e30f2-106">Depending on your needs, local functions may be a much better and simpler solution.</span></span>

<span data-ttu-id="e30f2-107">Examinons les différences entre l’implémentation de l’algorithme factoriel avec une fonction locale et une expression lambda.</span><span class="sxs-lookup"><span data-stu-id="e30f2-107">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="e30f2-108">Voici tout d’abord la version utilisant une fonction locale :</span><span class="sxs-lookup"><span data-stu-id="e30f2-108">First the version using a local function:</span></span>

<span data-ttu-id="e30f2-109">[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Factorielle récursive utilisant une fonction locale")]</span><span class="sxs-lookup"><span data-stu-id="e30f2-109">[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]</span></span>

<span data-ttu-id="e30f2-110">Comparez cette implémentation avec une version qui utilise des expressions lambda :</span><span class="sxs-lookup"><span data-stu-id="e30f2-110">Contrast that implementation with a version that uses lambda expressions:</span></span>

<span data-ttu-id="e30f2-111">[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Factorielle récursive utilisant des expressions lambda")]</span><span class="sxs-lookup"><span data-stu-id="e30f2-111">[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]</span></span>

<span data-ttu-id="e30f2-112">En premier lieu, les expressions lambda sont implémentées en instanciant un délégué et en appelant ce même délégué.</span><span class="sxs-lookup"><span data-stu-id="e30f2-112">First, lambda expressions are implemented by instantiating a delegate and invoking that delegate.</span></span> <span data-ttu-id="e30f2-113">Les fonctions locales sont implémentées comme des appels de méthode.</span><span class="sxs-lookup"><span data-stu-id="e30f2-113">Local functions are implemented as method calls.</span></span>
<span data-ttu-id="e30f2-114">L’instanciation nécessaire pour les expressions lambda signifie des allocations de mémoire supplémentaires, qui peuvent être un facteur influençant les performances dans les chemins de code critiques au niveau du temps.</span><span class="sxs-lookup"><span data-stu-id="e30f2-114">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time critical code paths.</span></span>
<span data-ttu-id="e30f2-115">Les fonctions locales n’entraînent pas cette charge supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="e30f2-115">Local functions do not incur this overhead.</span></span> <span data-ttu-id="e30f2-116">Dans l’exemple ci-dessus, la version à fonction locale a 2 allocations de moins que la version à expression lambda.</span><span class="sxs-lookup"><span data-stu-id="e30f2-116">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

<span data-ttu-id="e30f2-117">Cette méthode récursive est suffisamment simple pour que la fonction locale soit implémentée en tant que méthode privée avec un nom généré par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="e30f2-117">This recursive method is simple enough that the local function is implemented as a private method with a compiler generated name.</span></span> <span data-ttu-id="e30f2-118">Sa seule différence par rapport aux autres méthodes privées est qu’elle est sémantiquement étendue au sein de la fonction externe.</span><span class="sxs-lookup"><span data-stu-id="e30f2-118">Its only difference from other private methods is that it is semantically scoped inside the outer function.</span></span>

<span data-ttu-id="e30f2-119">En second lieu, les fonctions locales peuvent être appelées avant d’être définies.</span><span class="sxs-lookup"><span data-stu-id="e30f2-119">Second, local functions can be called before they are defined.</span></span> <span data-ttu-id="e30f2-120">Les expressions lambda doivent être déclarées avant d’être définies.</span><span class="sxs-lookup"><span data-stu-id="e30f2-120">Lambda expressions must be declared before they are defined.</span></span> <span data-ttu-id="e30f2-121">Cela signifie que les fonctions locales sont plus faciles à utiliser dans des algorithmes récursifs, comme nous l’avons vu précédemment.</span><span class="sxs-lookup"><span data-stu-id="e30f2-121">This means local functions are easier to use in recursive algorithms, as shown above.</span></span>

<span data-ttu-id="e30f2-122">Notez que la version utilisant l’expression lambda doit déclarer et initialiser l’expression lambda `nthFactorial` avant de la définir.</span><span class="sxs-lookup"><span data-stu-id="e30f2-122">Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="e30f2-123">Si ce n’est pas le cas, cela entraîne une erreur de compilation due au fait que vous référencez `nthFactorial` avant de lui affecter une valeur.</span><span class="sxs-lookup"><span data-stu-id="e30f2-123">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="e30f2-124">Les algorithmes récursifs sont plus faciles à créer en utilisant des fonctions locales.</span><span class="sxs-lookup"><span data-stu-id="e30f2-124">Recursive algorithms are easier to create using local functions.</span></span>

<span data-ttu-id="e30f2-125">En troisième lieu, pour les expressions lambda, le compilateur doit toujours créer une classe anonyme et une instance de cette classe pour stocker les variables capturées par la fermeture.</span><span class="sxs-lookup"><span data-stu-id="e30f2-125">Third, for lambda expressions, the compiler must always create an anonymous class and an instance of that class to store any variables captured by the closure.</span></span> <span data-ttu-id="e30f2-126">Penchons-nous sur cet exemple asynchrone :</span><span class="sxs-lookup"><span data-stu-id="e30f2-126">Consider this async example:</span></span>

<span data-ttu-id="e30f2-127">[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Méthode retournant une tâche avec une expression lambda")]</span><span class="sxs-lookup"><span data-stu-id="e30f2-127">[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]</span></span>

<span data-ttu-id="e30f2-128">La fermeture de cette expression lambda contient les variables `address`, `index` et `name`.</span><span class="sxs-lookup"><span data-stu-id="e30f2-128">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="e30f2-129">Dans le cas des fonctions locales, l’objet qui implémente la fermeture peut être un type `struct`.</span><span class="sxs-lookup"><span data-stu-id="e30f2-129">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="e30f2-130">Cela permet d’économiser une allocation.</span><span class="sxs-lookup"><span data-stu-id="e30f2-130">That would save on an allocation.</span></span>

> [!NOTE]
> <span data-ttu-id="e30f2-131">L’équivalent de cette méthode avec une fonction locale fait aussi appel à une classe pour la fermeture.</span><span class="sxs-lookup"><span data-stu-id="e30f2-131">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="e30f2-132">Le fait que la fermeture d’une fonction locale soit implémentée en tant que `class` ou `struct` est un détail d’implémentation.</span><span class="sxs-lookup"><span data-stu-id="e30f2-132">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="e30f2-133">Une fonction locale peut utiliser un type `struct` contrairement à une expression lambda qui utilise toujours un type `class`.</span><span class="sxs-lookup"><span data-stu-id="e30f2-133">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

<span data-ttu-id="e30f2-134">[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "Méthode retournant une tâche avec une fonction locale")]</span><span class="sxs-lookup"><span data-stu-id="e30f2-134">[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "Task returning method with local function")]</span></span>

<span data-ttu-id="e30f2-135">Ultime avantage non décrit dans cet exemple : les fonctions locales peuvent être implémentées en tant qu’itérateurs, en utilisant la syntaxe `yield return` pour produire une séquence de valeurs.</span><span class="sxs-lookup"><span data-stu-id="e30f2-135">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span>

<span data-ttu-id="e30f2-136">Alors que les fonctions locales peuvent sembler redondantes par rapport aux expressions lambda, elles ont en réalité des objectifs différents et des utilisations différentes.</span><span class="sxs-lookup"><span data-stu-id="e30f2-136">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="e30f2-137">Les fonctions locales sont plus efficaces dans le cas où vous voulez écrire une fonction qui est appelée seulement dans le contexte d’une autre méthode.</span><span class="sxs-lookup"><span data-stu-id="e30f2-137">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

