---
title: "Sémantique de référence avec les types valeur"
description: "Comprendre les fonctionnalités de langage qui réduisent les structures de copie en toute sécurité"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 9eeaf201c1f5a58044db62e356199b609c4c035a
ms.sourcegitcommit: 7e99f66ef09d2903e22c789c67ff5a10aa953b2f
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/18/2017
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="45ac3-103">Sémantique de référence avec les types valeur</span><span class="sxs-lookup"><span data-stu-id="45ac3-103">Reference semantics with value types</span></span>

<span data-ttu-id="45ac3-104">L’avantage de l’utilisation des types de valeur est qu’ils évitent d’allocations de tas.</span><span class="sxs-lookup"><span data-stu-id="45ac3-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="45ac3-105">L’inconvénient correspondante est qu’elles sont copiées par valeur.</span><span class="sxs-lookup"><span data-stu-id="45ac3-105">The corresponding disadvantage is that they are copied by value.</span></span> <span data-ttu-id="45ac3-106">Ce compromis rend plus difficile optimiser les algorithmes qui fonctionnent sur de grandes quantités de données.</span><span class="sxs-lookup"><span data-stu-id="45ac3-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="45ac3-107">Nouvelles fonctionnalités de langage c# 7.2 fournissent des mécanismes qui permettent la sémantique de passage par référence avec les types valeur.</span><span class="sxs-lookup"><span data-stu-id="45ac3-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="45ac3-108">Si vous utilisez ces fonctionnalités avec soin, vous pouvez réduire les allocations et opérations de copie.</span><span class="sxs-lookup"><span data-stu-id="45ac3-108">If you use these features wisely you can minimize both allocations and copy operations.</span></span> <span data-ttu-id="45ac3-109">Cet article explore ces nouvelles fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="45ac3-109">This article explores those new features.</span></span>

<span data-ttu-id="45ac3-110">Une grande partie de l’exemple de code dans cet article montre les fonctionnalités ajoutées dans c# 7.2.</span><span class="sxs-lookup"><span data-stu-id="45ac3-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="45ac3-111">Pour pouvoir utiliser ces fonctionnalités, vous devez configurer votre projet pour utiliser le langage c# 7.2 ou version ultérieure dans votre projet.</span><span class="sxs-lookup"><span data-stu-id="45ac3-111">In order to use those features, you have to configure your project to use C# 7.2 or later in your project.</span></span> <span data-ttu-id="45ac3-112">Vous pouvez utiliser Visual Studio pour le sélectionner.</span><span class="sxs-lookup"><span data-stu-id="45ac3-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="45ac3-113">Pour chaque projet, sélectionnez **projet** dans le menu, puis **propriétés**.</span><span class="sxs-lookup"><span data-stu-id="45ac3-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="45ac3-114">Sélectionnez le **générer** onglet et cliquez sur **avancé**.</span><span class="sxs-lookup"><span data-stu-id="45ac3-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="45ac3-115">À partir de là, vous pouvez configurer la version de langue.</span><span class="sxs-lookup"><span data-stu-id="45ac3-115">From there, you can configure the language version.</span></span> <span data-ttu-id="45ac3-116">Choisissez « 7.2 », ou « dernier ».</span><span class="sxs-lookup"><span data-stu-id="45ac3-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="45ac3-117">Vous pouvez aussi modifier la *csproj* et ajoutez le nœud suivant :</span><span class="sxs-lookup"><span data-stu-id="45ac3-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="45ac3-118">Vous pouvez utiliser « 7.2 » ou « dernier » pour la valeur.</span><span class="sxs-lookup"><span data-stu-id="45ac3-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="specifying-in-parameters"></a><span data-ttu-id="45ac3-119">Spécification `in` paramètres</span><span class="sxs-lookup"><span data-stu-id="45ac3-119">Specifying `in` parameters</span></span>

<span data-ttu-id="45ac3-120">7.2 c# ajoute le `in` (mot clé) pour compléter existants `ref` et `out` mots clés lorsque vous écrivez une méthode qui transmet des arguments par référence.</span><span class="sxs-lookup"><span data-stu-id="45ac3-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords when you write a method that passes arguments by reference.</span></span> <span data-ttu-id="45ac3-121">Le `in` mot clé spécifie que vous passez le paramètre par référence et la méthode appelée ne modifie pas la valeur passée à ce dernier.</span><span class="sxs-lookup"><span data-stu-id="45ac3-121">The `in` keyword specifies that you are passing the parameter by reference and the called method does not modify the value passed to it.</span></span> 

<span data-ttu-id="45ac3-122">Cet ajout fournit un vocabulaire complète pour exprimer votre intention de conception.</span><span class="sxs-lookup"><span data-stu-id="45ac3-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="45ac3-123">Types valeur sont copiés quand il est passé à une méthode appelée lorsque vous ne spécifiez pas un des modificateurs suivants.</span><span class="sxs-lookup"><span data-stu-id="45ac3-123">Value types are copied when passed to a called method when you do not specify any of the following modifiers.</span></span> <span data-ttu-id="45ac3-124">Chacune de ces modificateurs de spécifier qu’un type valeur est passé par référence, évitant ainsi la copie.</span><span class="sxs-lookup"><span data-stu-id="45ac3-124">Each of these modifiers specify that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="45ac3-125">Chaque modificateur exprime un objectif différent :</span><span class="sxs-lookup"><span data-stu-id="45ac3-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="45ac3-126">`out`: Cette méthode définit la valeur de l’argument utilisé en tant que ce paramètre.</span><span class="sxs-lookup"><span data-stu-id="45ac3-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="45ac3-127">`ref`: Cette méthode peut définir la valeur de l’argument utilisé en tant que ce paramètre.</span><span class="sxs-lookup"><span data-stu-id="45ac3-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="45ac3-128">`in`: Cette méthode ne modifie pas la valeur de l’argument utilisé en tant que ce paramètre.</span><span class="sxs-lookup"><span data-stu-id="45ac3-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="45ac3-129">Lorsque vous ajoutez le `in` modificateur pour passer un argument par référence, vous déclarez votre objectif de conception est de passer des arguments par référence afin d’éviter la copie inutile.</span><span class="sxs-lookup"><span data-stu-id="45ac3-129">When you add the `in` modifier to pass an argument by reference, you declare your design intent is to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="45ac3-130">Vous ne souhaitez pas modifier l’objet utilisé comme argument.</span><span class="sxs-lookup"><span data-stu-id="45ac3-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="45ac3-131">Le code suivant montre un exemple d’une méthode qui calcule la distance entre deux points dans un espace 3D.</span><span class="sxs-lookup"><span data-stu-id="45ac3-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="45ac3-132">Les arguments sont deux structures qui contiennent chacune des trois valeurs de type double.</span><span class="sxs-lookup"><span data-stu-id="45ac3-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="45ac3-133">Un double est de 8 octets, par conséquent, chaque argument est de 24 octets.</span><span class="sxs-lookup"><span data-stu-id="45ac3-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="45ac3-134">En spécifiant le `in` modificateur, que vous passez une référence codés sur 4 ou 8 octets pour ces arguments, selon l’architecture de l’ordinateur.</span><span class="sxs-lookup"><span data-stu-id="45ac3-134">By specifying the `in` modifier, you pass 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="45ac3-135">La différence de taille est faible, mais elle peut rapidement s’ajouter lorsque votre application appelle cette méthode dans une boucle serrée, à l’aide de nombreuses valeurs différentes.</span><span class="sxs-lookup"><span data-stu-id="45ac3-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="45ac3-136">Le `in` modificateur complète `out` et `ref` d’autres façons.</span><span class="sxs-lookup"><span data-stu-id="45ac3-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="45ac3-137">Vous ne pouvez pas créer de surcharges d’une méthode qui diffèrent uniquement en présence de `in`, `out` ou `ref`.</span><span class="sxs-lookup"><span data-stu-id="45ac3-137">You cannot create overloads of a method that differ only in the presence of `in`, `out` or `ref`.</span></span> <span data-ttu-id="45ac3-138">Ces nouvelles règles d’étendent le comportement de même a toujours été défini pour `out` et `ref` paramètres.</span><span class="sxs-lookup"><span data-stu-id="45ac3-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="45ac3-139">Le `in` modificateur peut être appliqué à n’importe quel membre qui accepte des paramètres : méthodes, les délégués, les expressions lambda, fonctions locales, indexeurs, opérateurs.</span><span class="sxs-lookup"><span data-stu-id="45ac3-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="45ac3-140">Contrairement aux `ref` et `out` arguments, vous pouvez utiliser les valeurs littérales ou des constantes pour l’argument à un `in` paramètre.</span><span class="sxs-lookup"><span data-stu-id="45ac3-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="45ac3-141">En outre, contrairement à un `ref` ou `out` paramètre, vous n’avez pas besoin d’appliquer le `in` modificateur sur le site d’appel.</span><span class="sxs-lookup"><span data-stu-id="45ac3-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="45ac3-142">Le code suivant présente deux exemples de l’appel de la `CalculateDistance` (méthode).</span><span class="sxs-lookup"><span data-stu-id="45ac3-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="45ac3-143">Le premier délégué utilise deux variables locales, passés par référence.</span><span class="sxs-lookup"><span data-stu-id="45ac3-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="45ac3-144">La deuxième inclut une variable temporaire est créée dans le cadre de l’appel de méthode.</span><span class="sxs-lookup"><span data-stu-id="45ac3-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="45ac3-145">Il existe plusieurs façons dans lequel le compilateur garantit que la nature en lecture seule d’un `in` argument est appliqué.</span><span class="sxs-lookup"><span data-stu-id="45ac3-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="45ac3-146">Tout d’abord, la méthode appelée ne peut pas attribuer directement à un `in` paramètre.</span><span class="sxs-lookup"><span data-stu-id="45ac3-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="45ac3-147">Il ne peut pas attribuer directement à n’importe quel champ d’un `in` paramètre.</span><span class="sxs-lookup"><span data-stu-id="45ac3-147">It can't directly assign to any field of an `in` parameter.</span></span> <span data-ttu-id="45ac3-148">En outre, vous ne pouvez pas passer un `in` paramètre à toute méthode en exigeant la `ref` ou `out` modificateur.</span><span class="sxs-lookup"><span data-stu-id="45ac3-148">In addition, you cannot pass an `in` parameter to any method demanding the `ref` or `out` modifier.</span></span>
<span data-ttu-id="45ac3-149">Le compilateur considère que la `in` argument est une variable en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="45ac3-149">The compiler enforces that the `in` argument is a readonly variable.</span></span> <span data-ttu-id="45ac3-150">Vous pouvez appeler toute méthode d’instance qui utilise une sémantique de passage par valeur.</span><span class="sxs-lookup"><span data-stu-id="45ac3-150">You can call any instance method that uses pass-by-value semantics.</span></span> <span data-ttu-id="45ac3-151">Dans ce cas, une copie de la `in` paramètre est créé.</span><span class="sxs-lookup"><span data-stu-id="45ac3-151">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="45ac3-152">Étant donné que le compilateur peut créer une variable temporaire pour les `in` paramètre, vous pouvez également spécifier des valeurs par défaut pour toute `in` paramètre.</span><span class="sxs-lookup"><span data-stu-id="45ac3-152">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="45ac3-153">Le code suivant qui utilise pour spécifier l’origine (point 0,0) comme valeur par défaut pour le deuxième point :</span><span class="sxs-lookup"><span data-stu-id="45ac3-153">The follow code uses that to specify the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="45ac3-154">Le `in` désignation de paramètre peut également être utilisée avec les types référence ou générée dans les valeurs numériques.</span><span class="sxs-lookup"><span data-stu-id="45ac3-154">The `in` parameter designation can also be used with reference types or built in numeric values.</span></span> <span data-ttu-id="45ac3-155">Toutefois, les avantages dans les deux cas sont minimes, le cas échéant.</span><span class="sxs-lookup"><span data-stu-id="45ac3-155">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="45ac3-156">`ref readonly`Retourne</span><span class="sxs-lookup"><span data-stu-id="45ac3-156">`ref readonly` returns</span></span>

<span data-ttu-id="45ac3-157">Vous pouvez souhaiter également un type de valeur de retour par référence, mais ne pas autoriser l’appelant à partir de la modification de cette valeur.</span><span class="sxs-lookup"><span data-stu-id="45ac3-157">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="45ac3-158">Utilisez le `ref readonly` modificateur pour exprimer l’intention de cette conception.</span><span class="sxs-lookup"><span data-stu-id="45ac3-158">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="45ac3-159">Il indique aux lecteurs que vous ne retournant une référence aux données existantes, mais autorise ne pas la modification.</span><span class="sxs-lookup"><span data-stu-id="45ac3-159">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="45ac3-160">Le compilateur impose que l’appelant ne peut pas modifier la référence.</span><span class="sxs-lookup"><span data-stu-id="45ac3-160">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="45ac3-161">Tente d’assigner directement à la valeur génère une erreur de compilation.</span><span class="sxs-lookup"><span data-stu-id="45ac3-161">Attempts to assign to the value directly generate a compile-time error.</span></span> <span data-ttu-id="45ac3-162">Toutefois, le compilateur ne peut pas savoir si n’importe quelle méthode membre modifie l’état de la structure.</span><span class="sxs-lookup"><span data-stu-id="45ac3-162">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="45ac3-163">Pour vous assurer que l’objet n’est pas modifié, le compilateur crée une copie et appelle des références à l’aide de cette copie de membre.</span><span class="sxs-lookup"><span data-stu-id="45ac3-163">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="45ac3-164">Les modifications sont à la copie.</span><span class="sxs-lookup"><span data-stu-id="45ac3-164">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="45ac3-165">Il est probable que la bibliothèque à l’aide `Point3D` utiliseriez souvent l’origine dans le code.</span><span class="sxs-lookup"><span data-stu-id="45ac3-165">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="45ac3-166">Chaque instance crée un nouvel objet dans la pile.</span><span class="sxs-lookup"><span data-stu-id="45ac3-166">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="45ac3-167">Il peut être avantageux de créer une constante et la retournez par référence.</span><span class="sxs-lookup"><span data-stu-id="45ac3-167">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="45ac3-168">Toutefois, si vous retournez une référence à un stockage interne, il pouvez que vous souhaitez appliquer que l’appelant ne peut pas modifier le stockage référencé.</span><span class="sxs-lookup"><span data-stu-id="45ac3-168">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="45ac3-169">Le code suivant définit une propriété en lecture seule qui renvoie une `readonly ref` à un `Point3D` qui spécifie l’origine.</span><span class="sxs-lookup"><span data-stu-id="45ac3-169">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="45ac3-170">Il est facile de créer une copie d’une readonly ref retour : simplement l’affecter à une variable non déclarée avec le `ref readonly` modificateur.</span><span class="sxs-lookup"><span data-stu-id="45ac3-170">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="45ac3-171">Le compilateur génère du code pour copier l’objet dans le cadre de l’affectation.</span><span class="sxs-lookup"><span data-stu-id="45ac3-171">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="45ac3-172">Lorsque vous assignez une variable à un `ref readonly return`, vous pouvez spécifier une `ref readonly` variable ou une copie par valeur de la référence en lecture seule :</span><span class="sxs-lookup"><span data-stu-id="45ac3-172">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the readonly reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="45ac3-173">La première assignation dans le code précédent effectue une copie de la `Origin` constante et affecte cette copie.</span><span class="sxs-lookup"><span data-stu-id="45ac3-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="45ac3-174">La seconde assigne une référence.</span><span class="sxs-lookup"><span data-stu-id="45ac3-174">The second assigns a reference.</span></span> <span data-ttu-id="45ac3-175">Notez que le `readonly` modificateur doit faire partie de la déclaration de la variable.</span><span class="sxs-lookup"><span data-stu-id="45ac3-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="45ac3-176">La référence à laquelle il fait référence ne peut pas être modifiée.</span><span class="sxs-lookup"><span data-stu-id="45ac3-176">The reference to which it refers cannot be modified.</span></span> <span data-ttu-id="45ac3-177">Tente de faire provoque une erreur de compilation.</span><span class="sxs-lookup"><span data-stu-id="45ac3-177">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="45ac3-178">Type `readonly struct`</span><span class="sxs-lookup"><span data-stu-id="45ac3-178">`readonly struct` type</span></span>

<span data-ttu-id="45ac3-179">Application `ref readonly` à fort trafic des utilisations d’un struct peut suffire.</span><span class="sxs-lookup"><span data-stu-id="45ac3-179">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="45ac3-180">Parfois, vous voudrez créer un struct immuable.</span><span class="sxs-lookup"><span data-stu-id="45ac3-180">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="45ac3-181">Ensuite, vous pouvez toujours passer par référence d’en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="45ac3-181">Then you can always pass by readonly reference.</span></span> <span data-ttu-id="45ac3-182">Que pratique supprime la défense de copie qui se produisent lorsque vous accédez aux méthodes d’un struct utilisé comme un `in` paramètre.</span><span class="sxs-lookup"><span data-stu-id="45ac3-182">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="45ac3-183">Que faire, vous pouvez créer un `readonly struct` type.</span><span class="sxs-lookup"><span data-stu-id="45ac3-183">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="45ac3-184">Vous pouvez ajouter la `readonly` modificateur à une déclaration de struct.</span><span class="sxs-lookup"><span data-stu-id="45ac3-184">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="45ac3-185">Le compilateur impose que tous les membres du struct sont `readonly`; le `struct` doivent être immuables.</span><span class="sxs-lookup"><span data-stu-id="45ac3-185">The compiler enforces that all members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="45ac3-186">Il existe d’autres optimisations pour un `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="45ac3-186">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="45ac3-187">Vous pouvez utiliser la `in` modificateur à chaque emplacement où un `readonly struct` est un argument.</span><span class="sxs-lookup"><span data-stu-id="45ac3-187">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="45ac3-188">En outre, vous pouvez retourner un `readonly struct` comme un `ref return` lorsque vous retournez un objet dont durée de vie s’étend au-delà de la portée de la méthode de retour de l’objet.</span><span class="sxs-lookup"><span data-stu-id="45ac3-188">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="45ac3-189">Enfin, le compilateur génère du code plus efficace lorsque vous appelez des membres d’un `readonly struct`: le `this` référence, au lieu d’une copie du récepteur, est toujours un `in` paramètre passé par référence à la méthode de membre.</span><span class="sxs-lookup"><span data-stu-id="45ac3-189">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="45ac3-190">Cette optimisation enregistre une copie plus lorsque vous utilisez un `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="45ac3-190">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="45ac3-191">Le `Point3D` est un bon candidat pour que cette modification.</span><span class="sxs-lookup"><span data-stu-id="45ac3-191">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="45ac3-192">Le code suivant illustre une mise à jour `ReadonlyPoint3D` structure :</span><span class="sxs-lookup"><span data-stu-id="45ac3-192">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="45ac3-193">Type `ref struct`</span><span class="sxs-lookup"><span data-stu-id="45ac3-193">`ref struct` type</span></span>

<span data-ttu-id="45ac3-194">Une autre fonctionnalité de langage associé est la possibilité de déclarer un type valeur qui doit être allouée à la pile.</span><span class="sxs-lookup"><span data-stu-id="45ac3-194">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="45ac3-195">En d’autres termes, ces types ne peuvent jamais être créés sur le tas en tant que membre d’une autre classe.</span><span class="sxs-lookup"><span data-stu-id="45ac3-195">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="45ac3-196">L’objectif principal de cette fonctionnalité a été <xref:System.Span%601> et les structures associées.</span><span class="sxs-lookup"><span data-stu-id="45ac3-196">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="45ac3-197"><xref:System.Span%601>peut contenir un pointeur managé comme l’un de ses membres, l’autre étant la longueur de l’étendue.</span><span class="sxs-lookup"><span data-stu-id="45ac3-197"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="45ac3-198">Il est implémenté en fait un peu différemment, car c# ne prend en charge des pointeurs vers la mémoire managée en dehors d’un contexte unsafe.</span><span class="sxs-lookup"><span data-stu-id="45ac3-198">It's actually implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="45ac3-199">Toute écriture qui modifie le pointeur et la longueur n’est pas atomique.</span><span class="sxs-lookup"><span data-stu-id="45ac3-199">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="45ac3-200">Cela signifie une <xref:System.Span%601> serait soumis à des erreurs de plage insuffisante ou d’autres violations de sécurité de type ont été il pas limité à un frame de pile.</span><span class="sxs-lookup"><span data-stu-id="45ac3-200">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="45ac3-201">En outre, placer un pointeur managé sur le tas GC généralement se bloque au moment de JIT.</span><span class="sxs-lookup"><span data-stu-id="45ac3-201">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="45ac3-202">Vous pouvez avoir des exigences similaires fonctionne avec créé à l’aide de la mémoire [ `stackalloc` ](language-reference/keywords/stackalloc.md) ou lors de l’utilisation de mémoire à partir de l’API d’interopérabilité.</span><span class="sxs-lookup"><span data-stu-id="45ac3-202">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="45ac3-203">Vous pouvez définir vos propres `ref struct` types à ces besoins.</span><span class="sxs-lookup"><span data-stu-id="45ac3-203">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="45ac3-204">Dans cet article, vous consultez des exemples d’utilisation de `Span<T>` par souci de simplicité.</span><span class="sxs-lookup"><span data-stu-id="45ac3-204">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="45ac3-205">Le `ref struct` déclaration déclare qu’une structure de ce type doit être sur la pile.</span><span class="sxs-lookup"><span data-stu-id="45ac3-205">The `ref struct` declaration declares that a struct of this type must be on the stack.</span></span> <span data-ttu-id="45ac3-206">Les règles de langage l’assurer le bon fonctionnement de ces types.</span><span class="sxs-lookup"><span data-stu-id="45ac3-206">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="45ac3-207">Autres types déclarés en tant que `ref struct` incluent <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="45ac3-207">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="45ac3-208">Le but de conserver un `ref struct` type telle qu’une variable allouée à la pile introduit plusieurs règles que le compilateur applique pour tous les `ref struct` types.</span><span class="sxs-lookup"><span data-stu-id="45ac3-208">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="45ac3-209">Vous ne peut pas convertir un `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="45ac3-209">You can't box a `ref struct`.</span></span> <span data-ttu-id="45ac3-210">Vous ne pouvez pas affecter un `ref struct` type dans une variable de type `object`, `dynamic`, ou n’importe quel type interface.</span><span class="sxs-lookup"><span data-stu-id="45ac3-210">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="45ac3-211">Vous ne pouvez pas déclarer un `ref struct` en tant que membre d’une classe ou un struct normal.</span><span class="sxs-lookup"><span data-stu-id="45ac3-211">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="45ac3-212">Vous ne pouvez pas déclarer des variables locales sont `ref struct` types dans les méthodes async.</span><span class="sxs-lookup"><span data-stu-id="45ac3-212">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="45ac3-213">Vous pouvez les déclarer dans des méthodes synchrones qui retournent `Task`, `Task<T>` ou les types de tâches.</span><span class="sxs-lookup"><span data-stu-id="45ac3-213">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="45ac3-214">Vous ne pouvez pas déclarer `ref struct` variables locales dans les itérateurs.</span><span class="sxs-lookup"><span data-stu-id="45ac3-214">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="45ac3-215">Vous ne pouvez pas capturer `ref struct` variables dans les expressions lambda ou de fonctions locales.</span><span class="sxs-lookup"><span data-stu-id="45ac3-215">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="45ac3-216">Ces restrictions s’assurer que vous n’utilisez pas accidentellement un `ref struct` d’une manière qui pourrait le promouvoir pour le tas managé.</span><span class="sxs-lookup"><span data-stu-id="45ac3-216">These restrictions ensure that you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="conclusions"></a><span data-ttu-id="45ac3-217">Conclusions</span><span class="sxs-lookup"><span data-stu-id="45ac3-217">Conclusions</span></span>

<span data-ttu-id="45ac3-218">Ces améliorations du langage c# sont conçues pour les algorithmes de performances critiques où les allocations de mémoire peuvent être essentielles d’atteindre les performances nécessaires.</span><span class="sxs-lookup"><span data-stu-id="45ac3-218">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="45ac3-219">Vous constaterez peut-être que vous n’utilisez pas souvent ces fonctionnalités dans le code que vous écrivez.</span><span class="sxs-lookup"><span data-stu-id="45ac3-219">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="45ac3-220">Toutefois, ces améliorations ont été adoptées à de nombreux emplacements dans le .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45ac3-220">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="45ac3-221">Comme les API d’utiliser ces fonctionnalités, vous verrez les performances de vos propres applications améliorer.</span><span class="sxs-lookup"><span data-stu-id="45ac3-221">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
