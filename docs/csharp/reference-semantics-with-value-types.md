---
title: Sémantique de référence avec les types valeur
description: Comprendre les fonctionnalités de langage conçues pour minimiser les structures de copie en toute sécurité
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 778897dc92f8a94178ebbbed7704c0dfe2397729
ms.sourcegitcommit: 935d5267c44f9bce801468ef95f44572f1417e8c
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/28/2018
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="b5a74-103">Sémantique de référence avec les types valeur</span><span class="sxs-lookup"><span data-stu-id="b5a74-103">Reference semantics with value types</span></span>

<span data-ttu-id="b5a74-104">L’avantage des types valeur est qu’ils permettent souvent d’éviter les allocations de tas.</span><span class="sxs-lookup"><span data-stu-id="b5a74-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="b5a74-105">Mais l’inconvénient, c’est qu’ils sont copiés par valeur.</span><span class="sxs-lookup"><span data-stu-id="b5a74-105">The disadvantage is that they are copied by value.</span></span> <span data-ttu-id="b5a74-106">Ce compromis complique l’optimisation des algorithmes qui opèrent sur de grandes quantités de données.</span><span class="sxs-lookup"><span data-stu-id="b5a74-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="b5a74-107">Les nouvelles fonctionnalités de langage dans C# 7.2 fournissent des mécanismes qui permettent la sémantique de passage par référence avec des types valeur.</span><span class="sxs-lookup"><span data-stu-id="b5a74-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="b5a74-108">Utilisez ces fonctionnalités judicieusement pour minimiser à la fois les allocations et les opérations de copie.</span><span class="sxs-lookup"><span data-stu-id="b5a74-108">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="b5a74-109">Cet article explore ces nouvelles fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="b5a74-109">This article explores those new features.</span></span>

<span data-ttu-id="b5a74-110">Une grande partie de l’exemple de code de cet article illustre les fonctionnalités ajoutées dans C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="b5a74-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="b5a74-111">Pour pouvoir utiliser ces fonctionnalités, vous devez configurer votre projet de telle sorte qu’il utilise C# 7.2 ou ultérieur.</span><span class="sxs-lookup"><span data-stu-id="b5a74-111">In order to use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="b5a74-112">Vous pouvez utiliser Visual Studio pour le sélectionner.</span><span class="sxs-lookup"><span data-stu-id="b5a74-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="b5a74-113">Pour chaque projet, sélectionnez **Projet** dans le menu, puis **Propriétés**.</span><span class="sxs-lookup"><span data-stu-id="b5a74-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="b5a74-114">Sélectionnez l’onglet **Build**, puis cliquez sur **Avancé**.</span><span class="sxs-lookup"><span data-stu-id="b5a74-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="b5a74-115">À partir de là, configurez la version du langage.</span><span class="sxs-lookup"><span data-stu-id="b5a74-115">From there, configure the language version.</span></span> <span data-ttu-id="b5a74-116">Choisissez « 7.2 », ou « dernière ».</span><span class="sxs-lookup"><span data-stu-id="b5a74-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="b5a74-117">Sinon, vous pouvez modifier le fichier *csproj* et ajouter le nœud suivant :</span><span class="sxs-lookup"><span data-stu-id="b5a74-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="b5a74-118">Vous pouvez utiliser « 7.2 » ou « dernière » comme valeur.</span><span class="sxs-lookup"><span data-stu-id="b5a74-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="passing-arguments-by-readonly-reference"></a><span data-ttu-id="b5a74-119">Passage d’arguments par référence en lecture seule</span><span class="sxs-lookup"><span data-stu-id="b5a74-119">Passing arguments by readonly reference</span></span>

<span data-ttu-id="b5a74-120">C# 7.2 ajoute le mot clé `in` en plus des mots clés `ref` et `out` existants pour passer des arguments par référence.</span><span class="sxs-lookup"><span data-stu-id="b5a74-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="b5a74-121">Le mot clé `in` spécifie le passage de l’argument par référence, mais la méthode appelée ne modifie pas la valeur.</span><span class="sxs-lookup"><span data-stu-id="b5a74-121">The `in` keyword specifies passing the argument by reference, but the called method does not modify the value.</span></span> 

<span data-ttu-id="b5a74-122">Vous disposez ainsi d’un vocabulaire complet pour exprimer votre intention de conception.</span><span class="sxs-lookup"><span data-stu-id="b5a74-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="b5a74-123">Les types valeur sont copiés s’ils sont passés à une méthode appelée et que vous ne spécifiez pas l’un des modificateurs suivants dans la signature de la méthode.</span><span class="sxs-lookup"><span data-stu-id="b5a74-123">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="b5a74-124">Chacun de ces modificateurs spécifie qu’un type valeur est passé par référence, évitant ainsi la copie.</span><span class="sxs-lookup"><span data-stu-id="b5a74-124">Each of these modifiers specifies that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="b5a74-125">Chaque modificateur exprime une intention différente :</span><span class="sxs-lookup"><span data-stu-id="b5a74-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="b5a74-126">`out` : Cette méthode définit la valeur de l’argument utilisé comme paramètre.</span><span class="sxs-lookup"><span data-stu-id="b5a74-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="b5a74-127">`ref` : Cette méthode peut définir la valeur de l’argument utilisé comme paramètre.</span><span class="sxs-lookup"><span data-stu-id="b5a74-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="b5a74-128">`in` : Cette méthode ne modifie pas la valeur de l’argument utilisé comme paramètre.</span><span class="sxs-lookup"><span data-stu-id="b5a74-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="b5a74-129">Ajoutez le modificateur `in` pour passer un argument par référence et déclarez que votre intention de conception est de passer des arguments par référence afin d’éviter toute copie inutile.</span><span class="sxs-lookup"><span data-stu-id="b5a74-129">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="b5a74-130">Vous n’avez pas l’intention de modifier l’objet utilisé comme argument.</span><span class="sxs-lookup"><span data-stu-id="b5a74-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="b5a74-131">Le code suivant montre un exemple de méthode qui calcule la distance entre deux points dans l’espace 3D.</span><span class="sxs-lookup"><span data-stu-id="b5a74-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="b5a74-132">Les arguments sont deux structures qui contiennent chacune trois valeurs de type double.</span><span class="sxs-lookup"><span data-stu-id="b5a74-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="b5a74-133">Un double représentant 8 octets, chaque argument représente 24 octets.</span><span class="sxs-lookup"><span data-stu-id="b5a74-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="b5a74-134">En spécifiant le modificateur `in`, vous passez une référence de 4 ou 8 octets à ces arguments, selon l’architecture de l’ordinateur.</span><span class="sxs-lookup"><span data-stu-id="b5a74-134">By specifying the `in` modifier, you pass a 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="b5a74-135">La différence de taille est minime, mais elle peut rapidement s’accentuer si votre application appelle cette méthode dans une boucle serrée avec de nombreuses valeurs différentes.</span><span class="sxs-lookup"><span data-stu-id="b5a74-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="b5a74-136">Le modificateur `in` complète aussi `out` et `ref` d’autres façons.</span><span class="sxs-lookup"><span data-stu-id="b5a74-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="b5a74-137">Vous ne pouvez pas créer de surcharges de méthode qui diffèrent uniquement en présence de `in`, `out` ou `ref`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-137">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="b5a74-138">Ces nouvelles règles étendent le même comportement qui a toujours été défini pour les paramètres `out` et `ref`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="b5a74-139">Le modificateur `in` peut être appliqué à tout membre acceptant des paramètres : méthodes, délégués, expressions lambda, fonctions locales, indexeurs, opérateurs.</span><span class="sxs-lookup"><span data-stu-id="b5a74-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="b5a74-140">Contrairement aux arguments `ref` et `out`, vous pouvez utiliser des constantes ou des valeurs littérales pour l’argument à un paramètre `in`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="b5a74-141">Par ailleurs, contrairement à un paramètre `ref` ou `out`, il est inutile d’appliquer le modificateur `in` au niveau du site d’appel.</span><span class="sxs-lookup"><span data-stu-id="b5a74-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="b5a74-142">Le code suivant donne deux exemples d’appel de la méthode `CalculateDistance`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="b5a74-143">Le premier utilise deux variables locales passées par référence.</span><span class="sxs-lookup"><span data-stu-id="b5a74-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="b5a74-144">La deuxième inclut une variable temporaire créée dans le cadre de l’appel de méthode.</span><span class="sxs-lookup"><span data-stu-id="b5a74-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="b5a74-145">Le compilateur veille de plusieurs manières à l’application du principe « en lecture seule » d’un argument `in`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="b5a74-146">Premièrement, la méthode appelée ne peut rien assigner directement à un paramètre `in`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="b5a74-147">Elle ne peut rien assigner directement à un champ d’un paramètre `in` quand cette valeur est un type `struct`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-147">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="b5a74-148">Par ailleurs, vous ne pouvez pas passer un paramètre `in` à une méthode à l’aide du modificateur `ref` ou `out`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-148">In addition, you cannot pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="b5a74-149">Ces règles s’appliquent à tout champ d’un paramètre `in`, dans la mesure où le champ est un type `struct` et le paramètre également un type `struct`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-149">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="b5a74-150">En fait, ces règles s’appliquent à plusieurs couches d’accès au membre, dans la mesure où les types situés à tous les niveaux d’accès au membre sont des `structs`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-150">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span> <span data-ttu-id="b5a74-151">Le compilateur considère que les types `struct` passés en tant qu’arguments `in` et leurs membres `struct` sont des variables en lecture seule quand ils sont utilisés en tant qu’arguments pour d’autres méthodes.</span><span class="sxs-lookup"><span data-stu-id="b5a74-151">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="b5a74-152">L’utilisation de paramètres `in` permet d’éviter les éventuels coûts en termes de performances liés aux copies.</span><span class="sxs-lookup"><span data-stu-id="b5a74-152">The use of `in` parameters avoids the potential performance costs of making copies.</span></span> <span data-ttu-id="b5a74-153">Elle ne modifie pas la sémantique des appels de méthode.</span><span class="sxs-lookup"><span data-stu-id="b5a74-153">It does not change the semantics of any method call.</span></span> <span data-ttu-id="b5a74-154">Donc, vous n’avez pas besoin de spécifier le modificateur `in` sur le site d’appel.</span><span class="sxs-lookup"><span data-stu-id="b5a74-154">Therefore, you do not need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="b5a74-155">En revanche, l’omission du modificateur `in` sur le site d’appel indique au compilateur qu’il est autorisé à effectuer une copie de l’argument pour les raisons suivantes :</span><span class="sxs-lookup"><span data-stu-id="b5a74-155">However, omitting the `in` modifier at the call site informs the compiler that it is allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="b5a74-156">Il existe une conversion implicite, mais pas une conversion d’identité du type de l’argument en type du paramètre.</span><span class="sxs-lookup"><span data-stu-id="b5a74-156">There is an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="b5a74-157">L’argument est une expression, mais ne dispose pas d’une variable de stockage connue.</span><span class="sxs-lookup"><span data-stu-id="b5a74-157">The argument is an expression but does not have a known storage variable.</span></span>
- <span data-ttu-id="b5a74-158">Il existe une surcharge qui diffère selon la présence ou l’absence de `in`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-158">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="b5a74-159">Dans ce cas, la surcharge par valeur convient mieux.</span><span class="sxs-lookup"><span data-stu-id="b5a74-159">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="b5a74-160">Ces règles s’avèrent utiles quand vous mettez à jour le code existant pour utiliser des arguments de référence en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="b5a74-160">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="b5a74-161">À l’intérieur de la méthode appelée, vous pouvez appeler toute méthode d’instance qui utilise des paramètres par valeur.</span><span class="sxs-lookup"><span data-stu-id="b5a74-161">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="b5a74-162">Dans ces instances, une copie du paramètre `in` est créée.</span><span class="sxs-lookup"><span data-stu-id="b5a74-162">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="b5a74-163">Étant donné que le compilateur peut créer une variable temporaire pour tout paramètre `in`, vous pouvez également spécifier des valeurs par défaut pour tout paramètre `in`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-163">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="b5a74-164">Le code suivant spécifie l’origine (point 0,0) comme valeur par défaut du deuxième point :</span><span class="sxs-lookup"><span data-stu-id="b5a74-164">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="b5a74-165">Pour forcer le compilateur à passer des arguments en lecture seule par référence, spécifiez le modificateur `in` sur les arguments au niveau du site d’appel, comme indiqué dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="b5a74-165">To force the compiler to pass read only arguments by reference, specify the `in` modifer on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="b5a74-166">Ce comportement facilite l’adoption de paramètres `in` au fil du temps dans les codes bases volumineux où des gains de performance sont possibles.</span><span class="sxs-lookup"><span data-stu-id="b5a74-166">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="b5a74-167">Vous commencez par ajouter le modificateur `in` aux signatures de méthode.</span><span class="sxs-lookup"><span data-stu-id="b5a74-167">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="b5a74-168">Ensuite, vous pouvez ajouter le modificateur `in` au niveau des sites d’appel et créer des types `readonly struct` pour permettre au compilateur d’éviter de créer des copies défensives des paramètres `in` à d’autres emplacements.</span><span class="sxs-lookup"><span data-stu-id="b5a74-168">Then, you can add the `in` modifier at callsites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="b5a74-169">La désignation du paramètre `in` peut également être utilisée avec des types référence ou des valeurs numériques.</span><span class="sxs-lookup"><span data-stu-id="b5a74-169">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="b5a74-170">Toutefois, les avantages dans les deux cas sont minimes, voire inexistants.</span><span class="sxs-lookup"><span data-stu-id="b5a74-170">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="b5a74-171">Retours `ref readonly`</span><span class="sxs-lookup"><span data-stu-id="b5a74-171">`ref readonly` returns</span></span>

<span data-ttu-id="b5a74-172">Vous pouvez également retourner un type valeur par référence, mais interdire à l’appelant de modifier cette valeur.</span><span class="sxs-lookup"><span data-stu-id="b5a74-172">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="b5a74-173">Pour exprimer cette intention de conception, utilisez le modificateur `ref readonly`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-173">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="b5a74-174">Celui-ci indique aux lecteurs que vous retournez une référence à des données existantes, mais que vous n’autorisez aucune modification.</span><span class="sxs-lookup"><span data-stu-id="b5a74-174">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="b5a74-175">Le compilateur fait en sorte que l’appelant ne puisse pas modifier la référence.</span><span class="sxs-lookup"><span data-stu-id="b5a74-175">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="b5a74-176">Toute tentative d’assignation directe de la valeur génère une erreur de compilation.</span><span class="sxs-lookup"><span data-stu-id="b5a74-176">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="b5a74-177">Toutefois, le compilateur ne peut pas savoir si une méthode membre modifie l’état du struct.</span><span class="sxs-lookup"><span data-stu-id="b5a74-177">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="b5a74-178">Pour vérifier que l’objet n’est pas modifié, le compilateur crée une copie et appelle les références de membre à l’aide de cette copie.</span><span class="sxs-lookup"><span data-stu-id="b5a74-178">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="b5a74-179">Les modifications sont apportées à cette copie défensive.</span><span class="sxs-lookup"><span data-stu-id="b5a74-179">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="b5a74-180">Il est probable que la bibliothèque utilisant `Point3D` ait recours à l’origine dans tout le code.</span><span class="sxs-lookup"><span data-stu-id="b5a74-180">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="b5a74-181">Chaque instance crée un objet sur la pile.</span><span class="sxs-lookup"><span data-stu-id="b5a74-181">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="b5a74-182">Il peut être avantageux de créer une constante et de la retourner par référence.</span><span class="sxs-lookup"><span data-stu-id="b5a74-182">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="b5a74-183">Mais si vous retournez une référence à un stockage interne, il peut être judicieux de veiller à ce que l’appelant ne puisse pas modifier le stockage référencé.</span><span class="sxs-lookup"><span data-stu-id="b5a74-183">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="b5a74-184">Le code suivant définit une propriété en lecture seule qui retourne un `readonly ref` à un `Point3D` qui spécifie l’origine.</span><span class="sxs-lookup"><span data-stu-id="b5a74-184">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="b5a74-185">Pour créer une copie d’un ref readonly return, il vous suffit de l’assigner à une variable non déclarée avec le modificateur `ref readonly`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-185">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="b5a74-186">Le compilateur génère du code pour copier l’objet dans le cadre de l’assignation.</span><span class="sxs-lookup"><span data-stu-id="b5a74-186">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="b5a74-187">Quand vous assignez une variable à un `ref readonly return`, vous pouvez spécifier une variable `ref readonly` ou une copie par valeur de la référence en lecture seule :</span><span class="sxs-lookup"><span data-stu-id="b5a74-187">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the read-only reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="b5a74-188">La première assignation dans le code précédent effectue une copie de la constante `Origin` et assigne cette copie.</span><span class="sxs-lookup"><span data-stu-id="b5a74-188">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="b5a74-189">La seconde assigne une référence.</span><span class="sxs-lookup"><span data-stu-id="b5a74-189">The second assigns a reference.</span></span> <span data-ttu-id="b5a74-190">Notez que le modificateur `readonly` doit faire partie de la déclaration de la variable.</span><span class="sxs-lookup"><span data-stu-id="b5a74-190">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="b5a74-191">La référence à laquelle il fait référence ne peut pas être modifiée.</span><span class="sxs-lookup"><span data-stu-id="b5a74-191">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="b5a74-192">Toute tentative de modification provoque une erreur de compilation.</span><span class="sxs-lookup"><span data-stu-id="b5a74-192">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="b5a74-193">Type `readonly struct`</span><span class="sxs-lookup"><span data-stu-id="b5a74-193">`readonly struct` type</span></span>

<span data-ttu-id="b5a74-194">L’application de `ref readonly` à des utilisations à trafic élevé d’un struct peut suffire.</span><span class="sxs-lookup"><span data-stu-id="b5a74-194">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="b5a74-195">Dans d’autres cas, il peut-être préférable de créer un struct immuable.</span><span class="sxs-lookup"><span data-stu-id="b5a74-195">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="b5a74-196">Vous pouvez toujours passer des valeurs par référence en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="b5a74-196">Then you can always pass by read-only reference.</span></span> <span data-ttu-id="b5a74-197">Cette pratique supprime les copies défensives qui se produisent quand vous accédez aux méthodes d’un struct utilisé comme paramètre `in`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-197">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="b5a74-198">Pour cela, créez un type `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-198">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="b5a74-199">Ajoutez le modificateur `readonly` à une déclaration de struct.</span><span class="sxs-lookup"><span data-stu-id="b5a74-199">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="b5a74-200">Le compilateur veille à ce que tous les membres d’instance du struct soient `readonly` ; le `struct` doit être immuable.</span><span class="sxs-lookup"><span data-stu-id="b5a74-200">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="b5a74-201">Il existe d’autres optimisations pour un `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-201">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="b5a74-202">Vous pouvez utiliser le modificateur `in` à chaque emplacement où `readonly struct` est un argument.</span><span class="sxs-lookup"><span data-stu-id="b5a74-202">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="b5a74-203">En outre, vous pouvez retourner un `readonly struct` comme `ref return` quand vous retournez un objet dont la durée de vie s’étend au-delà de la portée de la méthode retournant l’objet.</span><span class="sxs-lookup"><span data-stu-id="b5a74-203">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="b5a74-204">Enfin, le compilateur génère du code plus performant quand vous appelez les membres d’un `readonly struct` : la référence `this`, et non une copie du récepteur, est toujours un paramètre `in` passé par référence à la méthode de membre.</span><span class="sxs-lookup"><span data-stu-id="b5a74-204">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="b5a74-205">Cette optimisation évite d’autres opérations de copie quand vous utilisez un `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-205">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="b5a74-206">`Point3D` est un bon candidat pour ce changement.</span><span class="sxs-lookup"><span data-stu-id="b5a74-206">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="b5a74-207">Le code suivant illustre une structure `ReadonlyPoint3D` mise à jour :</span><span class="sxs-lookup"><span data-stu-id="b5a74-207">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="b5a74-208">Type `ref struct`</span><span class="sxs-lookup"><span data-stu-id="b5a74-208">`ref struct` type</span></span>

<span data-ttu-id="b5a74-209">Une autre fonctionnalité de langage associé est la possibilité de déclarer un type valeur qui doit être alloué par la pile.</span><span class="sxs-lookup"><span data-stu-id="b5a74-209">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="b5a74-210">En d’autres termes, ces types ne peuvent jamais être créés sur le tas comme membres d’une autre classe.</span><span class="sxs-lookup"><span data-stu-id="b5a74-210">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="b5a74-211">Cette fonctionnalité vise principalement <xref:System.Span%601> et ses structures associées.</span><span class="sxs-lookup"><span data-stu-id="b5a74-211">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="b5a74-212"><xref:System.Span%601> peut contenir un pointeur managé comme l’un de ses membres, l’autre étant la longueur de l’étendue.</span><span class="sxs-lookup"><span data-stu-id="b5a74-212"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="b5a74-213">Il est implémenté un peu différemment, car C# ne prend pas en charge les pointeurs vers la mémoire managée en dehors d’un contexte unsafe.</span><span class="sxs-lookup"><span data-stu-id="b5a74-213">It's implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="b5a74-214">Toute écriture qui change le pointeur et la longueur n’est pas atomique.</span><span class="sxs-lookup"><span data-stu-id="b5a74-214">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="b5a74-215">Cela signifie qu’un <xref:System.Span%601> ferait l’objet d’erreurs « hors limites » ou d’autres violations de cohérence des types s’il n’était pas limité à un frame de pile.</span><span class="sxs-lookup"><span data-stu-id="b5a74-215">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="b5a74-216">De plus, le fait de placer un pointeur managé sur le tas GC entraîne généralement un blocage au moment de JIT.</span><span class="sxs-lookup"><span data-stu-id="b5a74-216">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="b5a74-217">Vous pouvez avoir des exigences similaires quand vous utilisez de la mémoire créée avec [`stackalloc`](language-reference/keywords/stackalloc.md) ou de la mémoire provenant d’API d’interopérabilité.</span><span class="sxs-lookup"><span data-stu-id="b5a74-217">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="b5a74-218">Pour répondre à ces besoins, vous pouvez définir vos propres types `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-218">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="b5a74-219">Par souci de simplicité, cet article comprend des exemples d’utilisation de `Span<T>`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-219">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="b5a74-220">La déclaration `ref struct` déclare qu’un struct de ce type doit être sur la pile.</span><span class="sxs-lookup"><span data-stu-id="b5a74-220">The `ref struct` declaration declares a struct of this type must be on the stack.</span></span> <span data-ttu-id="b5a74-221">Les règles de langage garantissent l’utilisation sécurisée de ces types.</span><span class="sxs-lookup"><span data-stu-id="b5a74-221">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="b5a74-222">Parmi les autres types déclarés comme `ref struct`, citons <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="b5a74-222">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="b5a74-223">La conservation d’un type `ref struct` comme variable allouée par la pile introduit plusieurs règles que le compilateur applique pour tous les types `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-223">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="b5a74-224">Vous ne pouvez pas effectuer d’opération box sur un `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-224">You can't box a `ref struct`.</span></span> <span data-ttu-id="b5a74-225">Vous ne pouvez pas assigner un type `ref struct` à une variable de type `object`, `dynamic` ou tout type interface.</span><span class="sxs-lookup"><span data-stu-id="b5a74-225">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="b5a74-226">Vous ne pouvez pas déclarer `ref struct` comme membre d’une classe ou d’un struct normal.</span><span class="sxs-lookup"><span data-stu-id="b5a74-226">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="b5a74-227">Vous ne pouvez pas déclarer des variables locales qui sont des types `ref struct` dans des méthodes async.</span><span class="sxs-lookup"><span data-stu-id="b5a74-227">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="b5a74-228">Vous pouvez les déclarer dans des méthodes synchrones qui retournent `Task`, `Task<T>` ou des types similaires à Task.</span><span class="sxs-lookup"><span data-stu-id="b5a74-228">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="b5a74-229">Vous ne pouvez pas déclarer de variables locales `ref struct` dans des itérateurs.</span><span class="sxs-lookup"><span data-stu-id="b5a74-229">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="b5a74-230">Vous ne pouvez pas capturer de variables `ref struct` dans des expressions lambda ou des fonctions locales.</span><span class="sxs-lookup"><span data-stu-id="b5a74-230">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="b5a74-231">Ces restrictions vous empêchent d’utiliser accidentellement un `ref struct` d’une manière qui pourrait le promouvoir au niveau du tas managé.</span><span class="sxs-lookup"><span data-stu-id="b5a74-231">These restrictions ensure you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="b5a74-232">Type `readonly ref struct`</span><span class="sxs-lookup"><span data-stu-id="b5a74-232">`readonly ref struct` type</span></span>

<span data-ttu-id="b5a74-233">La déclaration d’un struct comme `readonly ref` combine les avantages et les restrictions des déclarations `ref struct` et `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-233">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` delcarations.</span></span> 

<span data-ttu-id="b5a74-234">L’exemple suivant montre la déclaration de `readonly ref struct`.</span><span class="sxs-lookup"><span data-stu-id="b5a74-234">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="b5a74-235">Conclusions</span><span class="sxs-lookup"><span data-stu-id="b5a74-235">Conclusions</span></span>

<span data-ttu-id="b5a74-236">Ces améliorations apportées au langage C# sont conçues pour les algorithmes axés sur les performances dans lesquels les allocations de mémoire peuvent être essentielles pour atteindre le niveau de performance nécessaire.</span><span class="sxs-lookup"><span data-stu-id="b5a74-236">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="b5a74-237">Vous constaterez peut-être que vous n’utilisez pas souvent ces fonctionnalités dans votre code.</span><span class="sxs-lookup"><span data-stu-id="b5a74-237">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="b5a74-238">Toutefois, ces améliorations ont été adoptées à divers endroits du .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b5a74-238">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="b5a74-239">Au fur et à mesure que les API adoptent ces fonctionnalités, vous verrez les performances de vos propres applications s’améliorer.</span><span class="sxs-lookup"><span data-stu-id="b5a74-239">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
