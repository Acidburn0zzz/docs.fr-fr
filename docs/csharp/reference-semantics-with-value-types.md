---
title: "Sémantique de référence avec les types valeur"
description: "Comprendre les fonctionnalités de langage conçues pour minimiser les structures de copie en toute sécurité"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 6e40907cab2aabcf8c8321819c99298314bcfbc5
ms.sourcegitcommit: 83dd5ec003e788ccb3e33f3412a7af39ae347646
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/15/2018
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="a4f2d-103">Sémantique de référence avec les types valeur</span><span class="sxs-lookup"><span data-stu-id="a4f2d-103">Reference semantics with value types</span></span>

<span data-ttu-id="a4f2d-104">L’avantage des types valeur est qu’ils permettent souvent d’éviter les allocations de tas.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="a4f2d-105">Mais l’inconvénient, c’est qu’ils sont copiés par valeur.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-105">The corresponding disadvantage is that they are copied by value.</span></span> <span data-ttu-id="a4f2d-106">Ce compromis complique l’optimisation des algorithmes qui opèrent sur de grandes quantités de données.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="a4f2d-107">Les nouvelles fonctionnalités de langage dans C# 7.2 fournissent des mécanismes qui permettent la sémantique de passage par référence avec des types valeur.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="a4f2d-108">Si vous utilisez ces fonctionnalités judicieusement, vous pouvez minimiser à la fois les allocations et les opérations de copie.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-108">If you use these features wisely you can minimize both allocations and copy operations.</span></span> <span data-ttu-id="a4f2d-109">Cet article explore ces nouvelles fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-109">This article explores those new features.</span></span>

<span data-ttu-id="a4f2d-110">Une grande partie de l’exemple de code de cet article illustre les fonctionnalités ajoutées dans C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="a4f2d-111">Pour pouvoir utiliser ces fonctionnalités, vous devez configurer votre projet de telle sorte qu’il utilise C# 7.2 ou ultérieur.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-111">In order to use those features, you have to configure your project to use C# 7.2 or later in your project.</span></span> <span data-ttu-id="a4f2d-112">Vous pouvez utiliser Visual Studio pour le sélectionner.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="a4f2d-113">Pour chaque projet, sélectionnez **Projet** dans le menu, puis **Propriétés**.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="a4f2d-114">Sélectionnez l’onglet **Build**, puis cliquez sur **Avancé**.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="a4f2d-115">À partir de là, vous pouvez configurer la version du langage.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-115">From there, you can configure the language version.</span></span> <span data-ttu-id="a4f2d-116">Choisissez « 7.2 », ou « dernière ».</span><span class="sxs-lookup"><span data-stu-id="a4f2d-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="a4f2d-117">Sinon, vous pouvez modifier le fichier *csproj* et ajouter le nœud suivant :</span><span class="sxs-lookup"><span data-stu-id="a4f2d-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="a4f2d-118">Vous pouvez utiliser « 7.2 » ou « dernière » comme valeur.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="specifying-in-parameters"></a><span data-ttu-id="a4f2d-119">Spécification des paramètres `in`</span><span class="sxs-lookup"><span data-stu-id="a4f2d-119">Specifying `in` parameters</span></span>

<span data-ttu-id="a4f2d-120">C# 7.2 ajoute le mot clé `in` pour compléter les mots clés `ref` et `out` existants quand vous écrivez une méthode qui passe des arguments par référence.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords when you write a method that passes arguments by reference.</span></span> <span data-ttu-id="a4f2d-121">Le mot clé `in` spécifie que vous passez le paramètre par référence et que la méthode appelée ne modifie pas la valeur qui lui est passée.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-121">The `in` keyword specifies that you are passing the parameter by reference and the called method does not modify the value passed to it.</span></span> 

<span data-ttu-id="a4f2d-122">Vous disposez ainsi d’un vocabulaire complet pour exprimer votre intention de conception.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="a4f2d-123">Les types valeur sont copiés s’ils sont passés à une méthode appelée et que vous ne spécifiez pas l’un des modificateurs suivants.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-123">Value types are copied when passed to a called method when you do not specify any of the following modifiers.</span></span> <span data-ttu-id="a4f2d-124">Chacun de ces modificateurs spécifie qu’un type valeur est passé par référence, évitant ainsi la copie.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-124">Each of these modifiers specify that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="a4f2d-125">Chaque modificateur exprime une intention différente :</span><span class="sxs-lookup"><span data-stu-id="a4f2d-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="a4f2d-126">`out` : Cette méthode définit la valeur de l’argument utilisé comme paramètre.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="a4f2d-127">`ref` : Cette méthode peut définir la valeur de l’argument utilisé comme paramètre.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="a4f2d-128">`in` : Cette méthode ne modifie pas la valeur de l’argument utilisé comme paramètre.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="a4f2d-129">Quand vous ajoutez le modificateur `in` pour passer un argument par référence, vous déclarez que votre intention de conception est de passer des arguments par référence afin d’éviter toute copie inutile.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-129">When you add the `in` modifier to pass an argument by reference, you declare your design intent is to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="a4f2d-130">Vous n’avez pas l’intention de modifier l’objet utilisé comme argument.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="a4f2d-131">Le code suivant montre un exemple de méthode qui calcule la distance entre deux points dans l’espace 3D.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="a4f2d-132">Les arguments sont deux structures qui contiennent chacune trois valeurs de type double.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="a4f2d-133">Un double représentant 8 octets, chaque argument représente 24 octets.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="a4f2d-134">En spécifiant le modificateur `in`, vous passez une référence de 4 ou 8 octets à ces arguments, selon l’architecture de l’ordinateur.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-134">By specifying the `in` modifier, you pass 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="a4f2d-135">La différence de taille est minime, mais elle peut rapidement s’accentuer si votre application appelle cette méthode dans une boucle serrée avec de nombreuses valeurs différentes.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="a4f2d-136">Le modificateur `in` complète aussi `out` et `ref` d’autres façons.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="a4f2d-137">Vous ne pouvez pas créer de surcharges de méthode qui diffèrent uniquement en présence de `in`, `out` ou `ref`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-137">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="a4f2d-138">Ces nouvelles règles étendent le même comportement qui a toujours été défini pour les paramètres `out` et `ref`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="a4f2d-139">Le modificateur `in` peut être appliqué à tout membre acceptant des paramètres : méthodes, délégués, expressions lambda, fonctions locales, indexeurs, opérateurs.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="a4f2d-140">Contrairement aux arguments `ref` et `out`, vous pouvez utiliser des constantes ou des valeurs littérales pour l’argument à un paramètre `in`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="a4f2d-141">Par ailleurs, contrairement à un paramètre `ref` ou `out`, il est inutile d’appliquer le modificateur `in` au niveau du site d’appel.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="a4f2d-142">Le code suivant donne deux exemples d’appel de la méthode `CalculateDistance`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="a4f2d-143">Le premier utilise deux variables locales passées par référence.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="a4f2d-144">La deuxième inclut une variable temporaire créée dans le cadre de l’appel de méthode.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="a4f2d-145">Le compilateur veille de plusieurs manières à l’application du principe « en lecture seule » d’un argument `in`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="a4f2d-146">Premièrement, la méthode appelée ne peut rien assigner directement à un paramètre `in`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="a4f2d-147">Elle ne peut rien assigner directement aux champs d’un paramètre `in`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-147">It can't directly assign to any field of an `in` parameter.</span></span> <span data-ttu-id="a4f2d-148">Par ailleurs, vous ne pouvez pas passer un paramètre `in` à une méthode exigeant le modificateur `ref` ou `out`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-148">In addition, you cannot pass an `in` parameter to any method demanding the `ref` or `out` modifier.</span></span>
<span data-ttu-id="a4f2d-149">Le compilateur veille à ce que l’argument `in` soit une variable en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-149">The compiler enforces that the `in` argument is a readonly variable.</span></span> <span data-ttu-id="a4f2d-150">Vous pouvez appeler n’importe quelle méthode d’instance qui utilise une sémantique de passage par valeur.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-150">You can call any instance method that uses pass-by-value semantics.</span></span> <span data-ttu-id="a4f2d-151">Dans ces instances, une copie du paramètre `in` est créée.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-151">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="a4f2d-152">Étant donné que le compilateur peut créer une variable temporaire pour tout paramètre `in`, vous pouvez également spécifier des valeurs par défaut pour tout paramètre `in`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-152">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="a4f2d-153">Pour illustrer ceci, le code suivant spécifie l’origine (point 0,0) comme valeur par défaut pour le deuxième point :</span><span class="sxs-lookup"><span data-stu-id="a4f2d-153">The follow code uses that to specify the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="a4f2d-154">La désignation du paramètre `in` peut également être utilisée avec des types référence ou générée dans les valeurs numériques.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-154">The `in` parameter designation can also be used with reference types or built in numeric values.</span></span> <span data-ttu-id="a4f2d-155">Toutefois, les avantages dans les deux cas sont minimes, voire inexistants.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-155">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="a4f2d-156">Retours `ref readonly`</span><span class="sxs-lookup"><span data-stu-id="a4f2d-156">`ref readonly` returns</span></span>

<span data-ttu-id="a4f2d-157">Vous pouvez également retourner un type valeur par référence, mais interdire à l’appelant de modifier cette valeur.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-157">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="a4f2d-158">Pour exprimer cette intention de conception, utilisez le modificateur `ref readonly`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-158">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="a4f2d-159">Celui-ci indique aux lecteurs que vous retournez une référence à des données existantes, mais que vous n’autorisez aucune modification.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-159">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="a4f2d-160">Le compilateur fait en sorte que l’appelant ne puisse pas modifier la référence.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-160">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="a4f2d-161">Toute tentative d’assignation directe à la valeur génère une erreur de compilation.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-161">Attempts to assign to the value directly generate a compile-time error.</span></span> <span data-ttu-id="a4f2d-162">Toutefois, le compilateur ne peut pas savoir si une méthode membre modifie l’état du struct.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-162">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="a4f2d-163">Pour vérifier que l’objet n’est pas modifié, le compilateur crée une copie et appelle les références de membre à l’aide de cette copie.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-163">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="a4f2d-164">Les modifications sont apportées à cette copie défensive.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-164">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="a4f2d-165">Il est probable que la bibliothèque utilisant `Point3D` ait recours à l’origine dans tout le code.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-165">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="a4f2d-166">Chaque instance crée un objet sur la pile.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-166">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="a4f2d-167">Il peut être avantageux de créer une constante et de la retourner par référence.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-167">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="a4f2d-168">Mais si vous retournez une référence à un stockage interne, il peut être judicieux de veiller à ce que l’appelant ne puisse pas modifier le stockage référencé.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-168">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="a4f2d-169">Le code suivant définit une propriété en lecture seule qui retourne un `readonly ref` à un `Point3D` qui spécifie l’origine.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-169">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="a4f2d-170">Pour créer une copie d’un ref readonly return, il vous suffit de l’assigner à une variable non déclarée avec le modificateur `ref readonly`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-170">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="a4f2d-171">Le compilateur génère du code pour copier l’objet dans le cadre de l’assignation.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-171">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="a4f2d-172">Quand vous assignez une variable à un `ref readonly return`, vous pouvez spécifier une variable `ref readonly` ou une copie par valeur de la référence en lecture seule :</span><span class="sxs-lookup"><span data-stu-id="a4f2d-172">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the readonly reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="a4f2d-173">La première assignation dans le code précédent effectue une copie de la constante `Origin` et assigne cette copie.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="a4f2d-174">La seconde assigne une référence.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-174">The second assigns a reference.</span></span> <span data-ttu-id="a4f2d-175">Notez que le modificateur `readonly` doit faire partie de la déclaration de la variable.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="a4f2d-176">La référence à laquelle il fait référence ne peut pas être modifiée.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-176">The reference to which it refers cannot be modified.</span></span> <span data-ttu-id="a4f2d-177">Toute tentative de modification provoque une erreur de compilation.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-177">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="a4f2d-178">Type `readonly struct`</span><span class="sxs-lookup"><span data-stu-id="a4f2d-178">`readonly struct` type</span></span>

<span data-ttu-id="a4f2d-179">L’application de `ref readonly` à des utilisations à trafic élevé d’un struct peut suffire.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-179">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="a4f2d-180">Dans d’autres cas, il peut-être préférable de créer un struct immuable.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-180">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="a4f2d-181">Vous pouvez toujours passer des valeurs par référence en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-181">Then you can always pass by readonly reference.</span></span> <span data-ttu-id="a4f2d-182">Cette pratique supprime les copies défensives qui se produisent quand vous accédez aux méthodes d’un struct utilisé comme paramètre `in`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-182">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="a4f2d-183">Pour cela, créez un type `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-183">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="a4f2d-184">Ajoutez le modificateur `readonly` à une déclaration de struct.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-184">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="a4f2d-185">Le compilateur veille à ce que tous les membres d’instance du struct soient `readonly` ; le `struct` doit être immuable.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-185">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="a4f2d-186">Il existe d’autres optimisations pour un `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-186">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="a4f2d-187">Vous pouvez utiliser le modificateur `in` à chaque emplacement où `readonly struct` est un argument.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-187">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="a4f2d-188">En outre, vous pouvez retourner un `readonly struct` comme `ref return` quand vous retournez un objet dont la durée de vie s’étend au-delà de la portée de la méthode retournant l’objet.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-188">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="a4f2d-189">Enfin, le compilateur génère du code plus performant quand vous appelez les membres d’un `readonly struct` : la référence `this`, et non une copie du récepteur, est toujours un paramètre `in` passé par référence à la méthode de membre.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-189">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="a4f2d-190">Cette optimisation évite d’autres opérations de copie quand vous utilisez un `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-190">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="a4f2d-191">`Point3D` est un bon candidat pour ce changement.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-191">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="a4f2d-192">Le code suivant illustre une structure `ReadonlyPoint3D` mise à jour :</span><span class="sxs-lookup"><span data-stu-id="a4f2d-192">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="a4f2d-193">Type `ref struct`</span><span class="sxs-lookup"><span data-stu-id="a4f2d-193">`ref struct` type</span></span>

<span data-ttu-id="a4f2d-194">Une autre fonctionnalité de langage associé est la possibilité de déclarer un type valeur qui doit être alloué par la pile.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-194">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="a4f2d-195">En d’autres termes, ces types ne peuvent jamais être créés sur le tas comme membres d’une autre classe.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-195">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="a4f2d-196">Cette fonctionnalité vise principalement <xref:System.Span%601> et ses structures associées.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-196">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="a4f2d-197"><xref:System.Span%601> peut contenir un pointeur managé comme l’un de ses membres, l’autre étant la longueur de l’étendue.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-197"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="a4f2d-198">En fait, il est implémenté un peu différemment, car C# ne prend pas en charge les pointeurs vers la mémoire managée en dehors d’un contexte unsafe.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-198">It's actually implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="a4f2d-199">Toute écriture qui change le pointeur et la longueur n’est pas atomique.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-199">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="a4f2d-200">Cela signifie qu’un <xref:System.Span%601> ferait l’objet d’erreurs « hors limites » ou d’autres violations de cohérence des types s’il n’était pas limité à un frame de pile.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-200">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="a4f2d-201">De plus, le fait de placer un pointeur managé sur le tas GC entraîne généralement un blocage au moment de JIT.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-201">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="a4f2d-202">Vous pouvez avoir des exigences similaires quand vous utilisez de la mémoire créée avec [`stackalloc`](language-reference/keywords/stackalloc.md) ou de la mémoire provenant d’API d’interopérabilité.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-202">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="a4f2d-203">Pour répondre à ces besoins, vous pouvez définir vos propres types `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-203">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="a4f2d-204">Par souci de simplicité, cet article comprend des exemples d’utilisation de `Span<T>`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-204">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="a4f2d-205">La déclaration `ref struct` déclare qu’un struct de ce type doit être sur la pile.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-205">The `ref struct` declaration declares that a struct of this type must be on the stack.</span></span> <span data-ttu-id="a4f2d-206">Les règles de langage garantissent l’utilisation sécurisée de ces types.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-206">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="a4f2d-207">Parmi les autres types déclarés comme `ref struct`, citons <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-207">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="a4f2d-208">La conservation d’un type `ref struct` comme variable allouée par la pile introduit plusieurs règles que le compilateur applique pour tous les types `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-208">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="a4f2d-209">Vous ne pouvez pas effectuer d’opération box sur un `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-209">You can't box a `ref struct`.</span></span> <span data-ttu-id="a4f2d-210">Vous ne pouvez pas assigner un type `ref struct` à une variable de type `object`, `dynamic` ou tout type interface.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-210">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="a4f2d-211">Vous ne pouvez pas déclarer `ref struct` comme membre d’une classe ou d’un struct normal.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-211">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="a4f2d-212">Vous ne pouvez pas déclarer des variables locales qui sont des types `ref struct` dans des méthodes async.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-212">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="a4f2d-213">Vous pouvez les déclarer dans des méthodes synchrones qui retournent `Task`, `Task<T>` ou des types similaires à Task.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-213">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="a4f2d-214">Vous ne pouvez pas déclarer de variables locales `ref struct` dans des itérateurs.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-214">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="a4f2d-215">Vous ne pouvez pas capturer de variables `ref struct` dans des expressions lambda ou des fonctions locales.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-215">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="a4f2d-216">Ces restrictions vous empêchent d’utiliser accidentellement un `ref struct` d’une manière qui pourrait le promouvoir au niveau du tas managé.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-216">These restrictions ensure that you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="conclusions"></a><span data-ttu-id="a4f2d-217">Conclusions</span><span class="sxs-lookup"><span data-stu-id="a4f2d-217">Conclusions</span></span>

<span data-ttu-id="a4f2d-218">Ces améliorations apportées au langage C# sont conçues pour les algorithmes axés sur les performances dans lesquels les allocations de mémoire peuvent être essentielles pour atteindre le niveau de performance nécessaire.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-218">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="a4f2d-219">Vous constaterez peut-être que vous n’utilisez pas souvent ces fonctionnalités dans votre code.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-219">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="a4f2d-220">Toutefois, ces améliorations ont été adoptées à divers endroits du .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-220">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="a4f2d-221">Au fur et à mesure que les API adoptent ces fonctionnalités, vous verrez les performances de vos propres applications s’améliorer.</span><span class="sxs-lookup"><span data-stu-id="a4f2d-221">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
