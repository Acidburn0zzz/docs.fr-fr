---
title: "Classes et objets dans C# - Visite guidée du langage C#"
description: "Novice en matière de langage C# ? Lisez cette présentation des classes, des objets et de l’héritage"
keywords: ".NET, csharp, classe, instance, objet, héritage, polymorphisme"
author: BillWagner
ms.author: wiwagn
ms.date: 08/10/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.openlocfilehash: 97559a6e7b24f4a61b49dd4f050747a6d0ccbda0
ms.sourcegitcommit: d95a91d685565f4d95c8773b558752864a6a3d7e
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/12/2018
---
# <a name="classes-and-objects"></a><span data-ttu-id="880a1-105">Classes et objets</span><span class="sxs-lookup"><span data-stu-id="880a1-105">Classes and objects</span></span>

<span data-ttu-id="880a1-106">Les *Classes* sont le type le plus fondamental de C#.</span><span class="sxs-lookup"><span data-stu-id="880a1-106">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="880a1-107">Une classe est une structure de données qui combine l’état (champs) et les actions (méthodes et autres fonctions membres) en une seule unité.</span><span class="sxs-lookup"><span data-stu-id="880a1-107">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="880a1-108">Une classe fournit une définition pour les *instances* créées dynamiquement de la classe, également appelées *objets*.</span><span class="sxs-lookup"><span data-stu-id="880a1-108">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="880a1-109">Les classes prennent en charge *l’héritage* et le *polymorphisme*, des mécanismes par lesquels les *classes dérivées* peuvent étendre et spécialiser les *classes de base*.</span><span class="sxs-lookup"><span data-stu-id="880a1-109">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="880a1-110">Les nouvelles classes sont créées à l’aide des déclarations de classe.</span><span class="sxs-lookup"><span data-stu-id="880a1-110">New classes are created using class declarations.</span></span> <span data-ttu-id="880a1-111">Une déclaration de classe commence par un en-tête qui spécifie les attributs et modificateurs de la classe, le nom de la classe, la classe de base (si fournie) et les interfaces implémentées par la classe.</span><span class="sxs-lookup"><span data-stu-id="880a1-111">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="880a1-112">L’en-tête est suivi par le corps de la classe, qui se compose d’une liste de déclarations de membres écrites entre les délimiteurs `{` et `}`.</span><span class="sxs-lookup"><span data-stu-id="880a1-112">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="880a1-113">Voici une déclaration d’une classe simple nommée `Point` :</span><span class="sxs-lookup"><span data-stu-id="880a1-113">The following is a declaration of a simple class named `Point`:</span></span>

[!code-csharp[PointClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]

<span data-ttu-id="880a1-114">Les instances de classes sont créées à l’aide de l’opérateur `new`, qui alloue la mémoire pour une nouvelle instance, appelle un constructeur pour initialiser l’instance et retourne une référence à l’instance.</span><span class="sxs-lookup"><span data-stu-id="880a1-114">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="880a1-115">Les instructions suivantes créent deux objets Point et stockent les références à ces objets dans les deux variables :</span><span class="sxs-lookup"><span data-stu-id="880a1-115">The following statements create two Point objects and store references to those objects in two variables:</span></span>

[!code-csharp[PointExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]

<span data-ttu-id="880a1-116">La mémoire occupée par un objet est automatiquement libérée lorsque l’objet n’est plus accessible.</span><span class="sxs-lookup"><span data-stu-id="880a1-116">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="880a1-117">Il n’est ni possible ni nécessaire de libérer explicitement des objets dans C#.</span><span class="sxs-lookup"><span data-stu-id="880a1-117">It is neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="880a1-118">Membres</span><span class="sxs-lookup"><span data-stu-id="880a1-118">Members</span></span>

<span data-ttu-id="880a1-119">Les membres d’une classe sont des membres statiques ou membres d’instance.</span><span class="sxs-lookup"><span data-stu-id="880a1-119">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="880a1-120">Les membres statiques appartiennent à des classes, et les membres d’instance appartiennent à des objets (instances de classes).</span><span class="sxs-lookup"><span data-stu-id="880a1-120">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="880a1-121">Vous trouverez ci-dessous une vue d’ensemble des types de membres qu'une classe peut contenir.</span><span class="sxs-lookup"><span data-stu-id="880a1-121">The following provides an overview of the kinds of members a class can contain.</span></span>

* <span data-ttu-id="880a1-122">Constantes</span><span class="sxs-lookup"><span data-stu-id="880a1-122">Constants</span></span>
    - <span data-ttu-id="880a1-123">Valeurs constantes associées à la classe</span><span class="sxs-lookup"><span data-stu-id="880a1-123">Constant values associated with the class</span></span>
* <span data-ttu-id="880a1-124">Champs</span><span class="sxs-lookup"><span data-stu-id="880a1-124">Fields</span></span>
    - <span data-ttu-id="880a1-125">Variables de la classe</span><span class="sxs-lookup"><span data-stu-id="880a1-125">Variables of the class</span></span>
* <span data-ttu-id="880a1-126">Méthodes</span><span class="sxs-lookup"><span data-stu-id="880a1-126">Methods</span></span>
    - <span data-ttu-id="880a1-127">Calculs et les actions qui peuvent être effectués par la classe</span><span class="sxs-lookup"><span data-stu-id="880a1-127">Computations and actions that can be performed by the class</span></span>
* <span data-ttu-id="880a1-128">Propriétés</span><span class="sxs-lookup"><span data-stu-id="880a1-128">Properties</span></span>
    - <span data-ttu-id="880a1-129">Actions associées à la lecture et l’écriture des propriétés nommées de la classe</span><span class="sxs-lookup"><span data-stu-id="880a1-129">Actions associated with reading and writing named properties of the class</span></span>
* <span data-ttu-id="880a1-130">Indexeurs</span><span class="sxs-lookup"><span data-stu-id="880a1-130">Indexers</span></span>
    - <span data-ttu-id="880a1-131">Actions liées à l’indexation des instances de la classe comme un tableau</span><span class="sxs-lookup"><span data-stu-id="880a1-131">Actions associated with indexing instances of the class like an array</span></span>
* <span data-ttu-id="880a1-132">Événements</span><span class="sxs-lookup"><span data-stu-id="880a1-132">Events</span></span>
    - <span data-ttu-id="880a1-133">Les notifications qui peuvent être générées par la classe</span><span class="sxs-lookup"><span data-stu-id="880a1-133">Notifications that can be generated by the class</span></span>
* <span data-ttu-id="880a1-134">Opérateurs</span><span class="sxs-lookup"><span data-stu-id="880a1-134">Operators</span></span>
    - <span data-ttu-id="880a1-135">Les opérateurs de conversion et d’expression pris en charge par la classe</span><span class="sxs-lookup"><span data-stu-id="880a1-135">Conversions and expression operators supported by the class</span></span>
* <span data-ttu-id="880a1-136">Constructeurs</span><span class="sxs-lookup"><span data-stu-id="880a1-136">Constructors</span></span>
    - <span data-ttu-id="880a1-137">Les actions requises pour initialiser les instances de la classe ou la classe elle-même</span><span class="sxs-lookup"><span data-stu-id="880a1-137">Actions required to initialize instances of the class or the class itself</span></span>
* <span data-ttu-id="880a1-138">Finaliseurs</span><span class="sxs-lookup"><span data-stu-id="880a1-138">Finalizers</span></span>
    - <span data-ttu-id="880a1-139">Actions à effectuer avant que les instances de la classe soient abandonnées de façon définitive</span><span class="sxs-lookup"><span data-stu-id="880a1-139">Actions to perform before instances of the class are permanently discarded</span></span>
* <span data-ttu-id="880a1-140">Types</span><span class="sxs-lookup"><span data-stu-id="880a1-140">Types</span></span>
    - <span data-ttu-id="880a1-141">Types imbriqués déclarés par la classe</span><span class="sxs-lookup"><span data-stu-id="880a1-141">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="880a1-142">Accessibilité</span><span class="sxs-lookup"><span data-stu-id="880a1-142">Accessibility</span></span>

<span data-ttu-id="880a1-143">Chaque membre d’une classe a une accessibilité associée, qui contrôle les régions du texte du programme qui sont en mesure d’accéder au membre.</span><span class="sxs-lookup"><span data-stu-id="880a1-143">Each member of a class has an associated accessibility, which controls the regions of program text that are able to access the member.</span></span> <span data-ttu-id="880a1-144">Il existe cinq formes possibles d’accessibilité.</span><span class="sxs-lookup"><span data-stu-id="880a1-144">There are five possible forms of accessibility.</span></span> <span data-ttu-id="880a1-145">Ils sont résumés ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="880a1-145">These are summarized below.</span></span>

* `public`
    - <span data-ttu-id="880a1-146">Accès non limité</span><span class="sxs-lookup"><span data-stu-id="880a1-146">Access not limited</span></span>
* `protected`
    - <span data-ttu-id="880a1-147">Accès limité à cette classe ou aux classes dérivées de cette classe</span><span class="sxs-lookup"><span data-stu-id="880a1-147">Access limited to this class or classes derived from this class</span></span>
* `internal`
    - <span data-ttu-id="880a1-148">Accès limité à l’assembly actuel (.exe, .dll, etc.)</span><span class="sxs-lookup"><span data-stu-id="880a1-148">Access limited to the current assembly (.exe, .dll, etc.)</span></span>
* `protected internal`
    - <span data-ttu-id="880a1-149">Accès limité à la classe conteneur ou aux classes dérivées de la classe conteneur</span><span class="sxs-lookup"><span data-stu-id="880a1-149">Access limited to the containing class or classes derived from the containing class</span></span>
* `private`
    - <span data-ttu-id="880a1-150">Accès limité à cette classe</span><span class="sxs-lookup"><span data-stu-id="880a1-150">Access limited to this class</span></span>
* `private protected`
    - <span data-ttu-id="880a1-151">Accès limité à la classe conteneur ou aux classes dérivées du type conteneur dans le même assembly</span><span class="sxs-lookup"><span data-stu-id="880a1-151">Access limited to the containing class or classes derived from the containing type within the same assembly</span></span>

## <a name="type-parameters"></a><span data-ttu-id="880a1-152">Paramètres de type</span><span class="sxs-lookup"><span data-stu-id="880a1-152">Type parameters</span></span>

<span data-ttu-id="880a1-153">Une définition de classe peut spécifier un jeu de paramètres de type en faisant suivre le nom de classe par une liste de noms de paramètre de type entre crochets.</span><span class="sxs-lookup"><span data-stu-id="880a1-153">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="880a1-154">Les paramètres de type peuvent ensuite être utilisés dans le corps des déclarations de classe pour définir les membres de la classe.</span><span class="sxs-lookup"><span data-stu-id="880a1-154">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="880a1-155">Dans l’exemple suivant, les paramètres de type de `Pair` sont `TFirst` et `TSecond` :</span><span class="sxs-lookup"><span data-stu-id="880a1-155">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

[!code-csharp[Pair](../../../samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]

<span data-ttu-id="880a1-156">Un type de classe déclaré pour prendre des paramètres de type est appelé un *type de classe générique*.</span><span class="sxs-lookup"><span data-stu-id="880a1-156">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="880a1-157">Les types struct, interface et délégué peuvent également être génériques.</span><span class="sxs-lookup"><span data-stu-id="880a1-157">Struct, interface and delegate types can also be generic.</span></span>
<span data-ttu-id="880a1-158">Lorsque la classe générique est utilisée, des arguments de type doivent être fournis pour chacun des paramètres de type :</span><span class="sxs-lookup"><span data-stu-id="880a1-158">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

[!code-csharp[PairExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]

<span data-ttu-id="880a1-159">Un type générique avec des arguments de type fournis, comme `Pair<int,string>` ci-dessus, est appelé un *type construit*.</span><span class="sxs-lookup"><span data-stu-id="880a1-159">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="880a1-160">Classes de base</span><span class="sxs-lookup"><span data-stu-id="880a1-160">Base classes</span></span>

<span data-ttu-id="880a1-161">Une déclaration de classe peut spécifier une classe de base en faisant suivre les paramètres de nom et de type de classe par un signe deux-points et le nom de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="880a1-161">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="880a1-162">L’omission d’une spécification de classe de base revient à dériver du type `object`.</span><span class="sxs-lookup"><span data-stu-id="880a1-162">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="880a1-163">Dans l'exemple suivant, la classe de base de `Point3D` est `Point`, et la classe de base de `Point` est `object` :</span><span class="sxs-lookup"><span data-stu-id="880a1-163">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

[!code-csharp[Point3DClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]

<span data-ttu-id="880a1-164">Une classe hérite des membres de sa classe de base.</span><span class="sxs-lookup"><span data-stu-id="880a1-164">A class inherits the members of its base class.</span></span> <span data-ttu-id="880a1-165">L’héritage signifie qu’une classe contient implicitement tous les membres de sa classe de base, à l’exception des constructeurs d’instance et statiques et des finaliseurs de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="880a1-165">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="880a1-166">Une classe dérivée peut ajouter des membres hérités, mais ne peut pas supprimer la définition d’un membre hérité.</span><span class="sxs-lookup"><span data-stu-id="880a1-166">A derived class can add new members to those it inherits, but it cannot remove the definition of an inherited member.</span></span> <span data-ttu-id="880a1-167">Dans l’exemple précédent, `Point3D` hérite des champs `x` et `y` de `Point`, et chaque instance de `Point3D` contient trois champs, `x`, `y` et `z`.</span><span class="sxs-lookup"><span data-stu-id="880a1-167">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="880a1-168">Il existe une conversion implicite d’un type de classe vers un de ses types de classe de base.</span><span class="sxs-lookup"><span data-stu-id="880a1-168">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="880a1-169">Par conséquent, une variable d’un type de classe peut référencer une instance de cette classe ou une instance d’une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="880a1-169">Therefore, a variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="880a1-170">Par exemple, pour les déclarations de classe précédentes, une variable de type `Point` peut faire référence à un objet `Point` ou `Point3D` :</span><span class="sxs-lookup"><span data-stu-id="880a1-170">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

[!code-csharp[Point3DExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]

## <a name="fields"></a><span data-ttu-id="880a1-171">Champs</span><span class="sxs-lookup"><span data-stu-id="880a1-171">Fields</span></span>

<span data-ttu-id="880a1-172">Un *champ* est une variable qui est associée à une classe ou une instance d’une classe.</span><span class="sxs-lookup"><span data-stu-id="880a1-172">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="880a1-173">Un champ déclaré avec le modificateur static définit un champ statique.</span><span class="sxs-lookup"><span data-stu-id="880a1-173">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="880a1-174">Un champ statique identifie exactement un seul emplacement de stockage.</span><span class="sxs-lookup"><span data-stu-id="880a1-174">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="880a1-175">Quel que soit le nombre d’instances d’une classe qui sont créées, il n’existe qu’une seule copie d’un champ statique.</span><span class="sxs-lookup"><span data-stu-id="880a1-175">No matter how many instances of a class are created, there is only ever one copy of a static field.</span></span>

<span data-ttu-id="880a1-176">Un champ déclaré sans le modificateur static définit un champ d’instance.</span><span class="sxs-lookup"><span data-stu-id="880a1-176">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="880a1-177">Chaque instance d’une classe contient une copie distincte de tous les champs d’instance de cette classe.</span><span class="sxs-lookup"><span data-stu-id="880a1-177">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="880a1-178">Dans l’exemple suivant, chaque instance de la classe `Color` possède une copie distincte des champs d’instance `r`, `g` et `b`, mais il existe une seule copie des champs statiques `Black`, `White`, `Red`, `Green` et `Blue` :</span><span class="sxs-lookup"><span data-stu-id="880a1-178">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there is only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

[!code-csharp[ColorClass](../../../samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]

<span data-ttu-id="880a1-179">Comme indiqué dans l’exemple précédent, les *champs en lecture seule* peuvent être déclarés avec un modificateur `readonly`.</span><span class="sxs-lookup"><span data-stu-id="880a1-179">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="880a1-180">L’affectation à un champ `readonly` peut survenir uniquement dans le cadre de la déclaration du champ ou dans un constructeur de la même classe.</span><span class="sxs-lookup"><span data-stu-id="880a1-180">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="880a1-181">Méthodes</span><span class="sxs-lookup"><span data-stu-id="880a1-181">Methods</span></span>

<span data-ttu-id="880a1-182">Une *méthode* est un membre qui implémente un calcul ou une action qui peut être effectuée par un objet ou une classe.</span><span class="sxs-lookup"><span data-stu-id="880a1-182">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="880a1-183">Les *méthodes statiques* sont accessibles à travers la classe.</span><span class="sxs-lookup"><span data-stu-id="880a1-183">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="880a1-184">Les *méthodes d’instance* sont accessibles via des instances de la classe.</span><span class="sxs-lookup"><span data-stu-id="880a1-184">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="880a1-185">Les méthodes peuvent avoir une liste de *paramètres*, qui représentent des valeurs ou des références variables passées à la méthode et un *type de retour*, qui spécifie le type de la valeur calculée et retournée par la méthode.</span><span class="sxs-lookup"><span data-stu-id="880a1-185">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="880a1-186">Le type de retour d’une méthode est `void` si elle ne retourne pas de valeur.</span><span class="sxs-lookup"><span data-stu-id="880a1-186">A method’s return type is `void` if it does not return a value.</span></span>

<span data-ttu-id="880a1-187">Comme les types, les méthodes peuvent également être un jeu de paramètres de type pour lesquels les arguments de type doivent être spécifiés lorsque la méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="880a1-187">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="880a1-188">Contrairement aux types, les arguments de type peuvent souvent être déduits à partir des arguments d’un appel de méthode et n’ont pas à être fournis explicitement.</span><span class="sxs-lookup"><span data-stu-id="880a1-188">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="880a1-189">La *signature* d’une méthode doit être unique dans la classe dans laquelle la méthode est déclarée.</span><span class="sxs-lookup"><span data-stu-id="880a1-189">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="880a1-190">La signature d’une méthode se compose du nom de la méthode, du nombre de paramètres de type et du nombre, des modificateurs et des types de ses paramètres.</span><span class="sxs-lookup"><span data-stu-id="880a1-190">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="880a1-191">La signature d'une méthode n'inclut pas le type de retour.</span><span class="sxs-lookup"><span data-stu-id="880a1-191">The signature of a method does not include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="880a1-192">Paramètres</span><span class="sxs-lookup"><span data-stu-id="880a1-192">Parameters</span></span>

<span data-ttu-id="880a1-193">Les paramètres sont utilisés pour passer des valeurs ou des références variables aux méthodes.</span><span class="sxs-lookup"><span data-stu-id="880a1-193">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="880a1-194">Les paramètres d’une méthode obtiennent leurs valeurs réelles à partir des *arguments* qui sont spécifiés lorsque la méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="880a1-194">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="880a1-195">Il existe quatre types de paramètres : les paramètres de valeur, les paramètres de référence, les paramètres de sortie et les tableaux de paramètres.</span><span class="sxs-lookup"><span data-stu-id="880a1-195">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="880a1-196">Un *paramètre de valeur* est utilisé pour passer des arguments en entrée.</span><span class="sxs-lookup"><span data-stu-id="880a1-196">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="880a1-197">Un paramètre de valeur correspond à une variable locale qui obtient sa valeur initiale de l’argument qui a été transmis pour le paramètre.</span><span class="sxs-lookup"><span data-stu-id="880a1-197">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="880a1-198">Les modifications apportées à un paramètre de valeur n’affectent pas l’argument qui a été transmis pour le paramètre.</span><span class="sxs-lookup"><span data-stu-id="880a1-198">Modifications to a value parameter do not affect the argument that was passed for the parameter.</span></span> 

<span data-ttu-id="880a1-199">Les paramètres de valeur peuvent être facultatifs, en spécifiant une valeur par défaut afin que les arguments correspondants puissent être omis.</span><span class="sxs-lookup"><span data-stu-id="880a1-199">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="880a1-200">Un *paramètre de référence* est utilisé pour passer des arguments par référence.</span><span class="sxs-lookup"><span data-stu-id="880a1-200">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="880a1-201">L’argument passé pour un paramètre de référence doit être une variable avec une valeur définie et, pendant l’exécution de la méthode, le paramètre de référence représente le même emplacement de stockage que la variable d’argument.</span><span class="sxs-lookup"><span data-stu-id="880a1-201">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="880a1-202">Un paramètre de référence est déclaré avec le modificateur `ref`.</span><span class="sxs-lookup"><span data-stu-id="880a1-202">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="880a1-203">L'exemple suivant illustre l'utilisation des paramètres `ref`.</span><span class="sxs-lookup"><span data-stu-id="880a1-203">The following example shows the use of `ref` parameters.</span></span>

[!code-csharp[swapExample](../../../samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]

<span data-ttu-id="880a1-204">Un *paramètre de sortie* est utilisé pour passer des arguments par référence.</span><span class="sxs-lookup"><span data-stu-id="880a1-204">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="880a1-205">Il est similaire à un paramètre de référence, sauf qu’il ne nécessite pas d’affecter explicitement une valeur à l’argument fourni par l’appelant.</span><span class="sxs-lookup"><span data-stu-id="880a1-205">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="880a1-206">Un paramètre de sortie est déclaré avec le modificateur `out`.</span><span class="sxs-lookup"><span data-stu-id="880a1-206">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="880a1-207">L’exemple suivant montre l’utilisation de paramètres `out` à l’aide de la syntaxe introduite dans C# 7.</span><span class="sxs-lookup"><span data-stu-id="880a1-207">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

[!code-csharp[OutExample](../../../samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]

<span data-ttu-id="880a1-208">Un *tableau de paramètres* autorise le passage d’un nombre variable d’arguments à une méthode.</span><span class="sxs-lookup"><span data-stu-id="880a1-208">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="880a1-209">Un tableau de paramètres est déclaré avec le modificateur `params`.</span><span class="sxs-lookup"><span data-stu-id="880a1-209">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="880a1-210">Seul le dernier paramètre d’une méthode peut être un tableau de paramètres, et le type d’un tableau de paramètres doit être un type tableau unidimensionnel.</span><span class="sxs-lookup"><span data-stu-id="880a1-210">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="880a1-211">Les méthodes Write et WriteLine de la classe <xref:System.Console?displayProperty=nameWithType> sont de bons exemples d’utilisation des tableaux de paramètres.</span><span class="sxs-lookup"><span data-stu-id="880a1-211">The Write and WriteLine methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="880a1-212">Vous les déclarez de la façon suivante.</span><span class="sxs-lookup"><span data-stu-id="880a1-212">They are declared as follows.</span></span>

[!code-csharp[ConsoleExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]

<span data-ttu-id="880a1-213">Dans une méthode qui utilise un tableau de paramètres, le tableau de paramètres se comporte exactement comme un paramètre ordinaire de type tableau.</span><span class="sxs-lookup"><span data-stu-id="880a1-213">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="880a1-214">Toutefois, dans un appel à une méthode avec un tableau de paramètres, il est possible de passer un argument unique de type tableau de paramètres ou n’importe quel nombre d’arguments du type d’élément du tableau de paramètres.</span><span class="sxs-lookup"><span data-stu-id="880a1-214">However, in an invocation of a method with a parameter array, it is possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="880a1-215">Dans ce cas, une instance de tableau est automatiquement créée et initialisée avec les arguments donnés.</span><span class="sxs-lookup"><span data-stu-id="880a1-215">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="880a1-216">Cet exemple</span><span class="sxs-lookup"><span data-stu-id="880a1-216">This example</span></span>

[!code-csharp[StringFormat](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]

<span data-ttu-id="880a1-217">revient à écrire ce qui suit.</span><span class="sxs-lookup"><span data-stu-id="880a1-217">is equivalent to writing the following.</span></span>

[!code-csharp[StringFormat2](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]

### <a name="method-body-and-local-variables"></a><span data-ttu-id="880a1-218">Corps de la méthode et variables locales</span><span class="sxs-lookup"><span data-stu-id="880a1-218">Method body and local variables</span></span>

<span data-ttu-id="880a1-219">Le corps d’une méthode spécifie les instructions à exécuter lorsque la méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="880a1-219">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="880a1-220">Un corps de méthode peut déclarer des variables qui sont spécifiques à l’appel de la méthode.</span><span class="sxs-lookup"><span data-stu-id="880a1-220">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="880a1-221">Ces variables sont appelées *variables locales*.</span><span class="sxs-lookup"><span data-stu-id="880a1-221">Such variables are called *local variables*.</span></span> <span data-ttu-id="880a1-222">Une déclaration de variable locale spécifie un nom de type, un nom de variable et éventuellement une valeur initiale.</span><span class="sxs-lookup"><span data-stu-id="880a1-222">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="880a1-223">L’exemple suivant déclare une variable locale `i` avec une valeur initiale de zéro et une variable locale `j` sans valeur initiale.</span><span class="sxs-lookup"><span data-stu-id="880a1-223">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

[!code-csharp[Squares](../../../samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]

<span data-ttu-id="880a1-224">C# requiert qu’une variable locale soit *assignée de manière définitive* avant de pouvoir obtenir sa valeur.</span><span class="sxs-lookup"><span data-stu-id="880a1-224">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="880a1-225">Par exemple, si la déclaration du `i` précédent n’inclut pas de valeur initiale, le compilateur signale une erreur pour les utilisations ultérieures de `i`, car `i` ne serait pas assigné de manière définitive à ces points dans le programme.</span><span class="sxs-lookup"><span data-stu-id="880a1-225">For example, if the declaration of the previous `i` did not include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` would not be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="880a1-226">Une méthode peut utiliser les instructions `return` pour retourner le contrôle à son appelant.</span><span class="sxs-lookup"><span data-stu-id="880a1-226">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="880a1-227">Dans une méthode retournant `void`, les instructions `return` ne peuvent pas spécifier une expression.</span><span class="sxs-lookup"><span data-stu-id="880a1-227">In a method returning `void`, `return` statements cannot specify an expression.</span></span> <span data-ttu-id="880a1-228">Dans une méthode avec un type de retour non void, les instructions `return` doivent inclure une expression qui calcule la valeur de retour.</span><span class="sxs-lookup"><span data-stu-id="880a1-228">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="880a1-229">Méthodes statiques et d’instance</span><span class="sxs-lookup"><span data-stu-id="880a1-229">Static and instance methods</span></span>

<span data-ttu-id="880a1-230">Une méthode déclarée avec un modificateur statique est une *méthode statique*.</span><span class="sxs-lookup"><span data-stu-id="880a1-230">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="880a1-231">Une méthode statique n’opère pas sur une instance spécifique et permet uniquement d’accéder directement à des membres statiques.</span><span class="sxs-lookup"><span data-stu-id="880a1-231">A static method does not operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="880a1-232">Une méthode déclarée sans un modificateur statique est une *méthode d’instance*.</span><span class="sxs-lookup"><span data-stu-id="880a1-232">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="880a1-233">Une méthode d’instance opère sur une instance spécifique et peut accéder aux membres statiques et d’instance.</span><span class="sxs-lookup"><span data-stu-id="880a1-233">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="880a1-234">L’instance sur laquelle une méthode d’instance a été appelée est explicitement accessible en tant que `this`.</span><span class="sxs-lookup"><span data-stu-id="880a1-234">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="880a1-235">Une erreur consiste à faire référence à `this` dans une méthode statique.</span><span class="sxs-lookup"><span data-stu-id="880a1-235">It is an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="880a1-236">La classe `Entity` suivante a à la fois des statiques et des membres d’instance.</span><span class="sxs-lookup"><span data-stu-id="880a1-236">The following `Entity` class has both static and instance members.</span></span>

[!code-csharp[Entity](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]

<span data-ttu-id="880a1-237">Chaque instance `Entity` contient un numéro de série (et probablement d’autres informations qui ne sont pas indiquées ici).</span><span class="sxs-lookup"><span data-stu-id="880a1-237">Each `Entity` instance contains a serial number (and presumably some other information that is not shown here).</span></span> <span data-ttu-id="880a1-238">Le constructeur `Entity` (qui est similaire à une méthode d’instance) initialise la nouvelle instance avec le numéro de série suivant.</span><span class="sxs-lookup"><span data-stu-id="880a1-238">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="880a1-239">Étant donné que le constructeur est un membre d’instance, il est autorisé à accéder à la fois au champ d’instance `serialNo` et au champ statique `nextSerialNo`.</span><span class="sxs-lookup"><span data-stu-id="880a1-239">Because the constructor is an instance member, it is permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="880a1-240">Les méthodes statiques `GetNextSerialNo` et `SetNextSerialNo` peuvent accéder au champ statique `nextSerialNo`, mais ce serait une erreur pour eux d’accéder directement au champ d’instance `serialNo`.</span><span class="sxs-lookup"><span data-stu-id="880a1-240">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="880a1-241">L’exemple suivant illustre l’utilisation de la classe d’entité.</span><span class="sxs-lookup"><span data-stu-id="880a1-241">The following example shows the use of the Entity class.</span></span>

[!code-csharp[EntityExample](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]

<span data-ttu-id="880a1-242">Notez que les méthodes statiques `SetNextSerialNo` et `GetNextSerialNo` sont appelées sur la classe alors que la méthode d’instance `GetSerialNo` est appelée sur les instances de la classe.</span><span class="sxs-lookup"><span data-stu-id="880a1-242">Note that the `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="880a1-243">Méthodes virtuelles, de substitution et abstraites</span><span class="sxs-lookup"><span data-stu-id="880a1-243">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="880a1-244">Lorsqu’une déclaration de méthode d’instance inclut un modificateur `virtual`, la méthode est appelée *méthode virtuelle*.</span><span class="sxs-lookup"><span data-stu-id="880a1-244">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="880a1-245">Si aucun modificateur virtuel n’est présent, la méthode est appelée *méthode non virtuelle*.</span><span class="sxs-lookup"><span data-stu-id="880a1-245">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="880a1-246">Lorsqu’une méthode virtuelle est appelée, le *type au moment de l’exécution* de l’instance pour laquelle cet appel prend place détermine l’implémentation de méthode à appeler.</span><span class="sxs-lookup"><span data-stu-id="880a1-246">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="880a1-247">Dans un appel de méthode non virtuelle, le *type lors de la compilation* de l’instance est le facteur déterminant.</span><span class="sxs-lookup"><span data-stu-id="880a1-247">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="880a1-248">Une méthode virtuelle peut être *substituée* dans une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="880a1-248">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="880a1-249">Lorsqu’une déclaration de méthode d’instance comprend un modificateur override, la méthode substitue une méthode virtuelle héritée ayant la même signature.</span><span class="sxs-lookup"><span data-stu-id="880a1-249">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="880a1-250">Là où une déclaration de méthode virtuelle présente une nouvelle méthode, une déclaration de méthode de substitution spécialise une méthode virtuelle héritée existante en fournissant une nouvelle implémentation de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="880a1-250">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="880a1-251">Une *méthode abstraite* est une méthode virtuelle sans implémentation.</span><span class="sxs-lookup"><span data-stu-id="880a1-251">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="880a1-252">Une méthode abstraite est déclarée avec le modificateur abstract et est autorisée uniquement dans une classe qui est également déclarée comme étant abstract.</span><span class="sxs-lookup"><span data-stu-id="880a1-252">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="880a1-253">Une méthode abstraite doit être remplacée dans chaque classe dérivée non abstraite.</span><span class="sxs-lookup"><span data-stu-id="880a1-253">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="880a1-254">L’exemple suivant déclare une classe abstraite, `Expression`, qui représente un nœud d’arborescence de l’expression et trois classes dérivées, `Constant`, `VariableReference` et `Operation`, qui implémentent des nœuds d’arborescence de l’expression pour les références variables, les constantes et les opérations arithmétiques.</span><span class="sxs-lookup"><span data-stu-id="880a1-254">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="880a1-255">(Cela est similaire aux types arborescence de l’expression, mais ne les confondez pas).</span><span class="sxs-lookup"><span data-stu-id="880a1-255">(This is similar to, but not to be confused with the expression tree types).</span></span>

[!code-csharp[ExpressionClass](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]

<span data-ttu-id="880a1-256">Les quatre classes précédentes permet de modéliser des expressions arithmétiques.</span><span class="sxs-lookup"><span data-stu-id="880a1-256">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="880a1-257">Par exemple, en utilisant des instances de ces classes, l’expression `x + 3` peut être représentée comme suit.</span><span class="sxs-lookup"><span data-stu-id="880a1-257">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

[!code-csharp[ExpressionExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]

<span data-ttu-id="880a1-258">La méthode `Evaluate` d’une instance `Expression` est appelée pour évaluer l’expression donnée et produire une valeur `double`.</span><span class="sxs-lookup"><span data-stu-id="880a1-258">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="880a1-259">La méthode prend un argument `Dictionary` qui contient des noms de variables (comme clés des entrées) et des valeurs (comme valeurs des entrées).</span><span class="sxs-lookup"><span data-stu-id="880a1-259">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="880a1-260">Comme `Evaluate` est une méthode abstraite, les classes non abstraites dérivées de `Expression` doivent remplacer `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="880a1-260">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="880a1-261">Une implémentation de `Constant` de `Evaluate` renvoie simplement la constante stockée.</span><span class="sxs-lookup"><span data-stu-id="880a1-261">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="880a1-262">Une implémentation de `VariableReference` recherche le nom de variable dans le dictionnaire et renvoie la valeur résultante.</span><span class="sxs-lookup"><span data-stu-id="880a1-262">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="880a1-263">Une implémentation de `Operation` évalue d’abord les opérandes de gauche et de droite (en appelant de manière récursive leurs méthodes `Evaluate`), puis effectue l’opération arithmétique donnée.</span><span class="sxs-lookup"><span data-stu-id="880a1-263">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="880a1-264">Le programme suivant utilise les classes `Expression` pour évaluer l’expression `x * (y + 2)` pour différentes valeurs de `x` et `y`.</span><span class="sxs-lookup"><span data-stu-id="880a1-264">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

[!code-csharp[ExpressionUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]

### <a name="method-overloading"></a><span data-ttu-id="880a1-265">Surcharge de méthode</span><span class="sxs-lookup"><span data-stu-id="880a1-265">Method overloading</span></span>

<span data-ttu-id="880a1-266">La *surcharge* de méthode permet d’avoir plusieurs méthodes dans la même classe avec le même nom, tant qu’elles ont des signatures uniques.</span><span class="sxs-lookup"><span data-stu-id="880a1-266">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="880a1-267">Lors de la compilation d’un appel à une méthode surchargée, le compilateur utilise *la résolution de surcharge* pour déterminer la méthode spécifique à appeler.</span><span class="sxs-lookup"><span data-stu-id="880a1-267">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="880a1-268">La résolution de surcharge trouve la méthode qui correspond le mieux aux arguments ou signale une erreur si aucune meilleure correspondance ne peut être trouvée.</span><span class="sxs-lookup"><span data-stu-id="880a1-268">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="880a1-269">L’exemple suivant montre la résolution de surcharge en action.</span><span class="sxs-lookup"><span data-stu-id="880a1-269">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="880a1-270">Le commentaire pour chaque appel de la méthode `Main` affiche une méthode qui est réellement appelée.</span><span class="sxs-lookup"><span data-stu-id="880a1-270">The comment for each invocation in the `Main` method shows which method is actually invoked.</span></span>

[!code-csharp[OverloadUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]

<span data-ttu-id="880a1-271">Comme le montre l’exemple, une méthode particulière peut toujours être sélectionnée en effectuant un cast explicite des arguments aux types de paramètres exacts et/ou en fournissant explicitement les arguments de type.</span><span class="sxs-lookup"><span data-stu-id="880a1-271">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="880a1-272">Autres fonctions membres</span><span class="sxs-lookup"><span data-stu-id="880a1-272">Other function members</span></span>

<span data-ttu-id="880a1-273">Les membres qui contiennent du code exécutable sont collectivement regroupés sous les *membres de fonction* d’une classe.</span><span class="sxs-lookup"><span data-stu-id="880a1-273">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="880a1-274">La section précédente décrit les méthodes qui sont du type principal des fonctions membres.</span><span class="sxs-lookup"><span data-stu-id="880a1-274">The preceding section describes methods, which are the primary kind of function members.</span></span> <span data-ttu-id="880a1-275">Cette section décrit les autres types de fonctions membres pris en charge par C# : constructeurs, propriétés, indexeurs, événements, opérateurs et finaliseurs.</span><span class="sxs-lookup"><span data-stu-id="880a1-275">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="880a1-276">L’exemple suivant montre une classe générique appelée List<T>, qui implémente une liste d’objets évolutive.</span><span class="sxs-lookup"><span data-stu-id="880a1-276">The following shows a generic class called List<T>, which implements a growable list of objects.</span></span> <span data-ttu-id="880a1-277">La classe contient plusieurs exemples des types les plus courants de membres de fonction.</span><span class="sxs-lookup"><span data-stu-id="880a1-277">The class contains several examples of the most common kinds of function members.</span></span>

[!code-csharp[ListClass](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]

### <a name="constructors"></a><span data-ttu-id="880a1-278">Constructeurs</span><span class="sxs-lookup"><span data-stu-id="880a1-278">Constructors</span></span>

<span data-ttu-id="880a1-279">C# prend en charge les constructeurs statiques et d’instance.</span><span class="sxs-lookup"><span data-stu-id="880a1-279">C# supports both instance and static constructors.</span></span> <span data-ttu-id="880a1-280">Un *constructeur d’instance* est un membre qui implémente les actions requises pour initialiser une instance d’une classe.</span><span class="sxs-lookup"><span data-stu-id="880a1-280">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="880a1-281">Un *constructeur statique* est un membre qui implémente les actions requises pour initialiser une classe lui-même lorsqu’il est chargé.</span><span class="sxs-lookup"><span data-stu-id="880a1-281">A *static constructor* is a member that implements the actions required to initialize a class itself when it is first loaded.</span></span>

<span data-ttu-id="880a1-282">Un constructeur est déclaré comme une méthode sans aucun type de retour et le même nom que la classe contenante.</span><span class="sxs-lookup"><span data-stu-id="880a1-282">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="880a1-283">Si une déclaration de constructeur comprend un modificateur static, elle déclare un constructeur statique.</span><span class="sxs-lookup"><span data-stu-id="880a1-283">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="880a1-284">Dans le cas contraire, elle déclare un constructeur d’instance.</span><span class="sxs-lookup"><span data-stu-id="880a1-284">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="880a1-285">Les constructeurs d’instance peuvent être surchargés et avoir des paramètres facultatifs.</span><span class="sxs-lookup"><span data-stu-id="880a1-285">Instance constructors can be overloaded, and can have optional parameters.</span></span> <span data-ttu-id="880a1-286">Par exemple, la classe `List<T>` déclare deux constructeurs d’instance, un sans paramètres et une fonction qui accepte un paramètre `int`.</span><span class="sxs-lookup"><span data-stu-id="880a1-286">For example, the `List<T>` class declares two instance constructors, one with no parameters and one that takes an `int` parameter.</span></span> <span data-ttu-id="880a1-287">Les constructeurs d’instance sont appelés en utilisant l’opérateur `new`.</span><span class="sxs-lookup"><span data-stu-id="880a1-287">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="880a1-288">Les instructions suivantes allouent deux instances `List<string>` à l’aide du constructeur de la classe `List` avec et sans l’argument facultatif.</span><span class="sxs-lookup"><span data-stu-id="880a1-288">The following statements allocate two `List<string>` instances using the constructor of the `List` class with and without the optional argument.</span></span>

[!code-csharp[ListExample1](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]

<span data-ttu-id="880a1-289">Contrairement aux autres membres, les constructeurs d’instance ne sont pas hérités, et une classe n’a aucun constructeur d’instance autre que ceux réellement déclarés dans la classe.</span><span class="sxs-lookup"><span data-stu-id="880a1-289">Unlike other members, instance constructors are not inherited, and a class has no instance constructors other than those actually declared in the class.</span></span> <span data-ttu-id="880a1-290">Si aucun constructeur d’instance n’est fourni pour une classe, un constructeur vide sans paramètre est fourni automatiquement.</span><span class="sxs-lookup"><span data-stu-id="880a1-290">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="880a1-291">Propriétés</span><span class="sxs-lookup"><span data-stu-id="880a1-291">Properties</span></span>

<span data-ttu-id="880a1-292">Les *propriétés* sont une extension naturelle des champs.</span><span class="sxs-lookup"><span data-stu-id="880a1-292">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="880a1-293">Les deux sont des membres nommés avec des types associés, et la syntaxe pour accéder aux champs et propriétés est la même.</span><span class="sxs-lookup"><span data-stu-id="880a1-293">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="880a1-294">Toutefois, contrairement aux champs, les propriétés ne désignent pas des emplacements de stockage.</span><span class="sxs-lookup"><span data-stu-id="880a1-294">However, unlike fields, properties do not denote storage locations.</span></span> <span data-ttu-id="880a1-295">Au lieu de cela, les propriétés ont des *accesseurs* qui spécifient les instructions à exécuter lorsque les valeurs sont lues ou écrites.</span><span class="sxs-lookup"><span data-stu-id="880a1-295">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="880a1-296">Une propriété est déclarée comme un champ, sauf que la déclaration se termine avec un accesseur get et/ou un accesseur set écrit entre les délimiteurs `{` et `}` au lieu de se terminer par un point-virgule.</span><span class="sxs-lookup"><span data-stu-id="880a1-296">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="880a1-297">Une propriété qui a un accesseur get et un accesseur set est une *propriété en lecture-écriture*, une propriété qui possède uniquement un accesseur get est une *propriété en lecture seule*, et une propriété qui possède uniquement un accesseur set est une *propriété en écriture seule*.</span><span class="sxs-lookup"><span data-stu-id="880a1-297">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="880a1-298">Un accesseur get correspond à une méthode sans paramètre avec une valeur de retour du type de la propriété.</span><span class="sxs-lookup"><span data-stu-id="880a1-298">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="880a1-299">Sauf en tant que cible d’une assignation, lorsqu’une propriété est référencée dans une expression, l’accesseur get de la propriété est appelé pour calculer la valeur de la propriété.</span><span class="sxs-lookup"><span data-stu-id="880a1-299">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="880a1-300">Un accesseur set correspond à une méthode avec un paramètre unique nommé valeur et aucun type de retour.</span><span class="sxs-lookup"><span data-stu-id="880a1-300">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="880a1-301">Lorsqu’une propriété est référencée en tant que cible d’une assignation ou qu’opérande de ++ ou --, l’accesseur set est appelé avec un argument qui fournit la nouvelle valeur.</span><span class="sxs-lookup"><span data-stu-id="880a1-301">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="880a1-302">La classe `List<T>` déclare deux propriétés, Count et Capacity, qui sont en lecture seule et en lecture-écriture, respectivement.</span><span class="sxs-lookup"><span data-stu-id="880a1-302">The `List<T>` class declares two properties, Count and Capacity, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="880a1-303">Voici un exemple d’utilisation de ces propriétés.</span><span class="sxs-lookup"><span data-stu-id="880a1-303">The following is an example of use of these properties.</span></span>

[!code-csharp[ListExample2](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]

<span data-ttu-id="880a1-304">C# prend en charge les propriétés d’instance et les propriétés statiques, similaires aux champs et aux méthodes.</span><span class="sxs-lookup"><span data-stu-id="880a1-304">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="880a1-305">Les propriétés statiques sont déclarées avec le modificateur static, et les propriétés d’instance sont déclarées sans.</span><span class="sxs-lookup"><span data-stu-id="880a1-305">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="880a1-306">Le ou les accesseurs d’une propriété peuvent être virtuels.</span><span class="sxs-lookup"><span data-stu-id="880a1-306">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="880a1-307">Lorsqu’une déclaration de propriété inclut un modificateur `virtual`, `abstract` ou `override`, elle s’applique aux accesseurs de la propriété.</span><span class="sxs-lookup"><span data-stu-id="880a1-307">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="880a1-308">Indexeurs</span><span class="sxs-lookup"><span data-stu-id="880a1-308">Indexers</span></span>

<span data-ttu-id="880a1-309">Un *indexeur* est un membre qui permet l’indexation des objets de la même façon en tant que tableau.</span><span class="sxs-lookup"><span data-stu-id="880a1-309">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="880a1-310">Un indexeur est déclaré comme une propriété, sauf que le nom du membre est suivi d’une liste de paramètres entre les délimiteurs `[` et `]`.</span><span class="sxs-lookup"><span data-stu-id="880a1-310">An indexer is declared like a property except that the name of the member is this followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="880a1-311">Les paramètres sont disponibles dans le ou les accesseurs de l’indexeur.</span><span class="sxs-lookup"><span data-stu-id="880a1-311">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="880a1-312">Similaires aux propriétés, les indexeurs peuvent être en lecture-écriture, en lecture seule et en écriture seule, et les accesseurs d’un indexeur peuvent être virtuels.</span><span class="sxs-lookup"><span data-stu-id="880a1-312">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="880a1-313">La classe `List` déclare un indexeur en lecture-écriture unique qui prend un paramètre `int`.</span><span class="sxs-lookup"><span data-stu-id="880a1-313">The `List` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="880a1-314">L’indexeur rend possible l’indexation des instances `List` avec des valeurs `int`.</span><span class="sxs-lookup"><span data-stu-id="880a1-314">The indexer makes it possible to index `List` instances with `int` values.</span></span> <span data-ttu-id="880a1-315">Exemple :</span><span class="sxs-lookup"><span data-stu-id="880a1-315">For example:</span></span>

[!code-csharp[ListExample3](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]

<span data-ttu-id="880a1-316">Les indexeurs peuvent être surchargés, ce qui signifie qu’une classe peut déclarer plusieurs indexeurs tant que le nombre ou les types de leurs paramètres diffèrent.</span><span class="sxs-lookup"><span data-stu-id="880a1-316">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="880a1-317">Événements</span><span class="sxs-lookup"><span data-stu-id="880a1-317">Events</span></span>

<span data-ttu-id="880a1-318">Un *événement* est un membre qui permet à une classe ou un objet de fournir des notifications.</span><span class="sxs-lookup"><span data-stu-id="880a1-318">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="880a1-319">Un événement est déclaré comme un champ, sauf que la déclaration inclut un mot-clé d’événement et que le type doit être un type délégué.</span><span class="sxs-lookup"><span data-stu-id="880a1-319">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="880a1-320">Dans une classe qui déclare un membre d’événement, l’événement se comporte comme un champ d’un type délégué (à condition que l’événement n’est pas abstrait et ne déclare pas d’accesseurs).</span><span class="sxs-lookup"><span data-stu-id="880a1-320">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event is not abstract and does not declare accessors).</span></span> <span data-ttu-id="880a1-321">Le champ stocke une référence à un délégué qui représente les gestionnaires d’événements qui ont été ajoutés à l’événement.</span><span class="sxs-lookup"><span data-stu-id="880a1-321">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="880a1-322">Si aucun gestionnaire d’événements n’est présent, le champ est `null`.</span><span class="sxs-lookup"><span data-stu-id="880a1-322">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="880a1-323">La classe `List<T>` déclare un membre d’événement unique appelé `Changed`, qui indique qu’un nouvel élément a été ajouté à la liste.</span><span class="sxs-lookup"><span data-stu-id="880a1-323">The `List<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="880a1-324">L’événement Changed est déclenché par la méthode virtuelle `OnChanged`, qui vérifie si l’événement est `null` (ce qui signifie qu’aucun gestionnaire n’est présent).</span><span class="sxs-lookup"><span data-stu-id="880a1-324">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="880a1-325">La notion de déclenchement d’un événement est équivalente à l’appel de délégué représenté par l’événement. Par conséquent, il n’existe aucune construction de langage particulière pour déclencher des événements.</span><span class="sxs-lookup"><span data-stu-id="880a1-325">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="880a1-326">Les clients réagissent aux événements via les *gestionnaires d’événements*.</span><span class="sxs-lookup"><span data-stu-id="880a1-326">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="880a1-327">Les gestionnaires d’événements sont joints à l’aide de l’opérateur `+=` et supprimés à l’aide de l’opérateur `-=`.</span><span class="sxs-lookup"><span data-stu-id="880a1-327">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="880a1-328">L'exemple suivant joint un gestionnaire d'événements à l'événement `Changed` d’un `List<string>`.</span><span class="sxs-lookup"><span data-stu-id="880a1-328">The following example attaches an event handler to the `Changed` event of a `List<string>`.</span></span>

[!code-csharp[EventExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]

<span data-ttu-id="880a1-329">Pour les scénarios avancés où le contrôle du stockage sous-jacent d’un événement est souhaité, une déclaration d’événement peut fournir explicitement des accesseurs `add` et `remove`, qui sont plutôt similaires à l’accesseur `set` d’une propriété.</span><span class="sxs-lookup"><span data-stu-id="880a1-329">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are somewhat similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="880a1-330">Opérateurs</span><span class="sxs-lookup"><span data-stu-id="880a1-330">Operators</span></span>

<span data-ttu-id="880a1-331">Un *opérateur* est un membre qui définit la signification de l’application d’un opérateur d’expression particulière aux instances d’une classe.</span><span class="sxs-lookup"><span data-stu-id="880a1-331">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="880a1-332">Trois types d’opérateurs peuvent être définis : les opérateurs unaires, les opérateurs binaires et les opérateurs de conversion.</span><span class="sxs-lookup"><span data-stu-id="880a1-332">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="880a1-333">Tous les opérateurs doivent être déclarés comme `public` et `static`.</span><span class="sxs-lookup"><span data-stu-id="880a1-333">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="880a1-334">La classe `List<T>` déclare deux opérateurs, `operator ==` et `operator !=`, et donne donc une nouvelle signification aux expressions qui appliquent ces opérateurs aux instances `List`.</span><span class="sxs-lookup"><span data-stu-id="880a1-334">The `List<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `List` instances.</span></span> <span data-ttu-id="880a1-335">Plus précisément, les opérateurs définissent l’égalité de deux instances `List<T>` comme la comparaison de chacun des objets contenus à l’aide de leurs méthodes Equals.</span><span class="sxs-lookup"><span data-stu-id="880a1-335">Specifically, the operators define equality of two `List<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="880a1-336">L’exemple suivant utilise l’opérateur `==` pour comparer deux instances de `List<int>`.</span><span class="sxs-lookup"><span data-stu-id="880a1-336">The following example uses the `==` operator to compare two `List<int>` instances.</span></span>

[!code-csharp[OperatorExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]

<span data-ttu-id="880a1-337">La première `Console.WriteLine` génère `True`, car les deux listes contiennent le même nombre d’objets avec les mêmes valeurs dans le même ordre.</span><span class="sxs-lookup"><span data-stu-id="880a1-337">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="880a1-338">Si `List<T>` n’avait pas défini `operator ==`, la première `Console.WriteLine` aurait affiché `False`, car `a` et `b` référencent des instances `List<int>` différentes.</span><span class="sxs-lookup"><span data-stu-id="880a1-338">Had `List<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `List<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="880a1-339">Finaliseurs</span><span class="sxs-lookup"><span data-stu-id="880a1-339">Finalizers</span></span>

<span data-ttu-id="880a1-340">Un *finaliseur* est un membre qui implémente les actions requises pour finaliser une instance d’une classe.</span><span class="sxs-lookup"><span data-stu-id="880a1-340">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="880a1-341">Les finaliseurs ne peuvent pas avoir de paramètres, ils ne peuvent pas avoir de modificateurs d’accessibilité et ils ne peuvent pas être appelés explicitement.</span><span class="sxs-lookup"><span data-stu-id="880a1-341">Finalizers cannot have parameters, they cannot have accessibility modifiers, and they cannot be invoked explicitly.</span></span> <span data-ttu-id="880a1-342">Le finaliseur pour une instance est appelé automatiquement lors du nettoyage de la mémoire (garbage collection).</span><span class="sxs-lookup"><span data-stu-id="880a1-342">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="880a1-343">Le récupérateur de mémoire est libre de déterminer quand collecter des objets et exécuter des finaliseurs.</span><span class="sxs-lookup"><span data-stu-id="880a1-343">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="880a1-344">Plus précisément, le timing des appels du finaliseur n’est pas déterministe, et les finaliseurs ne peuvent être exécutés sur n’importe quel thread.</span><span class="sxs-lookup"><span data-stu-id="880a1-344">Specifically, the timing of finalizer invocations is not deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="880a1-345">Pour ces raisons et d’autres, les classes doivent implémenter des finaliseurs uniquement lorsqu’aucune des autres solutions n’est envisageable.</span><span class="sxs-lookup"><span data-stu-id="880a1-345">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="880a1-346">L’instruction `using` fournit une meilleure approche pour la destruction d’objets.</span><span class="sxs-lookup"><span data-stu-id="880a1-346">The `using` statement provides a better approach to object destruction.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="880a1-347">[Précédent](statements.md)
[Suivant](structs.md)</span><span class="sxs-lookup"><span data-stu-id="880a1-347">[Previous](statements.md)
[Next](structs.md)</span></span>
