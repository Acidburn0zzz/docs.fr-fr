---
title: "Explication des arborescences d’expressions"
description: "En savoir plus sur les arborescences d’expressions et leur utilité dans la conversion d’algorithmes pour une exécution externe et une inspection du code avant son exécution."
keywords: .NET, .NET Core
author: BillWagner
ms.author: wiwagn
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: 1de856a139ac7a6dee25f1dae54924e33f14a33b
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/18/2017
---
# <a name="expression-trees-explained"></a><span data-ttu-id="9fbe1-104">Explication des arborescences d’expressions</span><span class="sxs-lookup"><span data-stu-id="9fbe1-104">Expression Trees Explained</span></span>

[<span data-ttu-id="9fbe1-105">Précédent -- Vue d’ensemble</span><span class="sxs-lookup"><span data-stu-id="9fbe1-105">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="9fbe1-106">Les arborescences d’expressions sont des structures de données qui définissent du code.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-106">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="9fbe1-107">Elles sont basées sur les mêmes structures que celles utilisées par un compilateur pour analyser du code et générer la sortie compilée.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-107">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="9fbe1-108">Lors de la lecture de ce didacticiel, vous remarquerez qu’il existe certaines similitudes entre les arborescences d’expressions et les types utilisés dans les API Roslyn pour générer des [Analyzers et CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span><span class="sxs-lookup"><span data-stu-id="9fbe1-108">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="9fbe1-109">(Analyzers et CodeFixes sont des packages NuGet qui effectuent une analyse statique sur le code et peuvent suggérer des corrections à un développeur.) Les concepts sont similaires et le résultat final est une structure de données qui permet l’examen du code source de manière explicite.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-109">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="9fbe1-110">Toutefois, les arborescences d’expressions sont basées sur un ensemble de classes et d’API totalement différent des API Roslyn.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-110">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>
    
<span data-ttu-id="9fbe1-111">Examinons un exemple simple.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-111">Let's look at a simple example.</span></span>
<span data-ttu-id="9fbe1-112">Voici une ligne de code :</span><span class="sxs-lookup"><span data-stu-id="9fbe1-112">Here's a line of code:</span></span>
```csharp
var sum = 1 + 2;
```
<span data-ttu-id="9fbe1-113">Si vous analysez ceci comme une arborescence d’expressions, l’arborescence contient plusieurs nœuds.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-113">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="9fbe1-114">Le nœud extérieur est une instruction de déclaration de variable avec attribution (`var sum = 1 + 2;`). Ce nœud extérieur contient plusieurs nœuds enfants : une déclaration de variable, un opérateur d’assignation et une expression qui représente la partie à droite du signe égal.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-114">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="9fbe1-115">Cette expression est sous-divisée en expressions qui représentent l’opération d’addition et les opérandes gauche et droit de l’addition.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-115">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="9fbe1-116">Penchons-nous un peu plus sur les expressions qui composent la partie à droite du signe égal.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-116">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="9fbe1-117">L’expression est `1 + 2`.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-117">The expression is `1 + 2`.</span></span> <span data-ttu-id="9fbe1-118">Il s’agit d’une expression binaire.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-118">That's a binary expression.</span></span> <span data-ttu-id="9fbe1-119">Plus spécifiquement, il s’agit d’une expression d’addition binaire.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-119">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="9fbe1-120">Une expression d’addition binaire a deux enfants, représentant les nœuds gauche et droit de l’expression d’addition.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-120">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="9fbe1-121">Ici, les deux nœuds sont des expressions constantes : l’opérande gauche est la valeur `1`, et l’opérande droit est la valeur `2`.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-121">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="9fbe1-122">Visuellement, l’instruction entière est une arborescence. Vous pouvez partir du nœud racine et accéder à chaque nœud dans l’arborescence pour voir le code qui compose l’instruction :</span><span class="sxs-lookup"><span data-stu-id="9fbe1-122">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="9fbe1-123">Instruction de déclaration de variable avec attribution (`var sum = 1 + 2;`)</span><span class="sxs-lookup"><span data-stu-id="9fbe1-123">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
    * <span data-ttu-id="9fbe1-124">Déclaration de type de variable implicite (`var sum`)</span><span class="sxs-lookup"><span data-stu-id="9fbe1-124">Implicit variable type declaration (`var sum`)</span></span>
        - <span data-ttu-id="9fbe1-125">Mot clé var implicite (`var`)</span><span class="sxs-lookup"><span data-stu-id="9fbe1-125">Implicit var keyword (`var`)</span></span>
        - <span data-ttu-id="9fbe1-126">Déclaration de nom de variable (`sum`)</span><span class="sxs-lookup"><span data-stu-id="9fbe1-126">Variable name declaration (`sum`)</span></span>
    * <span data-ttu-id="9fbe1-127">Opérateur d’assignation (`=`)</span><span class="sxs-lookup"><span data-stu-id="9fbe1-127">Assignment operator (`=`)</span></span>
    * <span data-ttu-id="9fbe1-128">Expression d’addition binaire (`1 + 2`)</span><span class="sxs-lookup"><span data-stu-id="9fbe1-128">Binary addition expression (`1 + 2`)</span></span>
        - <span data-ttu-id="9fbe1-129">Opérande gauche (`1`)</span><span class="sxs-lookup"><span data-stu-id="9fbe1-129">Left operand (`1`)</span></span>
        - <span data-ttu-id="9fbe1-130">Opérateur d’addition (`+`)</span><span class="sxs-lookup"><span data-stu-id="9fbe1-130">Addition operator (`+`)</span></span>
        - <span data-ttu-id="9fbe1-131">Opérande droit (`2`)</span><span class="sxs-lookup"><span data-stu-id="9fbe1-131">Right operand (`2`)</span></span>

<span data-ttu-id="9fbe1-132">Cela peut sembler compliqué, mais c’est très puissant.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-132">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="9fbe1-133">Suivant le même processus, vous pouvez décomposer des expressions beaucoup plus complexes.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-133">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="9fbe1-134">Examinons cette expression :</span><span class="sxs-lookup"><span data-stu-id="9fbe1-134">Consider this expression:</span></span>
```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="9fbe1-135">L’expression ci-dessus est aussi une déclaration de variable avec une assignation.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-135">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="9fbe1-136">La partie droite de l’assignation est une arborescence beaucoup plus complexe.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-136">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="9fbe1-137">Je ne vais pas décomposer cette expression, mais réfléchissez à ce que pourraient être les différents nœuds.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-137">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="9fbe1-138">Il y a des appels de méthode utilisant l’objet actif comme destinataire, un qui a un récepteur `this` explicite, un autre qui n’en a pas.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-138">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="9fbe1-139">Il y a des appels de méthode utilisant d’autres objets récepteurs, et des arguments constants de différents types.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-139">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="9fbe1-140">Pour finir, il y a un opérateur d’addition binaire.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-140">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="9fbe1-141">En fonction du type de retour de `SecretSauceFunction()` ou `MoreSecretSauce()`, cet opérateur d’addition binaire peut être un appel de méthode à un opérateur d’addition substitué, résolu en un appel de méthode statique à l’opérateur d’addition binaire défini pour une classe.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-141">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="9fbe1-142">Malgré cette complexité apparente, l’expression ci-dessus crée une arborescence qui peut être parcourue aussi facilement que le premier exemple.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-142">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="9fbe1-143">Vous pouvez traverser les nœuds enfants successifs pour rechercher des nœuds terminaux dans l’expression.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-143">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="9fbe1-144">Les nœuds parents ont des références à leurs enfants, et chaque nœud a une propriété qui décrit le genre de nœud dont il s’agit.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-144">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="9fbe1-145">La structure d’une arborescence d’expressions est très cohérente.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-145">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="9fbe1-146">Une fois que vous maîtrisez les principes de base, vous pouvez comprendre le code le plus complexe quand il est représenté sous forme d’arborescence d’expressions.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-146">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="9fbe1-147">L’élégance dans la structure de données explique comment le compilateur C# peut analyser les programmes C# les plus complexes et créer une sortie appropriée à partir de ce code source complexe.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-147">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="9fbe1-148">Une fois que vous vous serez familiarisé avec la structure des arborescences d’expressions, vous constaterez que les connaissances acquises vous permettront de travailler rapidement avec de nombreux scénarios avancés.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-148">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="9fbe1-149">Les arborescences d’expressions offrent une puissance incroyable.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-149">There is incredible power to expression trees.</span></span>

<span data-ttu-id="9fbe1-150">Outre la conversion d’algorithmes à exécuter dans d’autres environnements, vous pouvez utiliser des arborescences d’expressions pour simplifier l’écriture d’algorithmes qui inspectent du code avant de l’exécuter.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-150">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="9fbe1-151">Vous pouvez écrire une méthode dont les arguments sont des expressions, puis examiner ces expressions avant d’exécuter le code.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-151">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="9fbe1-152">L’arborescence d’expressions est une représentation complète du code : vous pouvez voir les valeurs de n’importe quelle sous-expression.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-152">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="9fbe1-153">Vous pouvez voir les noms des méthodes et des propriétés.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-153">You can see method and property names.</span></span> <span data-ttu-id="9fbe1-154">Vous pouvez voir la valeur de n’importe quelle expression constante.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-154">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="9fbe1-155">Vous pouvez également convertir une arborescence d’expressions en délégué exécutable et exécuter le code.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-155">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="9fbe1-156">Les API d’arborescences d’expressions vous permettent de créer des arborescences qui représentent presque n’importe quelle construction de code valide.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-156">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="9fbe1-157">Toutefois, pour simplifier les choses au maximum, certains idiomes C# ne peuvent pas être créés dans une arborescence d’expressions.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-157">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="9fbe1-158">C’est le cas des expressions asynchrones (utilisant les mots clés `async` et `await`).</span><span class="sxs-lookup"><span data-stu-id="9fbe1-158">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="9fbe1-159">Si vous avez besoin d’algorithmes asynchrones, vous devez manipuler directement les objets `Task` plutôt que de vous fier à la prise en charge du compilateur.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-159">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="9fbe1-160">C’est aussi le cas pour la création des boucles.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-160">Another is in creating loops.</span></span> <span data-ttu-id="9fbe1-161">En général, vous les créez à l’aide de boucles `for`, `foreach`, `while` ou `do`.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-161">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="9fbe1-162">Comme vous le verrez [plus loin dans cette série](expression-trees-building.md), les API d’arborescences d’expressions prennent en charge une expression de boucle unique, avec des expressions `break` et `continue` qui contrôlent la répétition de la boucle.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-162">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="9fbe1-163">La seule chose que vous ne pouvez pas faire est de modifier une arborescence d’expressions.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-163">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="9fbe1-164">Les arborescences d’expressions sont des structures de données immuables.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-164">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="9fbe1-165">Si vous souhaitez muter (changer) une expression de l’arborescence, vous devez créer une nouvelle arborescence qui est une copie de l’original, mais avec les modifications souhaitées.</span><span class="sxs-lookup"><span data-stu-id="9fbe1-165">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span> 

[<span data-ttu-id="9fbe1-166">Suivant -- Types de frameworks prenant en charge les arborescences d’expressions</span><span class="sxs-lookup"><span data-stu-id="9fbe1-166">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)
