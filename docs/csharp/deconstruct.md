---
title: "Déconstruction de tuples et d’autres types"
description: "Découvrez comment déconstruire des tuples et d’autres types."
keywords: .NET,.NET Core,C#
author: rpetrusha
ms-author: ronpet
ms.date: 07/18/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 0b0c4b0f-4a47-4f66-9b8e-f5c63b195960
ms.translationtype: HT
ms.sourcegitcommit: 863940512f33568ee10569da4712e7e646bc3ba7
ms.openlocfilehash: ad0ed6568da073683545727ef47f6a223942c8d6
ms.contentlocale: fr-fr
ms.lasthandoff: 08/12/2017

---
# <a name="deconstructing-tuples-and-other-types"></a><span data-ttu-id="9d6a6-104">Déconstruction de tuples et d’autres types</span><span class="sxs-lookup"><span data-stu-id="9d6a6-104">Deconstructing tuples and other types</span></span> #

<span data-ttu-id="9d6a6-105">Un tuple offre un moyen léger de récupérer plusieurs valeurs à partir d’un appel de méthode.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-105">A tuple provides a light-weight way to retrieve multiple values from a method call.</span></span> <span data-ttu-id="9d6a6-106">Cependant, une fois que vous récupérez le tuple, vous devez gérer ses éléments individuels.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-106">But once you retrieve the tuple, you have to handle its individual elements.</span></span> <span data-ttu-id="9d6a6-107">Cette gestion élément par élément est assez fastidieuse, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-107">Doing this on an element-by-element basis is cumbersome, as the following example shows.</span></span> <span data-ttu-id="9d6a6-108">La méthode `QueryCityData` retourne un tuple de 3 éléments, et chacun de ses éléments est affecté à une variable dans une opération distincte.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-108">The `QueryCityData` method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation.</span></span>

<span data-ttu-id="9d6a6-109">[!code-csharp[WithoutDeconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]</span><span class="sxs-lookup"><span data-stu-id="9d6a6-109">[!code-csharp[WithoutDeconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]</span></span>

<span data-ttu-id="9d6a6-110">La récupération de plusieurs valeurs de champs et de propriétés d’un objet peut également être assez fastidieuse : vous devez affecter une valeur de champ ou de propriété à une variable membre par membre.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-110">Retrieving multiple field and property values from an object can be equally cumbersome: you have to assign a field or property value to a variable on a member-by-member basis.</span></span> 

<span data-ttu-id="9d6a6-111">À compter de C# 7, vous pouvez récupérer plusieurs éléments d’un tuple ou récupérer plusieurs valeurs de champ et de propriété, ainsi que des valeurs calculées, à partir d’un objet en une seule opération de *déconstruction*.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-111">Starting with C# 7, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single *deconstruct* operation.</span></span> <span data-ttu-id="9d6a6-112">Quand vous déconstruisez un tuple, vous affectez ses éléments à des variables individuelles.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-112">When you deconstruct a tuple, you assign its elements to individual variables.</span></span> <span data-ttu-id="9d6a6-113">Quand vous déconstruisez un objet, vous affectez des valeurs sélectionnées à des variables individuelles.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-113">When you deconstruct an object, you assign selected values to individual variables.</span></span> 

## <a name="deconstructing-a-tuple"></a><span data-ttu-id="9d6a6-114">Déconstruction d’un tuple</span><span class="sxs-lookup"><span data-stu-id="9d6a6-114">Deconstructing a tuple</span></span>

<span data-ttu-id="9d6a6-115">Des fonctionnalités C# intégrées prennent en charge la déconstruction des tuples, ce qui vous permet de décomposer tous les éléments d’un tuple en une seule opération.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-115">C# features built-in support for deconstructing tuples, which lets you unpackage all the items in a tuple in a single operation.</span></span> <span data-ttu-id="9d6a6-116">La syntaxe générale de déconstruction d’un tuple est similaire à la syntaxe qui permet d’en définir un : vous placez les variables auxquelles chaque élément doit être affecté entre des parenthèses, dans la partie gauche d’une instruction d’affectation.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-116">The general syntax for deconstructing a tuple is similar to the syntax for defining one: you enclose the variables to which each element is to be assigned in parentheses in the left side of an assignment statement.</span></span> <span data-ttu-id="9d6a6-117">Par exemple, l’instruction suivante affecte les éléments d’un tuple de 4 éléments à quatre variables distinctes :</span><span class="sxs-lookup"><span data-stu-id="9d6a6-117">For example, the following statement assigns the elements of a 4-tuple to four separate variables:</span></span>

```csharp
var (name, address, city, zip) = contact.GetAddressInfo();
```

<span data-ttu-id="9d6a6-118">Il existe deux façons de déconstruire un tuple :</span><span class="sxs-lookup"><span data-stu-id="9d6a6-118">There are two ways to deconstruct a tuple:</span></span>

- <span data-ttu-id="9d6a6-119">Vous pouvez déclarer explicitement le type de chaque champ entre des parenthèses.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-119">You can explicitly declare the type of each field inside parentheses.</span></span> <span data-ttu-id="9d6a6-120">L’exemple suivant utilise cette approche pour déconstruire un tuple de 3 éléments retourné par la méthode `QueryCityData`.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-120">The following example uses this approach to deconstruct the 3-tuple returned by the `QueryCityData` method.</span></span>

    <span data-ttu-id="9d6a6-121">[!code-csharp[Déconstruction explicite](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]</span><span class="sxs-lookup"><span data-stu-id="9d6a6-121">[!code-csharp[Deconstruction-Explicit](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]</span></span>

- <span data-ttu-id="9d6a6-122">Vous pouvez utiliser le mot clé `var` pour que C# infère le type de chaque variable.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-122">You can use the `var` keyword so that C# infers the type of each variable.</span></span> <span data-ttu-id="9d6a6-123">Vous placez le mot clé `var` en dehors des parenthèses.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-123">You place the `var` keyword outside of the parentheses.</span></span> <span data-ttu-id="9d6a6-124">L’exemple suivant utilise l’inférence de type lors de la déconstruction du tuple de 3 éléments retourné par la méthode `QueryCityData`.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-124">The following example uses type inference when deconstructing the 3-tuple returned by the `QueryCityData` method.</span></span>
 
    <span data-ttu-id="9d6a6-125">[!code-csharp[Deconstruction-Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]</span><span class="sxs-lookup"><span data-stu-id="9d6a6-125">[!code-csharp[Deconstruction-Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]</span></span>

    <span data-ttu-id="9d6a6-126">Vous pouvez aussi utiliser le mot clé `var` individuellement avec tout ou partie des déclarations de variables à l’intérieur des parenthèses.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-126">You can also use the `var` keyword individually with any or all of the variable declarations inside the parentheses.</span></span> 

    <span data-ttu-id="9d6a6-127">[!code-csharp[Deconstruction-Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]</span><span class="sxs-lookup"><span data-stu-id="9d6a6-127">[!code-csharp[Deconstruction-Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]</span></span>

    <span data-ttu-id="9d6a6-128">Ceci est assez fastidieux et n’est pas recommandé.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-128">This is cumbersome and is not recommended.</span></span>

<span data-ttu-id="9d6a6-129">Notez que vous ne pouvez pas spécifier un type spécifique en dehors des parenthèses, même si tous les champs du tuple ont le même type.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-129">Note that you cannot specify a specific type outside the parentheses even if every field in the tuple has the same type.</span></span> <span data-ttu-id="9d6a6-130">Cela génère l’erreur du compilateur CS8136, « La déconstruction de 'var (...)' form interdit un type spécifique pour 'var'.».</span><span class="sxs-lookup"><span data-stu-id="9d6a6-130">This generates compiler error CS8136, "Deconstruction 'var (...)' form disallows a specific type for 'var'.".</span></span>

<span data-ttu-id="9d6a6-131">Notez que vous devez également affecter chaque élément du tuple à une variable.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-131">Note that you must also assign each element of the tuple to a variable.</span></span> <span data-ttu-id="9d6a6-132">Si vous omettez des éléments, le compilateur génère l’erreur CS8132, « Impossible de déconstruire un tuple de « x » éléments en « y » variables ».</span><span class="sxs-lookup"><span data-stu-id="9d6a6-132">If you omit any elements, the compiler generates error CS8132, "Cannot deconstruct a tuple of 'x' elements into 'y' variables."</span></span>

## <a name="deconstructing-tuple-elements-with-discards"></a><span data-ttu-id="9d6a6-133">Déconstruction d’éléments d’un tuple en ignorant des éléments</span><span class="sxs-lookup"><span data-stu-id="9d6a6-133">Deconstructing tuple elements with discards</span></span>

<span data-ttu-id="9d6a6-134">Souvent, lors de la déconstruction d’un tuple, vous êtes intéressé seulement par les valeurs de certains éléments.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-134">Often when deconstructing a tuple, you're interested in the values of only some elements.</span></span> <span data-ttu-id="9d6a6-135">À compter de C# 7, vous pouvez tirer parti de la prise en charge des *éléments ignorés*, qui sont des variables en écriture seule dont vous avez choisi d’ignorer les valeurs.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-135">Starting with C# 7, you can take advantage of C#'s support for *discards*, which are write-only variables whose values you've chosen to ignore.</span></span> <span data-ttu-id="9d6a6-136">Un élément ignoré est désigné par un caractère de soulignement (« \_ ») dans une affectation.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-136">A discard is designated by an underscore character ("\_") in an assignment.</span></span> <span data-ttu-id="9d6a6-137">Vous pouvez ignorer autant de valeurs que vous le souhaitez ; pour représenter toutes les valeurs, utilisez l’élément ignoré unique, `_`.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-137">You can discard as many values as you like; all are represented by the single discard, `_`.</span></span>

<span data-ttu-id="9d6a6-138">L’exemple suivant illustre l’utilisation de tuples avec des éléments ignorés.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-138">The following example illustrates the use of tuples with discards.</span></span> <span data-ttu-id="9d6a6-139">La méthode `QueryCityDataForYears` retourne un tuple de 6 éléments avec le nom d’une ville, sa région, une année, la population de la ville pour cette année, une seconde année et la population de la ville pour cette seconde année.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-139">The `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="9d6a6-140">L’exemple montre la différence de population entre ces deux années.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-140">The example shows the change in population between those two years.</span></span> <span data-ttu-id="9d6a6-141">Parmi les données disponibles dans le tuple, nous ne sommes pas intéressés par la région de la ville, et nous connaissons le nom de la ville et les deux dates au moment du design.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-141">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="9d6a6-142">Par conséquent, nous sommes intéressés seulement par les deux valeurs de la population stockées dans le tuple et nous pouvons gérer ses valeurs restantes comme éléments ignorés.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-142">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

<span data-ttu-id="9d6a6-143">[!code-csharp[Tuple avec des éléments ignorés](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]</span><span class="sxs-lookup"><span data-stu-id="9d6a6-143">[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]</span></span>

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="9d6a6-144">Déconstruction de types définis par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="9d6a6-144">Deconstructing user-defined types</span></span>

<span data-ttu-id="9d6a6-145">Les types autres que les tuples n’offrent pas de prise en charge intégrée pour les éléments ignorés.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-145">Non-tuple types do not offer built-in support for discards.</span></span> <span data-ttu-id="9d6a6-146">Cependant, en tant que créateur d’une classe, d’un struct ou d’une interface, vous pouvez permettre la déconstruction du type en implémentant une ou plusieurs méthodes `Deconstruct`.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-146">However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more `Deconstruct` methods.</span></span> <span data-ttu-id="9d6a6-147">La méthode retourne void, et chaque valeur à déconstruire est indiquée par un paramètre [out](language-reference/keywords/out-parameter-modifier.md) dans la signature de la méthode.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-147">The method returns void, and each value to be deconstructed is indicated by an [out](language-reference/keywords/out-parameter-modifier.md) parameter in the method signature.</span></span> <span data-ttu-id="9d6a6-148">Par exemple, la méthode `Deconstruct` suivante d’une classe `Person` retourne le prénom, le deuxième prénom et le nom :</span><span class="sxs-lookup"><span data-stu-id="9d6a6-148">For example, the following `Deconstruct` method of a `Person` class returns the first, middle, and last name:</span></span>

<span data-ttu-id="9d6a6-149">[!code-csharp[Déconstruction au niveau d’une classe](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]</span><span class="sxs-lookup"><span data-stu-id="9d6a6-149">[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]</span></span>

<span data-ttu-id="9d6a6-150">Vous pouvez alors déconstruire une instance de la classe `Person` nommée `p` avec une affectation comme celle-ci :</span><span class="sxs-lookup"><span data-stu-id="9d6a6-150">You can then deconstruct an instance of the `Person` class named `p` with an assignment like the following:</span></span>

<span data-ttu-id="9d6a6-151">[!code-csharp[Déconstruction au niveau d’une classe](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]</span><span class="sxs-lookup"><span data-stu-id="9d6a6-151">[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]</span></span>

<span data-ttu-id="9d6a6-152">L’exemple suivant surcharge la méthode `Deconstruct` de façon retourner différentes combinaisons des propriétés d’un objet `Person`.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-152">The following example overloads the `Deconstruct` method to return various combinations of properties of a `Person` object.</span></span> <span data-ttu-id="9d6a6-153">Les différentes surcharges retournent :</span><span class="sxs-lookup"><span data-stu-id="9d6a6-153">Individual overloads return:</span></span>

- <span data-ttu-id="9d6a6-154">Un prénom et un nom.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-154">A first and last name.</span></span>
- <span data-ttu-id="9d6a6-155">Un prénom, un nom et un deuxième nom.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-155">A first, last, and middle name.</span></span>
- <span data-ttu-id="9d6a6-156">Un prénom, un nom, un nom de ville et un nom d’état.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-156">A first name, a last name, a city name, and a state name.</span></span>

<span data-ttu-id="9d6a6-157">[!code-csharp[Déconstruction au niveau d’une classe](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]</span><span class="sxs-lookup"><span data-stu-id="9d6a6-157">[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]</span></span>

<span data-ttu-id="9d6a6-158">Comme vous pouvez surcharger la méthode `Deconstruct` de façon à refléter les groupes de données qui sont souvent extraits d’un objet, vous devez être attentif à définir des méthodes `Deconstruct` avec des signatures qui les distinguent et ne sont pas ambiguës.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-158">Because you can overload the `Deconstruct` method to reflect groups of data that are commonly extracted from an object, you should be careful to define `Deconstruct` methods with signatures that are distinctive and unambiguous.</span></span> <span data-ttu-id="9d6a6-159">Plusieurs méthodes `Deconstruct` ayant même nombre de paramètres `out`, ou le même nombre et le même type de paramètres `out` dans un ordre différent, peuvent provoquer de la confusion.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-159">Multiple `Deconstruct` methods that have the same number of `out` parameters or the same number and type of `out` parameters in a different order can cause confusion.</span></span> 

<span data-ttu-id="9d6a6-160">La méthode `Deconstruct` surchargée dans l’exemple suivant montre une source possible de confusion.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-160">The overloaded `Deconstruct` method in the following example illustrates one possible source of confusion.</span></span> <span data-ttu-id="9d6a6-161">La première surcharge retourne le prénom, le deuxième prénom, le nom et l’âge d’un objet `Person`, dans cet ordre.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-161">The first overload returns the first name, middle name, last name, and age of a `Person` object, in that order.</span></span> <span data-ttu-id="9d6a6-162">La seconde surcharge retourne les informations de nom seulement avec le revenu annuel, mais le prénom, le deuxième prénom et le nom sont dans un ordre différent.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-162">The second overload returns name information only along with annual income, but the first, middle, and last name are in a different order.</span></span> <span data-ttu-id="9d6a6-163">Ceci facilite la confusion dans l’ordre des arguments lors de la déconstruction d’une instance de `Person`.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-163">This makes it easy to confuse the order of arguments when deconstructing a `Person` instance.</span></span>

<span data-ttu-id="9d6a6-164">[!code-csharp[Ambiguïté dans la déconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-ambiguous.cs)]</span><span class="sxs-lookup"><span data-stu-id="9d6a6-164">[!code-csharp[Deconstruct-ambiguity](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-ambiguous.cs)]</span></span>

## <a name="deconstructing-a-user-defined-type-with-discards"></a><span data-ttu-id="9d6a6-165">Déconstruction d’un type défini par l’utilisateur avec des éléments ignorés</span><span class="sxs-lookup"><span data-stu-id="9d6a6-165">Deconstructing a user-defined type with discards</span></span>

<span data-ttu-id="9d6a6-166">Tout comme vous le faites avec des [tuples](#deconstructing-tuple-elements-with-discards), vous pouvez utiliser des éléments ignorés pour ignorer des éléments sélectionnés retournés par une méthode `Deconstruct`.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-166">Just as you do with [tuples](#deconstructing-tuple-elements-with-discards), you can use discards to ignore selected items returned by a `Deconstruct` method.</span></span> <span data-ttu-id="9d6a6-167">Chaque élément ignoré est défini par une variable nommée « \_ », et une même opération de déconstruction peut inclure plusieurs éléments ignorés.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-167">Each discard is defined by a variable named "\_", and a single deconstruction operation can include multiple discards.</span></span>

<span data-ttu-id="9d6a6-168">L’exemple suivant déconstruit un objet `Person` en quatre chaînes (le prénom et le nom, la ville et l’état), mais ignore le nom et l’état.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-168">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state) but discards the last name and the state.</span></span>

<span data-ttu-id="9d6a6-169">[!code-csharp[Classe et éléments ignorés](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]</span><span class="sxs-lookup"><span data-stu-id="9d6a6-169">[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]</span></span>

## <a name="deconstructing-a-user-defined-type-with-an-extension-method"></a><span data-ttu-id="9d6a6-170">Déconstruction d’un type défini par l’utilisateur avec une méthode d’extension</span><span class="sxs-lookup"><span data-stu-id="9d6a6-170">Deconstructing a user-defined type with an extension method</span></span>

<span data-ttu-id="9d6a6-171">Si vous n’avez pas créé une classe, un struct ou une interface, vous pouvez néanmoins déconstruire des objets de ce type en implémentant une ou plusieurs `Deconstruct`[méthodes d’extension](programming-guide/classes-and-structs/extension-methods.md) pour retourner les valeurs qui vous intéressent.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-171">If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more `Deconstruct` [extension methods](programming-guide/classes-and-structs/extension-methods.md) to return the values in which you're interested.</span></span> 

<span data-ttu-id="9d6a6-172">L’exemple suivant définit deux méthodes d’extension `Deconstruct` pour la classe <xref:System.Reflection.PropertyInfo?displayProperty=fullName>.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-172">The following example defines two `Deconstruct` extension methods for the <xref:System.Reflection.PropertyInfo?displayProperty=fullName> class.</span></span> <span data-ttu-id="9d6a6-173">La première retourne un ensemble de valeurs qui indique les caractéristiques de la propriété, notamment son type, si elle est statique ou d’instance, si elle est en lecture seule et si elle est indexée.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-173">The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed.</span></span> <span data-ttu-id="9d6a6-174">La seconde indique l’accessibilité de la propriété.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-174">The second indicates the property's accessibility.</span></span> <span data-ttu-id="9d6a6-175">Comme l’accessibilité des accesseurs get et set peut varier, des valeurs booléennes indiquent si la propriété a des accesseurs get et set distincts et, le cas échéant, s’ils ont la même accessibilité.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-175">Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility.</span></span> <span data-ttu-id="9d6a6-176">S’il n’existe qu’un seul accesseur, ou si les deux accesseurs get et set ont la même accessibilité, la variable `access` indique l’accessibilité de la propriété comme un tout.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-176">If there is only one accessor or both the get and the set accessor have the same accessibility, the `access` variable indicates the accessibility of the property as a whole.</span></span> <span data-ttu-id="9d6a6-177">Dans le cas contraire, l’accessibilité des accesseurs get et set est indiquée par les variables `getAccess` et `setAccess`.</span><span class="sxs-lookup"><span data-stu-id="9d6a6-177">Otherwise, the accessibility of the get and set accessors are indicated by the accessaccessibility is indicated by the `getAccess` and `setAccess` variables.</span></span>

<span data-ttu-id="9d6a6-178">[!code-csharp[Déconstruction par extension](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]</span><span class="sxs-lookup"><span data-stu-id="9d6a6-178">[!code-csharp[Extension-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]</span></span>
 
## <a name="see-also"></a><span data-ttu-id="9d6a6-179">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="9d6a6-179">See also</span></span>
<span data-ttu-id="9d6a6-180">[Éléments ignorés](discards.md) </span><span class="sxs-lookup"><span data-stu-id="9d6a6-180">[Discards](discards.md) </span></span>  
[<span data-ttu-id="9d6a6-181">Tuples</span><span class="sxs-lookup"><span data-stu-id="9d6a6-181">Tuples</span></span>](tuples.md)  

