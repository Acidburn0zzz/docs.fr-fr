---
title: "Génériques (F#)"
description: "Découvrez comment utiliser les fonctions F # génériques et types, qui vous permettent d’écrire du code qui fonctionne avec un large éventail de types sans avoir à répéter le code."
keywords: visual f#, f#, programmation fonctionnelle
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: a9f2e2ee-bcb1-4ce3-8531-850aa183040f
ms.openlocfilehash: e7a5712fddf4d372d1ada86927f50e394a59a410
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/18/2017
---
# <a name="generics"></a><span data-ttu-id="66a0d-104">Génériques</span><span class="sxs-lookup"><span data-stu-id="66a0d-104">Generics</span></span>

<span data-ttu-id="66a0d-105">Les valeurs de fonctions, méthodes, propriétés et types d’agrégats F# comme les classes, les enregistrements et les unions discriminées peuvent être *génériques*.</span><span class="sxs-lookup"><span data-stu-id="66a0d-105">F# function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be *generic*.</span></span> <span data-ttu-id="66a0d-106">Les constructions génériques contiennent au moins un paramètre de type généralement fourni par l’utilisateur de la construction générique.</span><span class="sxs-lookup"><span data-stu-id="66a0d-106">Generic constructs contain at least one type parameter, which is usually supplied by the user of the generic construct.</span></span> <span data-ttu-id="66a0d-107">Les types et les fonctions génériques vous permettent d’écrire le code qui fonctionne avec plusieurs types, sans que ce dernier ne soit répété pour chaque type.</span><span class="sxs-lookup"><span data-stu-id="66a0d-107">Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</span></span> <span data-ttu-id="66a0d-108">En F#, il est très simple d’affecter à votre code un caractère générique. En effet, celui-ci est souvent et implicitement déduit pour devenir générique par l’inférence de type et les mécanismes de généralisation automatique du compilateur.</span><span class="sxs-lookup"><span data-stu-id="66a0d-108">Making your code generic can be simple in F#, because often your code is implicitly inferred to be generic by the compiler's type inference and automatic generalization mechanisms.</span></span>


## <a name="syntax"></a><span data-ttu-id="66a0d-109">Syntaxe</span><span class="sxs-lookup"><span data-stu-id="66a0d-109">Syntax</span></span>

```fsharp
// Explicitly generic function.
let function-name<type-parameters> parameter-list =
function-body

// Explicitly generic method.
[ static ] member object-identifer.method-name<type-parameters> parameter-list [ return-type ] =
method-body

// Explicitly generic class, record, interface, structure,
// or discriminated union.
type type-name<type-parameters> type-definition
```

## <a name="remarks"></a><span data-ttu-id="66a0d-110">Remarques</span><span class="sxs-lookup"><span data-stu-id="66a0d-110">Remarks</span></span>
<span data-ttu-id="66a0d-111">La déclaration d’un type ou d’une fonction explicitement générique s’apparente considérablement à celle d’un type ou d’une fonction non générique, sauf pour la spécification (et l’utilisation) des paramètres de type (entre crochets pointus après le nom du type ou de la fonction).</span><span class="sxs-lookup"><span data-stu-id="66a0d-111">The declaration of an explicitly generic function or type is much like that of a non-generic function or type, except for the specification (and use) of the type parameters, in angle brackets after the function or type name.</span></span>

<span data-ttu-id="66a0d-112">Les déclarations sont souvent implicitement génériques.</span><span class="sxs-lookup"><span data-stu-id="66a0d-112">Declarations are often implicitly generic.</span></span> <span data-ttu-id="66a0d-113">Si vous ne spécifiez pas complètement le type de tous les paramètres utilisés pour composer un type ou une fonction, le compilateur tente de déduire le type de chaque paramètre, valeur et variable du code que vous écrivez.</span><span class="sxs-lookup"><span data-stu-id="66a0d-113">If you do not fully specify the type of every parameter that is used to compose a function or type, the compiler attempts to infer the type of each parameter, value, and variable from the code you write.</span></span> <span data-ttu-id="66a0d-114">Pour plus d’informations, consultez [Inférence de type](../type-inference.md).</span><span class="sxs-lookup"><span data-stu-id="66a0d-114">For more information, see [Type Inference](../type-inference.md).</span></span> <span data-ttu-id="66a0d-115">Si le code de votre type ou fonction n’exerce pas de contrainte sur les types de paramètres, le type ou la fonction est implicitement générique.</span><span class="sxs-lookup"><span data-stu-id="66a0d-115">If the code for your type or function does not otherwise constrain the types of parameters, the function or type is implicitly generic.</span></span> <span data-ttu-id="66a0d-116">Le terme « *généralisation automatique* » désigne ce processus.</span><span class="sxs-lookup"><span data-stu-id="66a0d-116">This process is named *automatic generalization*.</span></span> <span data-ttu-id="66a0d-117">La généralisation automatique présente des limites.</span><span class="sxs-lookup"><span data-stu-id="66a0d-117">There are some limits on automatic generalization.</span></span> <span data-ttu-id="66a0d-118">Par exemple, si le compilateur F# ne parvient pas à déduire les types d’une construction générique, il signale une erreur qui fait référence à une restriction appelée « *restriction de valeur* ».</span><span class="sxs-lookup"><span data-stu-id="66a0d-118">For example, if the F# compiler is unable to infer the types for a generic construct, the compiler reports an error that refers to a restriction called the *value restriction*.</span></span> <span data-ttu-id="66a0d-119">Dans ce cas, vous devrez peut-être ajouter des annotations de type.</span><span class="sxs-lookup"><span data-stu-id="66a0d-119">In that case, you may have to add some type annotations.</span></span> <span data-ttu-id="66a0d-120">Pour plus d’informations sur la généralisation automatique et sur la restriction de valeur, ainsi que sur la modification de votre code pour traiter le problème, consultez [Généralisation automatique](automatic-generalization.md).</span><span class="sxs-lookup"><span data-stu-id="66a0d-120">For more information about automatic generalization and the value restriction, and how to change your code to address the problem, see [Automatic Generalization](automatic-generalization.md).</span></span>

<span data-ttu-id="66a0d-121">Dans la syntaxe précédente, *type-parameters* est une liste de paramètres avec la virgule comme séparateur qui représentent des types inconnus, dont chacun commence par un guillemet simple, éventuellement avec une clause de contrainte qui limite encore davantage les types susceptibles d’être utilisés pour ce type de paramètre.</span><span class="sxs-lookup"><span data-stu-id="66a0d-121">In the previous syntax, *type-parameters* is a comma-separated list of parameters that represent unknown types, each of which starts with a single quotation mark, optionally with a constraint clause that further limits what types may be used for that type parameter.</span></span> <span data-ttu-id="66a0d-122">Pour en savoir plus sur la syntaxe concernant les clauses de contraintes de plusieurs genres et obtenir d’autres informations sur les contraintes, consultez [Contraintes](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="66a0d-122">For the syntax for constraint clauses of various kinds and other information about constraints, see [Constraints](constraints.md).</span></span>

<span data-ttu-id="66a0d-123">*type-definition* dans la syntaxe est identique à la définition de type pour un type non générique.</span><span class="sxs-lookup"><span data-stu-id="66a0d-123">The *type-definition* in the syntax is the same as the type definition for a non-generic type.</span></span> <span data-ttu-id="66a0d-124">Cela inclut les paramètres de constructeur pour un type de classe, une clause `as` facultative, le symbole égal, les champs d’enregistrement, la clause `inherit`, les sélections pour une union discriminée, les liaisons `let` et `do`, les définitions de membres et tout autre élément autorisé dans une définition de type non générique.</span><span class="sxs-lookup"><span data-stu-id="66a0d-124">It includes the constructor parameters for a class type, an optional `as` clause, the equal symbol, the record fields, the `inherit` clause, the choices for a discriminated union, `let` and `do` bindings, member definitions, and anything else permitted in a non-generic type definition.</span></span>

<span data-ttu-id="66a0d-125">Les autres éléments de syntaxe sont identiques à ceux de types et de fonctions non génériques.</span><span class="sxs-lookup"><span data-stu-id="66a0d-125">The other syntax elements are the same as those for non-generic functions and types.</span></span> <span data-ttu-id="66a0d-126">Par exemple, *object-identifier* est un identificateur qui représente l’objet conteneur lui-même.</span><span class="sxs-lookup"><span data-stu-id="66a0d-126">For example, *object-identifier* is an identifier that represents the containing object itself.</span></span>

<span data-ttu-id="66a0d-127">Les propriétés, champs et constructeurs ne peuvent pas être plus génériques que le type englobant.</span><span class="sxs-lookup"><span data-stu-id="66a0d-127">Properties, fields, and constructors cannot be more generic than the enclosing type.</span></span> <span data-ttu-id="66a0d-128">De plus, les valeurs d’un module ne peuvent pas être génériques.</span><span class="sxs-lookup"><span data-stu-id="66a0d-128">Also, values in a module cannot be generic.</span></span>


## <a name="implicitly-generic-constructs"></a><span data-ttu-id="66a0d-129">Constructions implicitement génériques</span><span class="sxs-lookup"><span data-stu-id="66a0d-129">Implicitly Generic Constructs</span></span>
<span data-ttu-id="66a0d-130">Quand le compilateur F# déduit les types dans votre code, il traite automatiquement toute fonction susceptible d’être générique en tant que telle.</span><span class="sxs-lookup"><span data-stu-id="66a0d-130">When the F# compiler infers the types in your code, it automatically treats any function that can be generic as generic.</span></span> <span data-ttu-id="66a0d-131">Si vous spécifiez un type explicitement, comme un type de paramètre, cela empêche toute généralisation automatique.</span><span class="sxs-lookup"><span data-stu-id="66a0d-131">If you specify a type explicitly, such as a parameter type, you prevent automatic generalization.</span></span>

<span data-ttu-id="66a0d-132">Dans l’exemple de code suivant, `makeList` est générique, même si ni celui-ci ni ses paramètres ne sont explicitement déclarés comme étant génériques.</span><span class="sxs-lookup"><span data-stu-id="66a0d-132">In the following code example, `makeList` is generic, even though neither it nor its parameters are explicitly declared as generic.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1700.fs)]

<span data-ttu-id="66a0d-133">La signature de la fonction est déduite pour être `'a -> 'a -> 'a list`.</span><span class="sxs-lookup"><span data-stu-id="66a0d-133">The signature of the function is inferred to be `'a -> 'a -> 'a list`.</span></span> <span data-ttu-id="66a0d-134">Dans cet exemple, notez que `a` et `b` sont déduits pour avoir le même type.</span><span class="sxs-lookup"><span data-stu-id="66a0d-134">Note that `a` and `b` in this example are inferred to have the same type.</span></span> <span data-ttu-id="66a0d-135">Cela est dû au fait qu’ils sont regroupés dans une liste et que tous les éléments d’une même liste doivent être du même type.</span><span class="sxs-lookup"><span data-stu-id="66a0d-135">This is because they are included in a list together, and all elements of a list must be of the same type.</span></span>

<span data-ttu-id="66a0d-136">Vous pouvez également affecter un caractère générique à une fonction en utilisant la syntaxe contenant des guillemets simples dans une annotation de type, afin d’indiquer qu’un type de paramètre est un paramètre de type générique.</span><span class="sxs-lookup"><span data-stu-id="66a0d-136">You can also make a function generic by using the single quotation mark syntax in a type annotation to indicate that a parameter type is a generic type parameter.</span></span> <span data-ttu-id="66a0d-137">Dans le code suivant, `function1` est générique car ses paramètres sont déclarés de cette manière, comme des paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="66a0d-137">In the following code, `function1` is generic because its parameters are declared in this manner, as type parameters.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1701.fs)]
    
## <a name="explicitly-generic-constructs"></a><span data-ttu-id="66a0d-138">Constructions explicitement génériques</span><span class="sxs-lookup"><span data-stu-id="66a0d-138">Explicitly Generic Constructs</span></span>
<span data-ttu-id="66a0d-139">Vous pouvez également rendre une fonction générique en déclarant explicitement ses paramètres de type entre crochets pointus (`<type-parameter>`).</span><span class="sxs-lookup"><span data-stu-id="66a0d-139">You can also make a function generic by explicitly declaring its type parameters in angle brackets (`<type-parameter>`).</span></span> <span data-ttu-id="66a0d-140">Le code suivant illustre ce comportement :</span><span class="sxs-lookup"><span data-stu-id="66a0d-140">The following code illustrates this.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1703.fs)]
    
## <a name="using-generic-constructs"></a><span data-ttu-id="66a0d-141">Utilisation de constructions génériques</span><span class="sxs-lookup"><span data-stu-id="66a0d-141">Using Generic Constructs</span></span>
<span data-ttu-id="66a0d-142">Quand vous utilisez des fonctions ou des méthodes génériques, il est possible que vous n’ayez pas à spécifier les arguments de type.</span><span class="sxs-lookup"><span data-stu-id="66a0d-142">When you use generic functions or methods, you might not have to specify the type arguments.</span></span> <span data-ttu-id="66a0d-143">Le compilateur utilise l’inférence de type pour déduire les arguments de type appropriés.</span><span class="sxs-lookup"><span data-stu-id="66a0d-143">The compiler uses type inference to infer the appropriate type arguments.</span></span> <span data-ttu-id="66a0d-144">Si une ambigüité persiste, vous pouvez fournir des arguments de type entre crochets pointus, en prenant soin de séparer les différents arguments de type à l’aide de virgules.</span><span class="sxs-lookup"><span data-stu-id="66a0d-144">If there is still an ambiguity, you can supply type arguments in angle brackets, separating multiple type arguments with commas.</span></span>

<span data-ttu-id="66a0d-145">Le code suivant présente l’utilisation des fonctions définies aux sections précédentes.</span><span class="sxs-lookup"><span data-stu-id="66a0d-145">The following code shows the use of the functions that are defined in the previous sections.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1702.fs)]
    
>[!NOTE]
<span data-ttu-id="66a0d-146">Il existe deux manières de faire référence à un type générique sur la base du nom.</span><span class="sxs-lookup"><span data-stu-id="66a0d-146">There are two ways to refer to a generic type by name.</span></span> <span data-ttu-id="66a0d-147">Par exemple, `list<int>` et `int list` sont deux manières de faire référence à un type générique `list` qui dispose d’un argument de type unique `int`.</span><span class="sxs-lookup"><span data-stu-id="66a0d-147">For example, `list<int>` and `int list` are two ways to refer to a generic type `list` that has a single type argument `int`.</span></span> <span data-ttu-id="66a0d-148">Cette dernière forme n’est traditionnellement utilisée qu’avec des types F# intégrés, comme `list` et `option`.</span><span class="sxs-lookup"><span data-stu-id="66a0d-148">The latter form is conventionally used only with built-in F# types such as `list` and `option`.</span></span> <span data-ttu-id="66a0d-149">S’il existe plusieurs arguments de type, vous utilisez en principe la syntaxe `Dictionary<int, string>`, mais vous pouvez également utiliser la syntaxe `(int, string) Dictionary`.</span><span class="sxs-lookup"><span data-stu-id="66a0d-149">If there are multiple type arguments, you normally use the syntax `Dictionary<int, string>` but you can also use the syntax `(int, string) Dictionary`.</span></span>

## <a name="wildcards-as-type-arguments"></a><span data-ttu-id="66a0d-150">Caractères génériques utilisés comme arguments de type</span><span class="sxs-lookup"><span data-stu-id="66a0d-150">Wildcards as Type Arguments</span></span>
<span data-ttu-id="66a0d-151">Pour spécifier qu’un argument de type doit être déduit par le compilateur, vous pouvez utiliser le trait de soulignement ou le caractère générique (`_`) à la place d’un argument de type nommé.</span><span class="sxs-lookup"><span data-stu-id="66a0d-151">To specify that a type argument should be inferred by the compiler, you can use the underscore, or wildcard symbol (`_`), instead of a named type argument.</span></span> <span data-ttu-id="66a0d-152">Ceci est illustré dans le code suivant.</span><span class="sxs-lookup"><span data-stu-id="66a0d-152">This is shown in the following code.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1704.fs)]
    
## <a name="constraints-in-generic-types-and-functions"></a><span data-ttu-id="66a0d-153">Contraintes concernant les types et fonctions génériques</span><span class="sxs-lookup"><span data-stu-id="66a0d-153">Constraints in Generic Types and Functions</span></span>
<span data-ttu-id="66a0d-154">Dans une définition de type ou de fonction générique, vous ne pouvez utiliser que les constructions connues pour être disponibles sur le paramètre de type générique.</span><span class="sxs-lookup"><span data-stu-id="66a0d-154">In a generic type or function definition, you can use only those constructs that are known to be available on the generic type parameter.</span></span> <span data-ttu-id="66a0d-155">Cette exigence est imposée pour activer la vérification des appels de fonction et de méthode lors de la compilation.</span><span class="sxs-lookup"><span data-stu-id="66a0d-155">This is required to enable the verification of function and method calls at compile time.</span></span> <span data-ttu-id="66a0d-156">Si vous déclarez vos paramètres de type explicitement, vous pouvez appliquer une contrainte explicite à un paramètre de type générique pour notifier le compilateur que certaines méthodes et fonctions sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="66a0d-156">If you declare your type parameters explicitly, you can apply an explicit constraint to a generic type parameter to notify the compiler that certain methods and functions are available.</span></span> <span data-ttu-id="66a0d-157">Toutefois, si vous autorisez le compilateur F# à déduire vos types de paramètre génériques, il détermine les contraintes appropriées pour vous.</span><span class="sxs-lookup"><span data-stu-id="66a0d-157">However, if you allow the F# compiler to infer your generic parameter types, it will determine the appropriate constraints for you.</span></span> <span data-ttu-id="66a0d-158">Pour plus d’informations, consultez [Contraintes](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="66a0d-158">For more information, see [Constraints](constraints.md).</span></span>


## <a name="statically-resolved-type-parameters"></a><span data-ttu-id="66a0d-159">Paramètres de type résolus statiquement</span><span class="sxs-lookup"><span data-stu-id="66a0d-159">Statically Resolved Type Parameters</span></span>
<span data-ttu-id="66a0d-160">Il existe deux genres de paramètres de type qui peuvent être utilisés dans des programmes F#.</span><span class="sxs-lookup"><span data-stu-id="66a0d-160">There are two kinds of type parameters that can be used in F# programs.</span></span> <span data-ttu-id="66a0d-161">Les premiers correspondent aux paramètres de type générique du genre décrit dans les précédentes sections.</span><span class="sxs-lookup"><span data-stu-id="66a0d-161">The first are generic type parameters of the kind described in the previous sections.</span></span> <span data-ttu-id="66a0d-162">Ce premier genre de paramètre de type équivaut aux paramètres de type générique utilisés dans des langages tels que Visual Basic et C#.</span><span class="sxs-lookup"><span data-stu-id="66a0d-162">This first kind of type parameter is equivalent to the generic type parameters that are used in languages such as Visual Basic and C#.</span></span> <span data-ttu-id="66a0d-163">L’autre genre de paramètre de type est spécifique à F# et est appelé *type de paramètre résolu statiquement*.</span><span class="sxs-lookup"><span data-stu-id="66a0d-163">Another kind of type parameter is specific to F# and is referred to as a *statically resolved type parameter*.</span></span> <span data-ttu-id="66a0d-164">Pour plus d’informations sur ces constructions, consultez [Paramètres de type résolus statiquement](statically-resolved-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="66a0d-164">For information about these constructs, see [Statically Resolved Type Parameters](statically-resolved-type-parameters.md).</span></span>


## <a name="examples"></a><span data-ttu-id="66a0d-165">Exemples</span><span class="sxs-lookup"><span data-stu-id="66a0d-165">Examples</span></span>
[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1705.fs)]
    
## <a name="see-also"></a><span data-ttu-id="66a0d-166">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="66a0d-166">See Also</span></span>
[<span data-ttu-id="66a0d-167">Informations de référence sur le langage</span><span class="sxs-lookup"><span data-stu-id="66a0d-167">Language Reference</span></span>](../index.md)

[<span data-ttu-id="66a0d-168">Types</span><span class="sxs-lookup"><span data-stu-id="66a0d-168">Types</span></span>](../fsharp-types.md)

[<span data-ttu-id="66a0d-169">Paramètres de type résolus statiquement</span><span class="sxs-lookup"><span data-stu-id="66a0d-169">Statically Resolved Type Parameters</span></span>](statically-resolved-type-parameters.md)

[<span data-ttu-id="66a0d-170">Génériques dans le .NET Framework</span><span class="sxs-lookup"><span data-stu-id="66a0d-170">Generics in the .NET Framework</span></span>](~/docs/standard/generics/index.md)

[<span data-ttu-id="66a0d-171">Généralisation automatique</span><span class="sxs-lookup"><span data-stu-id="66a0d-171">Automatic Generalization</span></span>](automatic-generalization.md)

[<span data-ttu-id="66a0d-172">Contraintes</span><span class="sxs-lookup"><span data-stu-id="66a0d-172">Constraints</span></span>](constraints.md)
