---
title: "Opérateurs arithmétiques (F#)"
description: "Obtenir des informations sur les opérateurs arithmétiques qui sont disponibles dans le langage de programmation F #."
keywords: visual f#, f#, programmation fonctionnelle
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: 75ddcfa3-564e-4382-80a3-f9da73d0f0ea
ms.openlocfilehash: 237b97c24f207b3a9b4661d66f029f1b18b8fec7
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/18/2017
---
# <a name="arithmetic-operators"></a><span data-ttu-id="9a868-104">Opérateurs arithmétiques</span><span class="sxs-lookup"><span data-stu-id="9a868-104">Arithmetic Operators</span></span>

<span data-ttu-id="9a868-105">Cette rubrique décrit les opérateurs arithmétiques qui sont disponibles dans le langage F #.</span><span class="sxs-lookup"><span data-stu-id="9a868-105">This topic describes arithmetic operators that are available in the F# language.</span></span>

## <a name="summary-of-binary-arithmetic-operators"></a><span data-ttu-id="9a868-106">Résumé des opérateurs arithmétiques</span><span class="sxs-lookup"><span data-stu-id="9a868-106">Summary of Binary Arithmetic Operators</span></span>
<span data-ttu-id="9a868-107">Le tableau suivant récapitule les opérateurs arithmétiques sont disponibles pour les types intégraux et à virgule flottante unboxed.</span><span class="sxs-lookup"><span data-stu-id="9a868-107">The following table summarizes the binary arithmetic operators that are available for unboxed integral and floating-point types.</span></span>

|<span data-ttu-id="9a868-108">Opérateur binaire</span><span class="sxs-lookup"><span data-stu-id="9a868-108">Binary operator</span></span>|<span data-ttu-id="9a868-109">Notes</span><span class="sxs-lookup"><span data-stu-id="9a868-109">Notes</span></span>|
|---------------|-----|
|<span data-ttu-id="9a868-110">`+`(ajout, plus)</span><span class="sxs-lookup"><span data-stu-id="9a868-110">`+` (addition, plus)</span></span>|<span data-ttu-id="9a868-111">Elle est désactivée.</span><span class="sxs-lookup"><span data-stu-id="9a868-111">Unchecked.</span></span> <span data-ttu-id="9a868-112">Condition de dépassement possible lorsque les nombres sont ajoutés et la somme dépasse la valeur absolue maximale prise en charge par le type.</span><span class="sxs-lookup"><span data-stu-id="9a868-112">Possible overflow condition when numbers are added together and the sum exceeds the maximum absolute value supported by the type.</span></span>|
|<span data-ttu-id="9a868-113">`-`(soustraction, moins)</span><span class="sxs-lookup"><span data-stu-id="9a868-113">`-` (subtraction, minus)</span></span>|<span data-ttu-id="9a868-114">Elle est désactivée.</span><span class="sxs-lookup"><span data-stu-id="9a868-114">Unchecked.</span></span> <span data-ttu-id="9a868-115">Condition de dépassement de capacité négatif possible lors de la soustraction des types non signés, ou lorsque les valeurs à virgule flottante sont trop petits pour être représentée par le type.</span><span class="sxs-lookup"><span data-stu-id="9a868-115">Possible underflow condition when unsigned types are subtracted, or when floating-point values are too small to be represented by the type.</span></span>|
|<span data-ttu-id="9a868-116">`*`(multiplication, fois)</span><span class="sxs-lookup"><span data-stu-id="9a868-116">`*` (multiplication, times)</span></span>|<span data-ttu-id="9a868-117">Elle est désactivée.</span><span class="sxs-lookup"><span data-stu-id="9a868-117">Unchecked.</span></span> <span data-ttu-id="9a868-118">Condition de dépassement de capacité possible lorsque les nombres sont multipliés et le produit dépasse la valeur absolue maximale prise en charge par le type.</span><span class="sxs-lookup"><span data-stu-id="9a868-118">Possible overflow condition when numbers are multiplied and the product exceeds the maximum absolute value supported by the type.</span></span>|
|<span data-ttu-id="9a868-119">`/`(division, divisé par)</span><span class="sxs-lookup"><span data-stu-id="9a868-119">`/` (division, divided by)</span></span>|<span data-ttu-id="9a868-120">Division par zéro provoque un <xref:System.DivideByZeroException> pour les types intégraux.</span><span class="sxs-lookup"><span data-stu-id="9a868-120">Division by zero causes a <xref:System.DivideByZeroException> for integral types.</span></span> <span data-ttu-id="9a868-121">Pour les types à virgule flottante, division par zéro vous donne les valeurs à virgule flottante spéciales `+Infinity` ou `-Infinity`.</span><span class="sxs-lookup"><span data-stu-id="9a868-121">For floating-point types, division by zero gives you the special floating-point values `+Infinity` or `-Infinity`.</span></span> <span data-ttu-id="9a868-122">Il existe également une condition de dépassement de capacité négatif possible lorsqu’un nombre à virgule flottante est trop petit pour être représentée par le type.</span><span class="sxs-lookup"><span data-stu-id="9a868-122">There is also a possible underflow condition when a floating-point number is too small to be represented by the type.</span></span>|
|<span data-ttu-id="9a868-123">`%`(le module, mod)</span><span class="sxs-lookup"><span data-stu-id="9a868-123">`%` (modulus, mod)</span></span>|<span data-ttu-id="9a868-124">Retourne le reste d’une opération de division.</span><span class="sxs-lookup"><span data-stu-id="9a868-124">Returns the remainder of a division operation.</span></span> <span data-ttu-id="9a868-125">Le signe du résultat est le même que le signe du premier opérande.</span><span class="sxs-lookup"><span data-stu-id="9a868-125">The sign of the result is the same as the sign of the first operand.</span></span>|
|<span data-ttu-id="9a868-126">`**`(élévation à la puissance)</span><span class="sxs-lookup"><span data-stu-id="9a868-126">`**` (exponentiation, to the power of)</span></span>|<span data-ttu-id="9a868-127">Condition de dépassement possible lorsque le résultat dépasse la valeur absolue maximale pour le type.</span><span class="sxs-lookup"><span data-stu-id="9a868-127">Possible overflow condition when the result exceeds the maximum absolute value for the type.</span></span><br /><br /><span data-ttu-id="9a868-128">L’opérateur d’élévation fonctionne uniquement avec les types à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="9a868-128">The exponentiation operator works only with floating-point types.</span></span>|

## <a name="summary-of-unary-arithmetic-operators"></a><span data-ttu-id="9a868-129">Résumé des opérateurs arithmétiques unaires</span><span class="sxs-lookup"><span data-stu-id="9a868-129">Summary of Unary Arithmetic Operators</span></span>
<span data-ttu-id="9a868-130">Le tableau suivant récapitule les opérateurs arithmétiques unaires qui sont disponibles pour les types intégraux et à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="9a868-130">The following table summarizes the unary arithmetic operators that are available for integral and floating-point types.</span></span>


|<span data-ttu-id="9a868-131">Opérateur unaire</span><span class="sxs-lookup"><span data-stu-id="9a868-131">Unary operator</span></span>|<span data-ttu-id="9a868-132">Notes</span><span class="sxs-lookup"><span data-stu-id="9a868-132">Notes</span></span>|
|--------------|-----|
|<span data-ttu-id="9a868-133">`+`(positif)</span><span class="sxs-lookup"><span data-stu-id="9a868-133">`+` (positive)</span></span>|<span data-ttu-id="9a868-134">Peut être appliqué à n’importe quelle expression arithmétique.</span><span class="sxs-lookup"><span data-stu-id="9a868-134">Can be applied to any arithmetic expression.</span></span> <span data-ttu-id="9a868-135">Ne modifie pas le signe de la valeur.</span><span class="sxs-lookup"><span data-stu-id="9a868-135">Does not change the sign of the value.</span></span>|
|<span data-ttu-id="9a868-136">`-`(négation, négative)</span><span class="sxs-lookup"><span data-stu-id="9a868-136">`-` (negation, negative)</span></span>|<span data-ttu-id="9a868-137">Peut être appliqué à n’importe quelle expression arithmétique.</span><span class="sxs-lookup"><span data-stu-id="9a868-137">Can be applied to any arithmetic expression.</span></span> <span data-ttu-id="9a868-138">Modifie le signe de la valeur.</span><span class="sxs-lookup"><span data-stu-id="9a868-138">Changes the sign of the value.</span></span>|
<span data-ttu-id="9a868-139">Le comportement de dépassement de capacité positif ou négatif pour les types intégraux est habiller.</span><span class="sxs-lookup"><span data-stu-id="9a868-139">The behavior at overflow or underflow for integral types is to wrap around.</span></span> <span data-ttu-id="9a868-140">Cela provoque un résultat incorrect.</span><span class="sxs-lookup"><span data-stu-id="9a868-140">This causes an incorrect result.</span></span> <span data-ttu-id="9a868-141">Dépassement sur les entiers est un problème sérieux qui peut contribuer à des problèmes de sécurité lorsque le logiciel n’est pas écrite pour prendre en compte pour qu’il.</span><span class="sxs-lookup"><span data-stu-id="9a868-141">Integer overflow is a potentially serious problem that can contribute to security issues when software is not written to account for it.</span></span> <span data-ttu-id="9a868-142">S’il s’agit d’un critère important pour votre application, envisagez d’utiliser les opérateurs checked dans `Microsoft.FSharp.Core.Operators.Checked`.</span><span class="sxs-lookup"><span data-stu-id="9a868-142">If this is a concern for your application, consider using the checked operators in `Microsoft.FSharp.Core.Operators.Checked`.</span></span>


## <a name="summary-of-binary-comparison-operators"></a><span data-ttu-id="9a868-143">Résumé des opérateurs de comparaison binaire</span><span class="sxs-lookup"><span data-stu-id="9a868-143">Summary of Binary Comparison Operators</span></span>
<span data-ttu-id="9a868-144">Le tableau suivant répertorie les opérateurs de comparaison binaire qui sont disponibles pour les types intégraux et à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="9a868-144">The following table shows the binary comparison operators that are available for integral and floating-point types.</span></span> <span data-ttu-id="9a868-145">Ces opérateurs retournent des valeurs de type `bool`.</span><span class="sxs-lookup"><span data-stu-id="9a868-145">These operators return values of type `bool`.</span></span>

<span data-ttu-id="9a868-146">Chiffres à virgule flottante doit être jamais directement comparé en égalité, car la représentation à virgule flottante IEEE ne prend pas en charge une opération d’égalité exacte.</span><span class="sxs-lookup"><span data-stu-id="9a868-146">Floating-point numbers should never be directly compared for equality, because the IEEE floating-point representation does not support an exact equality operation.</span></span> <span data-ttu-id="9a868-147">Deux nombres que vous pouvez facilement vérifier égal en inspectant le code peut ont en fait des représentations de bit différentes.</span><span class="sxs-lookup"><span data-stu-id="9a868-147">Two numbers that you can easily verify to be equal by inspecting the code might actually have different bit representations.</span></span>



|<span data-ttu-id="9a868-148">Opérateur</span><span class="sxs-lookup"><span data-stu-id="9a868-148">Operator</span></span>|<span data-ttu-id="9a868-149">Notes</span><span class="sxs-lookup"><span data-stu-id="9a868-149">Notes</span></span>|
|--------|-----|
|<span data-ttu-id="9a868-150">`=`(égalité, égal à)</span><span class="sxs-lookup"><span data-stu-id="9a868-150">`=` (equality, equals)</span></span>|<span data-ttu-id="9a868-151">Ce n’est pas un opérateur d’assignation.</span><span class="sxs-lookup"><span data-stu-id="9a868-151">This is not an assignment operator.</span></span> <span data-ttu-id="9a868-152">Il est utilisé uniquement pour la comparaison.</span><span class="sxs-lookup"><span data-stu-id="9a868-152">It is used only for comparison.</span></span> <span data-ttu-id="9a868-153">Il s’agit d’un opérateur générique.</span><span class="sxs-lookup"><span data-stu-id="9a868-153">This is a generic operator.</span></span>|
|<span data-ttu-id="9a868-154">`>`(supérieur à)</span><span class="sxs-lookup"><span data-stu-id="9a868-154">`>` (greater than)</span></span>|<span data-ttu-id="9a868-155">Il s’agit d’un opérateur générique.</span><span class="sxs-lookup"><span data-stu-id="9a868-155">This is a generic operator.</span></span>|
|<span data-ttu-id="9a868-156">`<`(inférieur à)</span><span class="sxs-lookup"><span data-stu-id="9a868-156">`<` (less than)</span></span>|<span data-ttu-id="9a868-157">Il s’agit d’un opérateur générique.</span><span class="sxs-lookup"><span data-stu-id="9a868-157">This is a generic operator.</span></span>|
|<span data-ttu-id="9a868-158">`>=`(supérieur ou égal à)</span><span class="sxs-lookup"><span data-stu-id="9a868-158">`>=` (greater than or equals)</span></span>|<span data-ttu-id="9a868-159">Il s’agit d’un opérateur générique.</span><span class="sxs-lookup"><span data-stu-id="9a868-159">This is a generic operator.</span></span>|
|<span data-ttu-id="9a868-160">`<=`(inférieur ou égal à)</span><span class="sxs-lookup"><span data-stu-id="9a868-160">`<=` (less than or equals)</span></span>|<span data-ttu-id="9a868-161">Il s’agit d’un opérateur générique.</span><span class="sxs-lookup"><span data-stu-id="9a868-161">This is a generic operator.</span></span>|
|<span data-ttu-id="9a868-162">`<>`(non égal)</span><span class="sxs-lookup"><span data-stu-id="9a868-162">`<>` (not equal)</span></span>|<span data-ttu-id="9a868-163">Il s’agit d’un opérateur générique.</span><span class="sxs-lookup"><span data-stu-id="9a868-163">This is a generic operator.</span></span>|

## <a name="overloaded-and-generic-operators"></a><span data-ttu-id="9a868-164">Opérateurs surchargés et génériques</span><span class="sxs-lookup"><span data-stu-id="9a868-164">Overloaded and Generic Operators</span></span>
<span data-ttu-id="9a868-165">Tous les opérateurs décrits dans cette rubrique sont définis dans le **Microsoft.FSharp.Core.Operators** espace de noms.</span><span class="sxs-lookup"><span data-stu-id="9a868-165">All of the operators discussed in this topic are defined in the **Microsoft.FSharp.Core.Operators** namespace.</span></span> <span data-ttu-id="9a868-166">Certains des opérateurs sont définis à l’aide des paramètres de type résolus statiquement.</span><span class="sxs-lookup"><span data-stu-id="9a868-166">Some of the operators are defined by using statically resolved type parameters.</span></span> <span data-ttu-id="9a868-167">Cela signifie qu’il existe des définitions individuelles pour chaque type spécifique fonctionnant avec cet opérateur.</span><span class="sxs-lookup"><span data-stu-id="9a868-167">This means that there are individual definitions for each specific type that works with that operator.</span></span> <span data-ttu-id="9a868-168">Tous les opérateurs unaires et binaires arithmétiques et au niveau du bit sont dans cette catégorie.</span><span class="sxs-lookup"><span data-stu-id="9a868-168">All of the unary and binary arithmetic and bitwise operators are in this category.</span></span> <span data-ttu-id="9a868-169">Les opérateurs de comparaison sont génériques et par conséquent, fonctionnent avec n’importe quel type, pas simplement primitifs types arithmétiques.</span><span class="sxs-lookup"><span data-stu-id="9a868-169">The comparison operators are generic and therefore work with any type, not just primitive arithmetic types.</span></span> <span data-ttu-id="9a868-170">Union discriminée et types d’enregistrement ont leurs propres implémentations personnalisées qui sont générées par le compilateur F #.</span><span class="sxs-lookup"><span data-stu-id="9a868-170">Discriminated union and record types have their own custom implementations that are generated by the F# compiler.</span></span> <span data-ttu-id="9a868-171">Types de classe utilisent la méthode <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="9a868-171">Class types use the method <xref:System.Object.Equals%2A>.</span></span>

<span data-ttu-id="9a868-172">Les opérateurs génériques sont personnalisables.</span><span class="sxs-lookup"><span data-stu-id="9a868-172">The generic operators are customizable.</span></span> <span data-ttu-id="9a868-173">Pour personnaliser les fonctions de comparaison, substituez <xref:System.Object.Equals%2A> pour fournir votre propre comparaison d’égalité personnalisée, puis implémentez <xref:System.IComparable>.</span><span class="sxs-lookup"><span data-stu-id="9a868-173">To customize the comparison functions, override <xref:System.Object.Equals%2A> to provide your own custom equality comparison, and then implement <xref:System.IComparable>.</span></span> <span data-ttu-id="9a868-174">Le <xref:System.IComparable?displayProperty=nameWithType> interface a une méthode unique, la <xref:System.IComparable.CompareTo%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="9a868-174">The <xref:System.IComparable?displayProperty=nameWithType> interface has a single method, the <xref:System.IComparable.CompareTo%2A> method.</span></span>


## <a name="operators-and-type-inference"></a><span data-ttu-id="9a868-175">Opérateurs et inférence de Type</span><span class="sxs-lookup"><span data-stu-id="9a868-175">Operators and Type Inference</span></span>
<span data-ttu-id="9a868-176">L’utilisation d’un opérateur dans une expression contraint l’inférence de type sur cet opérateur.</span><span class="sxs-lookup"><span data-stu-id="9a868-176">The use of an operator in an expression constrains type inference on that operator.</span></span> <span data-ttu-id="9a868-177">En outre, l’utilisation d’opérateurs empêche la généralisation automatique, car l’utilisation d’opérateurs implique un type arithmétique.</span><span class="sxs-lookup"><span data-stu-id="9a868-177">Also, the use of operators prevents automatic generalization, because the use of operators implies an arithmetic type.</span></span> <span data-ttu-id="9a868-178">En l’absence de toute autre information, le compilateur F # déduit `int` comme type d’expressions arithmétiques.</span><span class="sxs-lookup"><span data-stu-id="9a868-178">In the absence of any other information, the F# compiler infers `int` as the type of arithmetic expressions.</span></span> <span data-ttu-id="9a868-179">Vous pouvez substituer ce comportement en spécifiant un autre type.</span><span class="sxs-lookup"><span data-stu-id="9a868-179">You can override this behavior by specifying another type.</span></span> <span data-ttu-id="9a868-180">Par conséquent les types d’arguments et le type de retour de `function1` dans le code suivant sont déduits pour être `int`, mais les types de `function2` sont déduits pour être `float`.</span><span class="sxs-lookup"><span data-stu-id="9a868-180">Thus the argument types and return type of `function1` in the following code are inferred to be `int`, but the types for `function2` are inferred to be `float`.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3501.fs)]
    
## <a name="see-also"></a><span data-ttu-id="9a868-181">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="9a868-181">See Also</span></span>
[<span data-ttu-id="9a868-182">Informations de référence des symboles et opérateurs</span><span class="sxs-lookup"><span data-stu-id="9a868-182">Symbol and Operator Reference</span></span>](index.md)

[<span data-ttu-id="9a868-183">Surcharge d'opérateur</span><span class="sxs-lookup"><span data-stu-id="9a868-183">Operator Overloading</span></span>](../operator-overloading.md)

[<span data-ttu-id="9a868-184">Opérateurs au niveau du bit</span><span class="sxs-lookup"><span data-stu-id="9a868-184">Bitwise Operators</span></span>](bitwise-operators.md)

[<span data-ttu-id="9a868-185">Opérateurs booléens</span><span class="sxs-lookup"><span data-stu-id="9a868-185">Boolean Operators</span></span>](boolean-operators.md)
