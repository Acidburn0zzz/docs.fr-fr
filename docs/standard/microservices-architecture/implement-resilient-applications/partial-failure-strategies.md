---
title: "Stratégies pour la gestion d’une défaillance partielle"
description: "Architecture des microservices .NET pour les applications .NET en conteneur | Stratégies pour la gestion d’une défaillance partielle"
keywords: Docker, microservices, ASP.NET, conteneur
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: baeeb47dde77ceaa461214f55482d2312d67ccec
ms.sourcegitcommit: c0dd436f6f8f44dc80dc43b07f6841a00b74b23f
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/19/2018
---
# <a name="strategies-for-handling-partial-failure"></a><span data-ttu-id="6881f-104">Stratégies pour la gestion d’une défaillance partielle</span><span class="sxs-lookup"><span data-stu-id="6881f-104">Strategies for handling partial failure</span></span>

<span data-ttu-id="6881f-105">Les stratégies pour la gestion des défaillances partielles sont les suivantes.</span><span class="sxs-lookup"><span data-stu-id="6881f-105">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="6881f-106">**Utilisez la communication asynchrone (par exemple, la communication basée sur les messages) sur les microservices internes**.</span><span class="sxs-lookup"><span data-stu-id="6881f-106">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="6881f-107">Il est vivement conseillé de ne pas créer de longues chaînes d’appels HTTP synchrones entre les microservices internes, car cette conception incorrecte peut devenir la cause principale de graves pannes.</span><span class="sxs-lookup"><span data-stu-id="6881f-107">It is highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="6881f-108">Au contraire, à l’exception des communications frontend entre les applications clientes et le premier niveau des microservices ou les passerelles d’API affinées, il est recommandé d’utiliser une communication asynchrone (basée sur les messages) uniquement après le premier cycle de demande/réponse, entre les microservices internes.</span><span class="sxs-lookup"><span data-stu-id="6881f-108">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it is recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="6881f-109">La cohérence à terme et les architectures basées sur les événements permettent de réduire les effets en chaîne.</span><span class="sxs-lookup"><span data-stu-id="6881f-109">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="6881f-110">Ces approches appliquent un plus haut niveau d’autonomie des microservices, c’est pourquoi elles préviennent le problème indiqué ici.</span><span class="sxs-lookup"><span data-stu-id="6881f-110">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="6881f-111">**Utilisez les nouvelles tentatives avec interruption exponentielle**.</span><span class="sxs-lookup"><span data-stu-id="6881f-111">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="6881f-112">Cette technique permet d’éviter les défaillances brèves et intermittentes en effectuant de nouvelles tentatives d’appel un certain nombre de fois, dans le cas où le service ne serait pas disponible pendant seulement une courte période.</span><span class="sxs-lookup"><span data-stu-id="6881f-112">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="6881f-113">Cela peut se produire lors de problèmes réseau intermittents ou quand un microservice/conteneur est déplacé vers un autre nœud d’un cluster.</span><span class="sxs-lookup"><span data-stu-id="6881f-113">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="6881f-114">Toutefois, si ces nouvelles tentatives ne sont pas correctement conçues avec des disjoncteurs, les effets en chaîne peuvent s’aggraver, entraînant même, à terme, un [déni de service](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span><span class="sxs-lookup"><span data-stu-id="6881f-114">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="6881f-115">**Contournez les délais d’attente réseau**.</span><span class="sxs-lookup"><span data-stu-id="6881f-115">**Work around network timeouts**.</span></span> <span data-ttu-id="6881f-116">En général, les clients doivent être conçus pour ne pas se bloquer indéfiniment et pour toujours utiliser des délais d’expiration lors de l’attente d’une réponse.</span><span class="sxs-lookup"><span data-stu-id="6881f-116">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="6881f-117">L’utilisation de délais d’expiration garantit que les ressources ne sont jamais bloquées indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="6881f-117">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="6881f-118">**Utilisez le modèle Disjoncteur**.</span><span class="sxs-lookup"><span data-stu-id="6881f-118">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="6881f-119">Dans cette approche, le processus client suit le nombre de requêtes ayant échoué.</span><span class="sxs-lookup"><span data-stu-id="6881f-119">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="6881f-120">Si le taux d’erreurs dépasse une limite configurée, un « disjoncteur » est déclenché de sorte que les autres tentatives échouent immédiatement.</span><span class="sxs-lookup"><span data-stu-id="6881f-120">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="6881f-121">(L’échec d’un grand nombre de requêtes est le signe que le service n’est pas disponible et qu’il est inutile d’envoyer des requêtes.) Après un délai d’expiration, le client doit réessayer. Si les nouvelles requêtes réussissent, fermez le disjoncteur.</span><span class="sxs-lookup"><span data-stu-id="6881f-121">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="6881f-122">**Fournissez des solutions de secours**.</span><span class="sxs-lookup"><span data-stu-id="6881f-122">**Provide fallbacks**.</span></span> <span data-ttu-id="6881f-123">Dans cette approche, le processus client exécute la logique de secours en cas d’échec d’une requête, comme le retour de données mises en cache ou d’une valeur par défaut.</span><span class="sxs-lookup"><span data-stu-id="6881f-123">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="6881f-124">Il s’agit d’une approche appropriée pour les requêtes, mais qui est plus complexe pour les mises à jour ou les commandes.</span><span class="sxs-lookup"><span data-stu-id="6881f-124">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="6881f-125">**Limitez le nombre de requêtes placées en file d’attente**.</span><span class="sxs-lookup"><span data-stu-id="6881f-125">**Limit the number of queued requests**.</span></span> <span data-ttu-id="6881f-126">Les clients doivent également imposer une limite plus grande du nombre de requêtes en attente qu’un microservice client peut envoyer à un service particulier.</span><span class="sxs-lookup"><span data-stu-id="6881f-126">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="6881f-127">Si la limite est atteinte, il est probablement inutile d’effectuer d’autres requêtes, et ces tentatives devraient échouer immédiatement.</span><span class="sxs-lookup"><span data-stu-id="6881f-127">If the limit has been reached, it is probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="6881f-128">En termes d’implémentation, la stratégie d’[isolation par cloisonnement](https://github.com/App-vNext/Polly/wiki/Bulkhead) de Polly peut être utilisée pour satisfaire cette exigence.</span><span class="sxs-lookup"><span data-stu-id="6881f-128">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfil this requirement.</span></span> <span data-ttu-id="6881f-129">Cette approche est essentiellement une limitation de parallélisation avec [SemaphoreSlim](https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-1.1) comme implémentation.</span><span class="sxs-lookup"><span data-stu-id="6881f-129">This approach is essentially a parallelization throttle with [SemaphoreSlim](https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-1.1) as the implementation.</span></span> <span data-ttu-id="6881f-130">Elle autorise également une « file d’attente » à l’extérieur du cloisonnement.</span><span class="sxs-lookup"><span data-stu-id="6881f-130">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="6881f-131">Vous pouvez vous protéger de manière proactive contre une charge excessive , même avant l’exécution (par exemple, parce que la capacité maximale est considérée comme atteinte).</span><span class="sxs-lookup"><span data-stu-id="6881f-131">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="6881f-132">Ainsi, sa réponse à certains scénarios de défaillance est plus rapide que celle d’un disjoncteur, puisque le disjoncteur attend la défaillance.</span><span class="sxs-lookup"><span data-stu-id="6881f-132">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="6881f-133">Dans Polly, l’objet BulkheadPolicy expose le niveau de remplissage du cloisonnement et de la file d’attente. De plus, en cas de dépassement, il propose des événements qui peuvent également être utilisés pour gérer la mise à l’échelle horizontale automatisée.</span><span class="sxs-lookup"><span data-stu-id="6881f-133">The BulkheadPolicy object in Polly exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="6881f-134">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="6881f-134">Additional resources</span></span>

-   <span data-ttu-id="6881f-135">**Modèles de résilience**
    [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span><span class="sxs-lookup"><span data-stu-id="6881f-135">**Resiliency patterns**
[*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span></span>

-   <span data-ttu-id="6881f-136">**Ajout de résilience et optimisation des performances**
    [*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span><span class="sxs-lookup"><span data-stu-id="6881f-136">**Adding Resilience and Optimizing Performance**
[*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span></span>

-   <span data-ttu-id="6881f-137">**Cloisonnement.**</span><span class="sxs-lookup"><span data-stu-id="6881f-137">**Bulkhead.**</span></span> <span data-ttu-id="6881f-138">Dépôt GitHub.</span><span class="sxs-lookup"><span data-stu-id="6881f-138">GitHub repo.</span></span> <span data-ttu-id="6881f-139">Implémentation de la stratégie de Polly.</span><span class="sxs-lookup"><span data-stu-id="6881f-139">Implementation with Polly policy.\\</span></span>
    [<span data-ttu-id="6881f-140">*https://github.com/App-vNext/Polly/wiki/Bulkhead*</span><span class="sxs-lookup"><span data-stu-id="6881f-140">*https://github.com/App-vNext/Polly/wiki/Bulkhead*</span></span>](https://github.com/App-vNext/Polly/wiki/Bulkhead)

-   <span data-ttu-id="6881f-141">**Conception d’applications résilientes pour Azure**
    [*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span><span class="sxs-lookup"><span data-stu-id="6881f-141">**Designing resilient applications for Azure**
[*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span></span>

-   <span data-ttu-id="6881f-142">**Gestion des erreurs temporaires**
    <https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span><span class="sxs-lookup"><span data-stu-id="6881f-142">**Transient fault handling**
<https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span></span>


>[!div class="step-by-step"]
<span data-ttu-id="6881f-143">[Précédent] (handle-partial-failure.md) [Suivant] (implement-retries-exponential-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="6881f-143">[Previous] (handle-partial-failure.md) [Next] (implement-retries-exponential-backoff.md)</span></span>
