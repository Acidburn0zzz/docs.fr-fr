---
title: "Conception de la couche de persistance d’infrastructure"
description: "Architecture de Microservices .NET pour les Applications .NET en conteneur | Conception de la couche de persistance d’infrastructure"
keywords: Docker, microservices, ASP.NET, conteneur
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: ce0f1d608eed909a7707f3c580afc5253f3eef06
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/18/2017
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="4a657-104">Conception de la couche de persistance d’infrastructure</span><span class="sxs-lookup"><span data-stu-id="4a657-104">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="4a657-105">Composants de persistance de données fournissent un accès aux données hébergées dans les limites d’un microservice (autrement dit, base de données d’un microservice).</span><span class="sxs-lookup"><span data-stu-id="4a657-105">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="4a657-106">Ils contiennent l’implémentation réelle de composants tels que les référentiels et [unité de travail](http://martinfowler.com/eaaCatalog/unitOfWork.html) les classes, comme les DBContexts EF personnalisé.</span><span class="sxs-lookup"><span data-stu-id="4a657-106">They contain the actual implementation of components such as repositories and [Unit of Work](http://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom EF DBContexts.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="4a657-107">Le modèle de référentiel</span><span class="sxs-lookup"><span data-stu-id="4a657-107">The Repository pattern</span></span>

<span data-ttu-id="4a657-108">Référentiels sont des classes ou des composants qui encapsulent la logique nécessaire pour accéder aux sources de données.</span><span class="sxs-lookup"><span data-stu-id="4a657-108">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="4a657-109">Ils centralisent les données access des fonctionnalités communes, en fournissant une meilleure facilité de maintenance et le découplage de l’infrastructure ou la technologie utilisée pour accéder aux bases de données à partir de la couche de modèle de domaine.</span><span class="sxs-lookup"><span data-stu-id="4a657-109">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="4a657-110">Si vous utilisez un ORM comme Entity Framework, le code qui doit être implémenté est simplifié grâce à LINQ et un typage fort.</span><span class="sxs-lookup"><span data-stu-id="4a657-110">If you use an ORM like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="4a657-111">Cela vous permet de vous concentrer sur la logique de persistance des données plutôt que sur les données d’accès plomberie.</span><span class="sxs-lookup"><span data-stu-id="4a657-111">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="4a657-112">Le modèle de référentiel est une façon bien documentée de l’utilisation de la source de données.</span><span class="sxs-lookup"><span data-stu-id="4a657-112">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="4a657-113">Dans le carnet de [modèles d’Architecture d’Application Enterprise](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler décrit un référentiel comme suit :</span><span class="sxs-lookup"><span data-stu-id="4a657-113">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

<span data-ttu-id="4a657-114">Un référentiel effectue les tâches d’intermédiaire entre les couches de modèle de domaine et le mappage de données, qui agit de manière similaire à un ensemble d’objets de domaine dans la mémoire.</span><span class="sxs-lookup"><span data-stu-id="4a657-114">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="4a657-115">Les objets de client générer des requêtes de façon déclarative et les envoyer vers les référentiels pour obtenir des réponses.</span><span class="sxs-lookup"><span data-stu-id="4a657-115">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="4a657-116">Point de vue conceptuel, un référentiel encapsule un ensemble d’objets stockés dans la base de données et les opérations qui peuvent être effectuées sur ces derniers, en fournissant un moyen plus proche de la couche de persistance.</span><span class="sxs-lookup"><span data-stu-id="4a657-116">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="4a657-117">Référentiels, également, prend en charge que l’objectif de séparation, clairement et dans un sens, la dépendance entre le domaine de travail et l’allocation de données ou d’un mappage.</span><span class="sxs-lookup"><span data-stu-id="4a657-117">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="4a657-118">Définir un référentiel par l’agrégat</span><span class="sxs-lookup"><span data-stu-id="4a657-118">Define one repository per aggregate</span></span>

<span data-ttu-id="4a657-119">Pour chaque racine d’agrégation ou d’agrégation, vous devez créer une classe de référentiel.</span><span class="sxs-lookup"><span data-stu-id="4a657-119">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="4a657-120">Dans un microservice basée sur des modèles de conception domaine, le canal uniquement, que vous devez utiliser pour mettre à jour la base de données doit être les référentiels.</span><span class="sxs-lookup"><span data-stu-id="4a657-120">In a microservice based on domain-driven design patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="4a657-121">Il s’agit, car ils ont une relation avec la racine d’agrégation, qui contrôle la cohérence transactionnelle et les invariants de l’agrégat.</span><span class="sxs-lookup"><span data-stu-id="4a657-121">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="4a657-122">Il est OK interroger la base de données à travers les autres canaux (comme vous pouvez le faire suivant une approche CQRS), car elles ne changent pas l’état de la base de données.</span><span class="sxs-lookup"><span data-stu-id="4a657-122">It is okay to query the database through other channels (as you can do following a CQRS approach), because queries do not change the state of the database.</span></span> <span data-ttu-id="4a657-123">Toutefois, la zone transactionnelle, les mises à jour, doivent toujours être contrôlés par les référentiels et les racines d’agrégat.</span><span class="sxs-lookup"><span data-stu-id="4a657-123">However, the transactional area—the updates—must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="4a657-124">En fait, un référentiel vous permet de remplir les données dans la mémoire provenant de la base de données sous la forme d’entités de domaine.</span><span class="sxs-lookup"><span data-stu-id="4a657-124">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="4a657-125">Une fois les entités en mémoire, elles peuvent être modifiées et puis persistantes dans la base de données à des transactions.</span><span class="sxs-lookup"><span data-stu-id="4a657-125">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="4a657-126">Comme indiqué précédemment, si vous utilisez le modèle architectural CQS/CQRS, les requêtes initiales seront effectuées par les requêtes côté hors du modèle de domaine, effectuées par des instructions SQL simples à l’aide de Dapper.</span><span class="sxs-lookup"><span data-stu-id="4a657-126">As noted earlier, if you are using the CQS/CQRS architectural pattern, the initial queries will be performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="4a657-127">Cette approche est beaucoup plus souple que référentiels, car vous pouvez interroger et joindre des tables que vous devez, et ces requêtes ne sont pas limitées par les règles à partir d’agrégats.</span><span class="sxs-lookup"><span data-stu-id="4a657-127">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries are not restricted by rules from the aggregates.</span></span> <span data-ttu-id="4a657-128">Ces données passera à l’application de client ou de la couche présentation.</span><span class="sxs-lookup"><span data-stu-id="4a657-128">That data will go to the presentation layer or client app.</span></span>

<span data-ttu-id="4a657-129">Si l’utilisateur apporte des modifications, les données à mettre à jour proviendront de la couche d’application ou une présentation de client à la couche application (par exemple, un service Web API).</span><span class="sxs-lookup"><span data-stu-id="4a657-129">If the user makes changes, the data to be updated will come from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="4a657-130">Lorsque vous recevez une commande (avec des données) dans un gestionnaire de commandes, vous utilisez des référentiels pour obtenir les données que vous souhaitez mettre à jour à partir de la base de données.</span><span class="sxs-lookup"><span data-stu-id="4a657-130">When you receive a command (with data) in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="4a657-131">Vous mettre à jour en mémoire avec les informations passées avec les commandes, et vous pouvez ensuite ajouter ou de mettre à jour les données (entités de domaine) dans la base de données via une transaction.</span><span class="sxs-lookup"><span data-stu-id="4a657-131">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="4a657-132">Nous devons mettre en évidence à nouveau que seul référentiel doit être défini pour chaque racine d’agrégat, comme indiqué dans la Figure 9-17.</span><span class="sxs-lookup"><span data-stu-id="4a657-132">We must emphasize again that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="4a657-133">Pour atteindre l’objectif de la racine d’agrégation pour maintenir la cohérence transactionnelle entre tous les objets au sein de l’agrégat, vous ne devez jamais créer un référentiel pour chaque table dans la base de données.</span><span class="sxs-lookup"><span data-stu-id="4a657-133">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="4a657-134">**Figure 9-17**.</span><span class="sxs-lookup"><span data-stu-id="4a657-134">**Figure 9-17**.</span></span> <span data-ttu-id="4a657-135">La relation entre les référentiels, les agrégats et les tables de base de données</span><span class="sxs-lookup"><span data-stu-id="4a657-135">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="4a657-136">En appliquant une racine d’agrégation par référentiel</span><span class="sxs-lookup"><span data-stu-id="4a657-136">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="4a657-137">Il peut être utile pour implémenter la conception de votre référentiel de sorte qu’il applique la règle que seules les racines d’agrégation doivent avoir des référentiels.</span><span class="sxs-lookup"><span data-stu-id="4a657-137">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="4a657-138">Vous pouvez créer un type générique ou de base de référentiel qui limite le type d’entité associé pour vous assurer qu’ils ont l’interface de marqueur IAggregateRoot.</span><span class="sxs-lookup"><span data-stu-id="4a657-138">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the IAggregateRoot marker interface.</span></span>

<span data-ttu-id="4a657-139">Par conséquent, chaque classe de référentiel implémenté au niveau de la couche d’infrastructure implémente son propre contrat ou une interface, comme indiqué dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="4a657-139">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
```

<span data-ttu-id="4a657-140">Chaque interface du référentiel spécifique implémente l’interface IRepository générique :</span><span class="sxs-lookup"><span data-stu-id="4a657-140">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="4a657-141">Toutefois, pour que le code d’appliquer la convention d’assurer un meilleur que chaque référentiel doit être lié à un agrégat unique serait d’implémenter un type de référentiel générique afin qu’il soit explicite que vous utilisez un référentiel pour cibler un regroupement spécifique.</span><span class="sxs-lookup"><span data-stu-id="4a657-141">However, a better way to have the code enforce the convention that each repository should be related to a single aggregate would be to implement a generic repository type so it is explicit that you are using a repository to target a specific aggregate.</span></span> <span data-ttu-id="4a657-142">Cela peut se faire facilement en implémentant ce générique dans l’interface de base IRepository, comme dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="4a657-142">That can be easily done by implementing that generic in the IRepository base interface, as in the following code:</span></span>

```csharp
  public interface IRepository<T> where T : IAggregateRoot
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="4a657-143">Le modèle de référentiel rend plus faciles à tester votre logique d’application</span><span class="sxs-lookup"><span data-stu-id="4a657-143">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="4a657-144">Le modèle de référentiel vous permet de tester facilement votre application avec des tests unitaires.</span><span class="sxs-lookup"><span data-stu-id="4a657-144">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="4a657-145">N’oubliez pas que les tests unitaires uniquement tester votre code, l’infrastructure pas sorte que les abstractions de référentiel plus faciles à atteindre cet objectif.</span><span class="sxs-lookup"><span data-stu-id="4a657-145">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="4a657-146">Comme indiqué dans la section précédente, il est recommandé que vous définissez et placez les interfaces de référentiel dans la couche de modèle de domaine afin que la couche d’application (par exemple, votre microservice API Web) ne dépend pas directement de la couche d’infrastructure, dans laquelle vous avez mis en œuvre les classes du référentiel réel.</span><span class="sxs-lookup"><span data-stu-id="4a657-146">As noted in an earlier section, it is recommended that you define and place the repository interfaces in the domain model layer so the application layer (for instance, your Web API microservice) does not depend directly on the infrastructure layer where you have implemented the actual repository classes.</span></span> <span data-ttu-id="4a657-147">Par cette opération et à l’aide de l’Injection de dépendances dans les contrôleurs de votre API Web, vous pouvez implémenter des référentiels fictives qui retournent des données fictives au lieu des données à partir de la base de données.</span><span class="sxs-lookup"><span data-stu-id="4a657-147">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="4a657-148">Qu’approche découplée vous permet de créer et de tests unitaires d’exécution qui peuvent tester uniquement la logique de votre application sans nécessiter de connectivité à la base de données.</span><span class="sxs-lookup"><span data-stu-id="4a657-148">That decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="4a657-149">Connexions aux bases de données peuvent échouer et, plus important, des centaines de tests en cours d’exécution par rapport à une base de données est incorrect pour deux raisons.</span><span class="sxs-lookup"><span data-stu-id="4a657-149">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="4a657-150">Tout d’abord, il peut prendre beaucoup de temps en raison du grand nombre de tests.</span><span class="sxs-lookup"><span data-stu-id="4a657-150">First, it can take a lot of time because of the large number of tests.</span></span> <span data-ttu-id="4a657-151">En second lieu, les enregistrements de base de données peuvent modifier et affecter les résultats de vos tests, afin qu’ils ne peuvent pas être cohérents.</span><span class="sxs-lookup"><span data-stu-id="4a657-151">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="4a657-152">Test par rapport à la base de données n’est pas une unité de tests, mais que des tests d’une intégration.</span><span class="sxs-lookup"><span data-stu-id="4a657-152">Testing against the database is not a unit tests but an integration test.</span></span> <span data-ttu-id="4a657-153">Vous devez disposer de nombreux tests unitaires en cours d’exécution rapide, mais moins d’intégration des tests sur les bases de données.</span><span class="sxs-lookup"><span data-stu-id="4a657-153">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="4a657-154">En termes de séparation des problèmes pour les tests unitaires, votre logique s’exécute sur les entités de domaine dans la mémoire.</span><span class="sxs-lookup"><span data-stu-id="4a657-154">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="4a657-155">Il suppose que la classe du référentiel a livré les.</span><span class="sxs-lookup"><span data-stu-id="4a657-155">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="4a657-156">Une fois que votre logique modifie les entités de domaine, il suppose que la classe de référentiel stockera les correctement.</span><span class="sxs-lookup"><span data-stu-id="4a657-156">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="4a657-157">Le point important ici consiste à créer des tests unitaires sur votre modèle de domaine et de sa logique de domaine.</span><span class="sxs-lookup"><span data-stu-id="4a657-157">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="4a657-158">Racines d’agrégat sont les limites de cohérence principal dans DDD.</span><span class="sxs-lookup"><span data-stu-id="4a657-158">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="4a657-159">La différence entre le modèle de référentiel et le modèle de classe (classe de la couche DAL) accès aux données hérité</span><span class="sxs-lookup"><span data-stu-id="4a657-159">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="4a657-160">Un objet d’accès aux données exécute directement des opérations d’accès et la persistance des données sur le stockage.</span><span class="sxs-lookup"><span data-stu-id="4a657-160">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="4a657-161">Marques de référentiel les données avec les opérations que vous souhaitez effectuer dans la mémoire d’une unité de l’objet de travail (par exemple, EF lorsque vous utilisez le DbContext), mais ces mises à jour ne seront pas effectuées immédiatement.</span><span class="sxs-lookup"><span data-stu-id="4a657-161">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the DbContext), but these updates will not be performed immediately.</span></span>

<span data-ttu-id="4a657-162">Une unité de travail est appelée comme une unique transaction qui implique plusieurs insert, update ou delete operations.</span><span class="sxs-lookup"><span data-stu-id="4a657-162">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="4a657-163">En termes simples, cela signifie que, pour une action utilisateur spécifique (par exemple, l’inscription sur un site Web), tous les insert, update et delete transactions sont gérées dans une transaction unique.</span><span class="sxs-lookup"><span data-stu-id="4a657-163">In simple terms, it means that for a specific user action (for example, registration on a website), all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="4a657-164">Cela est plus efficace que la gestion des transactions de base de données multiples d’une manière chattier.</span><span class="sxs-lookup"><span data-stu-id="4a657-164">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="4a657-165">Ces opérations de persistance plusieurs seront effectuées ultérieurement en une seule action lorsque votre code à partir de la couche application commandes il.</span><span class="sxs-lookup"><span data-stu-id="4a657-165">These multiple persistence operations will be performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="4a657-166">La décision relative à l’application des modifications en mémoire pour le stockage de base de données est généralement basée sur le [modèle d’unité de travail](http://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="4a657-166">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](http://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="4a657-167">Dans EF, le modèle de l’unité de travail est implémenté en tant que le DBContext.</span><span class="sxs-lookup"><span data-stu-id="4a657-167">In EF, the Unit of Work pattern is implemented as the DBContext.</span></span>

<span data-ttu-id="4a657-168">Dans de nombreux cas, ce modèle ou la façon d’appliquer des opérations sur le stockage peut augmenter les performances de l’application et réduire le risque d’incohérences.</span><span class="sxs-lookup"><span data-stu-id="4a657-168">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="4a657-169">En outre, elle réduit le blocage dans les tables de base de données, de transaction, car toutes les opérations prévues sont validées dans le cadre d’une transaction.</span><span class="sxs-lookup"><span data-stu-id="4a657-169">Also, it reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="4a657-170">C’est plus efficace, par opposition à l’exécution de nombreuses opérations isolées par rapport à la base de données.</span><span class="sxs-lookup"><span data-stu-id="4a657-170">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="4a657-171">Par conséquent, le ORM sélectionné sera optimiser l’exécution par rapport à la base de données en regroupant plusieurs actions de mise à jour dans la même transaction, au lieu de plusieurs exécutions de transaction distincts et de petite taille.</span><span class="sxs-lookup"><span data-stu-id="4a657-171">Therefore, the selected ORM will be able to optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-should-not-be-mandatory"></a><span data-ttu-id="4a657-172">Référentiels ne doivent pas être obligatoires</span><span class="sxs-lookup"><span data-stu-id="4a657-172">Repositories should not be mandatory</span></span>

<span data-ttu-id="4a657-173">Les dépôts personnalisés sont utiles pour les raisons cités précédemment, et qui est l’approche pour le tri microservice dans eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="4a657-173">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="4a657-174">Toutefois, il n’est pas un modèle essentiel à implémenter dans une conception orientée ou même en général de développement dans .NET.</span><span class="sxs-lookup"><span data-stu-id="4a657-174">However, it is not an essential pattern to implement in a DDD design or even in general development in .NET.</span></span>

<span data-ttu-id="4a657-175">Par exemple, Jimmy Bogard, lorsque vous fournissez des commentaires directement dans ce guide, on dit que les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="4a657-175">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

<span data-ttu-id="4a657-176">Cela serez probablement mes commentaires plus grands.</span><span class="sxs-lookup"><span data-stu-id="4a657-176">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="4a657-177">Je ne suis vraiment pas un ventilateur de référentiels, principalement car ils masquent les détails importants du mécanisme de persistance sous-jacentes.</span><span class="sxs-lookup"><span data-stu-id="4a657-177">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="4a657-178">Son pourquoi passer pour MediatR pour les commandes, trop.</span><span class="sxs-lookup"><span data-stu-id="4a657-178">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="4a657-179">Je peux utiliser toute la puissance de la couche de persistance et transmettre des tout comportement de ce domaine à mes racines d’agrégat.</span><span class="sxs-lookup"><span data-stu-id="4a657-179">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="4a657-180">Je ne souhaite généralement simuler mes dépôts : j’ai encore besoin d’avoir que l’intégration test avec la réalité.</span><span class="sxs-lookup"><span data-stu-id="4a657-180">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="4a657-181">Va CQRS signifiait que nous n’a pas vraiment avez besoin pour les référentiels plus.</span><span class="sxs-lookup"><span data-stu-id="4a657-181">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="4a657-182">Nous trouver référentiels utile, mais nous reconnaissez qu’ils ne sont pas critiques pour votre DDD, dans la façon dont le modèle d’agrégation et le modèle de domaine complet.</span><span class="sxs-lookup"><span data-stu-id="4a657-182">We find repositories useful, but we acknowledge that they are not critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="4a657-183">Par conséquent, utilisez le modèle de référentiel ou non, comme vous le voir s’ajuster.</span><span class="sxs-lookup"><span data-stu-id="4a657-183">Therefore, use the Repository pattern or not, as you see fit.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="4a657-184">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="4a657-184">Additional resources</span></span>

##### <a name="the-repository-pattern"></a><span data-ttu-id="4a657-185">Le modèle de référentiel</span><span class="sxs-lookup"><span data-stu-id="4a657-185">The Repository pattern</span></span>

-   <span data-ttu-id="4a657-186">**Edward Hieatt et Rob me. Modèle de référentiel. ** 
     [ *http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="4a657-186">**Edward Hieatt and Rob Mee. Repository pattern.**
[*http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)</span></span>

-   <span data-ttu-id="4a657-187">**Le modèle de référentiel**
    [*https://msdn.microsoft.com/en-us/library/ff649690.aspx*](https://msdn.microsoft.com/en-us/library/ff649690.aspx)</span><span class="sxs-lookup"><span data-stu-id="4a657-187">**The Repository pattern**
[*https://msdn.microsoft.com/en-us/library/ff649690.aspx*](https://msdn.microsoft.com/en-us/library/ff649690.aspx)</span></span>

-   <span data-ttu-id="4a657-188">**Modèle de référentiel : Une persistance abstraction de données**
    [*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="4a657-188">**Repository Pattern: A data persistence abstraction**
[*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span></span>

-   <span data-ttu-id="4a657-189">**Eric Evans. Conception domaine : Tackling Complexity in the Heart of Software.**</span><span class="sxs-lookup"><span data-stu-id="4a657-189">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="4a657-190">(Livre et en savoir plus sur le modèle de référentiel) [ *https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="4a657-190">(Book; includes a discussion of the Repository pattern) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

##### <a name="unit-of-work-pattern"></a><span data-ttu-id="4a657-191">Unité de modèle de travail</span><span class="sxs-lookup"><span data-stu-id="4a657-191">Unit of Work pattern</span></span>

-   <span data-ttu-id="4a657-192">**Martin Fowler. Unité de modèle de travail. ** 
     [ *http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="4a657-192">**Martin Fowler. Unit of Work pattern.**
[*http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

<!-- -->

-   <span data-ttu-id="4a657-193">**Implémentation du référentiel et une unité de travail des modèles dans une Application ASP.NET MVC**
    [*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/ Implementing-the-Repository-and-Unit-of-Work-Patterns-in-an-ASP-NET-MVC-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span><span class="sxs-lookup"><span data-stu-id="4a657-193">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="4a657-194">[Précédente] (domaine-événements-design-implementation.md) [suivant] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="4a657-194">[Previous] (domain-events-design-implementation.md) [Next] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
