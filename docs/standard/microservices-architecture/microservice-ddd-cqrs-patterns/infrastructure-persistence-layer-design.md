---
title: Conception de la couche de persistance de l’infrastructure
description: Découvrez comment concevoir la couche de persistance de l’infrastructure.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 06/28/2017
ms.openlocfilehash: a0fcaead363e41f0dd02ed1e2ddfc90afb8d0c57
ms.sourcegitcommit: 4c158beee818c408d45a9609bfc06f209a523e22
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/03/2018
ms.locfileid: "37404471"
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="648a6-103">Conception de la couche de persistance de l’infrastructure</span><span class="sxs-lookup"><span data-stu-id="648a6-103">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="648a6-104">Les composants de persistance des données fournissent l’accès aux données hébergées dans les limites d’un microservice (autrement dit, la base de données d’un microservice).</span><span class="sxs-lookup"><span data-stu-id="648a6-104">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="648a6-105">Ils contiennent l’implémentation réelle des composants tels que les dépôts et les classes d’[unité de travail](https://martinfowler.com/eaaCatalog/unitOfWork.html), comme les objets <xref:Microsoft.EntityFrameworkCore.DbContext> Entity Framework (EF) personnalisés.</span><span class="sxs-lookup"><span data-stu-id="648a6-105">They contain the actual implementation of components such as repositories and [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> objects.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="648a6-106">Le modèle Dépôt</span><span class="sxs-lookup"><span data-stu-id="648a6-106">The Repository pattern</span></span>

<span data-ttu-id="648a6-107">Les dépôts sont des classes ou composants qui encapsulent la logique nécessaire pour accéder aux sources de données.</span><span class="sxs-lookup"><span data-stu-id="648a6-107">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="648a6-108">Ils centralisent les fonctionnalités d’accès aux données communes, en fournissant une meilleure maintenabilité et en découplant l’infrastructure ou la technologie utilisée pour accéder aux bases de données à partir de la couche du modèle de domaine.</span><span class="sxs-lookup"><span data-stu-id="648a6-108">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="648a6-109">Si vous utilisez un mappage relationnel objet (ORM) comme Entity Framework, le code à implémenter est simplifié grâce à LINQ et à un typage fort.</span><span class="sxs-lookup"><span data-stu-id="648a6-109">If you use an object-relational mapping (ORM) like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="648a6-110">Ainsi, vous pouvez vous concentrer sur la logique de persistance des données plutôt que sur le raccordement de l’accès aux données.</span><span class="sxs-lookup"><span data-stu-id="648a6-110">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="648a6-111">Le modèle Dépôt est une façon bien décrite d’utiliser une source de données.</span><span class="sxs-lookup"><span data-stu-id="648a6-111">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="648a6-112">Dans l’ouvrage [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler décrit un dépôt comme suit :</span><span class="sxs-lookup"><span data-stu-id="648a6-112">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

> <span data-ttu-id="648a6-113">Un dépôt effectue les tâches d’un intermédiaire entre les couches du modèle de domaine et le mappage de données, en agissant d’une manière similaire à un ensemble d’objets de domaine dans la mémoire.</span><span class="sxs-lookup"><span data-stu-id="648a6-113">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="648a6-114">Les objets clients génèrent des requêtes de façon déclarative et les envoient aux dépôts pour obtenir des réponses.</span><span class="sxs-lookup"><span data-stu-id="648a6-114">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="648a6-115">D’un point de vue conceptuel, un dépôt encapsule un ensemble d’objets stockés dans la base de données et les opérations pouvant être effectuées sur ces derniers, en fournissant un moyen plus proche de la couche de persistance.</span><span class="sxs-lookup"><span data-stu-id="648a6-115">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="648a6-116">Les dépôts, par ailleurs, prennent en charge l’objectif de séparation, claire et dans un seul sens, de la dépendance entre le domaine de travail et l’allocation ou le mappage de données.</span><span class="sxs-lookup"><span data-stu-id="648a6-116">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="648a6-117">Définir un seul dépôt par agrégat</span><span class="sxs-lookup"><span data-stu-id="648a6-117">Define one repository per aggregate</span></span>

<span data-ttu-id="648a6-118">Pour chaque agrégat ou racine d’agrégat, vous devez créer une seule classe de dépôt.</span><span class="sxs-lookup"><span data-stu-id="648a6-118">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="648a6-119">Dans un microservice basé sur des modèles de conception pilotée par le domaine (DDD, Domain-Driven Design), le seul canal que vous devez utiliser pour mettre à jour la base de données doit être les dépôts.</span><span class="sxs-lookup"><span data-stu-id="648a6-119">In a microservice based on domain-driven design (DDD) patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="648a6-120">En effet, ils ont une relation un-à-un avec la racine d’agrégat, qui contrôle les invariants et la cohérence transactionnelle de l’agrégat.</span><span class="sxs-lookup"><span data-stu-id="648a6-120">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="648a6-121">Il est possible d’interroger la base de données par le biais d’autres canaux (selon une approche CQRS par exemple), car les requêtes ne changent pas l’état de la base de données.</span><span class="sxs-lookup"><span data-stu-id="648a6-121">It's okay to query the database through other channels (as you can do following a CQRS approach), because queries don't change the state of the database.</span></span> <span data-ttu-id="648a6-122">Toutefois, la zone transactionnelle (à savoir les mises à jour) doit toujours être contrôlée par les dépôts et les racines d’agrégat.</span><span class="sxs-lookup"><span data-stu-id="648a6-122">However, the transactional area (that is, the updates) must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="648a6-123">En bref, un dépôt vous permet de renseigner les données en mémoire provenant de la base de données sous la forme d’entités de domaine.</span><span class="sxs-lookup"><span data-stu-id="648a6-123">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="648a6-124">Une fois que les entités sont en mémoire, elles peuvent être modifiées et de nouveau rendues persistantes dans la base de données par le biais de transactions.</span><span class="sxs-lookup"><span data-stu-id="648a6-124">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="648a6-125">Comme indiqué précédemment, si vous utilisez le modèle architectural CQS/CQRS, les requêtes initiales sont effectuées par des requêtes latérales en dehors du modèle de domaine, effectuées par de simples instructions SQL à l’aide de Dapper.</span><span class="sxs-lookup"><span data-stu-id="648a6-125">As noted earlier, if you're using the CQS/CQRS architectural pattern, the initial queries are performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="648a6-126">Cette approche est beaucoup plus souple que les dépôts, car vous pouvez interroger et joindre les tables dont vous avez besoin, et ces requêtes ne sont pas limitées par des règles issues des agrégats.</span><span class="sxs-lookup"><span data-stu-id="648a6-126">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries aren't restricted by rules from the aggregates.</span></span> <span data-ttu-id="648a6-127">Ces données accèdent à la couche présentation ou à l’application cliente.</span><span class="sxs-lookup"><span data-stu-id="648a6-127">That data goes to the presentation layer or client app.</span></span>

<span data-ttu-id="648a6-128">Si l’utilisateur apporte des modifications, les données à mettre à jour passent de l’application cliente ou de la couche présentation à la couche Application (comme un service API web).</span><span class="sxs-lookup"><span data-stu-id="648a6-128">If the user makes changes, the data to be updated comes from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="648a6-129">Quand vous recevez une commande avec des données dans un gestionnaire de commandes, vous utilisez des dépôts pour obtenir les données à mettre à jour à partir de la base de données.</span><span class="sxs-lookup"><span data-stu-id="648a6-129">When you receive a command with data in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="648a6-130">Vous les mettez à jour dans la mémoire avec les informations passées avec les commandes, puis vous ajoutez ou mettez à jour les données (entités de domaine) dans la base de données par le biais d’une transaction.</span><span class="sxs-lookup"><span data-stu-id="648a6-130">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="648a6-131">N’oubliez pas qu’un seul dépôt doit être défini pour chaque racine d’agrégat, comme l’illustre la figure 9-17.</span><span class="sxs-lookup"><span data-stu-id="648a6-131">Remember that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="648a6-132">Pour atteindre l’objectif de la racine d’agrégat visant à maintenir la cohérence transactionnelle entre tous les objets au sein de l’agrégat, vous ne devez jamais créer un dépôt pour chaque table dans la base de données.</span><span class="sxs-lookup"><span data-stu-id="648a6-132">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="648a6-133">**Figure 9-17**.</span><span class="sxs-lookup"><span data-stu-id="648a6-133">**Figure 9-17**.</span></span> <span data-ttu-id="648a6-134">Relation entre les dépôts, les agrégats et les tables de base de données</span><span class="sxs-lookup"><span data-stu-id="648a6-134">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="648a6-135">Appliquer une seule racine d’agrégat par dépôt</span><span class="sxs-lookup"><span data-stu-id="648a6-135">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="648a6-136">Il peut s’avérer très utile d’implémenter votre conception de dépôt de sorte à faire respecter la règle stipulant que seules les racines d’agrégat doivent avoir des dépôts.</span><span class="sxs-lookup"><span data-stu-id="648a6-136">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="648a6-137">Vous pouvez créer un type de dépôt générique ou élémentaire qui limite le type des entités utilisées pour veiller à ce qu’elles aient l’interface de marqueur `IAggregateRoot`.</span><span class="sxs-lookup"><span data-stu-id="648a6-137">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the `IAggregateRoot` marker interface.</span></span>

<span data-ttu-id="648a6-138">Ainsi, chaque classe de dépôt implémentée au niveau de la couche d’infrastructure implémente son propre contrat ou sa propre interface, comme le montre le code suivant :</span><span class="sxs-lookup"><span data-stu-id="648a6-138">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
      // ...
    }
}
```

<span data-ttu-id="648a6-139">Chaque interface de dépôt spécifique implémente l’interface IRepository générique :</span><span class="sxs-lookup"><span data-stu-id="648a6-139">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="648a6-140">Toutefois, un meilleur moyen d’obliger le code à appliquer la convention selon laquelle chaque dépôt doit être lié à un seul agrégat consiste à implémenter un type de dépôt générique.</span><span class="sxs-lookup"><span data-stu-id="648a6-140">However, a better way to have the code enforce the convention that each repository is related to a single aggregate is to implement a generic repository type.</span></span> <span data-ttu-id="648a6-141">De cette façon, il est explicite que vous utilisez un dépôt pour cibler un agrégat spécifique.</span><span class="sxs-lookup"><span data-stu-id="648a6-141">That way, it's explicit that you're using a repository to target a specific aggregate.</span></span> <span data-ttu-id="648a6-142">Vous pouvez le faire facilement en implémentant une interface de base `IRepository` générique, comme dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="648a6-142">That can be easily done by implementing a generic `IRepository` base interface, as in the following code:</span></span>

```csharp
public interface IRepository<T> where T : IAggregateRoot
{
    //....
}
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="648a6-143">Le modèle Dépôt facilite le test de votre logique d’application</span><span class="sxs-lookup"><span data-stu-id="648a6-143">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="648a6-144">Le modèle Dépôt vous permet de tester facilement votre application avec des tests unitaires.</span><span class="sxs-lookup"><span data-stu-id="648a6-144">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="648a6-145">N’oubliez pas que les tests unitaires testent uniquement votre code, pas l’infrastructure, si bien que les abstractions de dépôt facilitent la réalisation de cet objectif.</span><span class="sxs-lookup"><span data-stu-id="648a6-145">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="648a6-146">Comme indiqué dans une section précédente, il est recommandé de définir et placer les interfaces de dépôt dans la couche du modèle de domaine pour que la couche Application telle que votre microservice d’API web, ne dépende pas directement de la couche d’infrastructure, dans laquelle vous avez implémenté les classes de dépôt réelles.</span><span class="sxs-lookup"><span data-stu-id="648a6-146">As noted in an earlier section, it's recommended that you define and place the repository interfaces in the domain model layer so the application layer, such as your Web API microservice, doesn't depend directly on the infrastructure layer where you've implemented the actual repository classes.</span></span> <span data-ttu-id="648a6-147">Ce faisant et à l’aide de l’injection de dépendances dans les contrôleurs de votre API web, vous pouvez implémenter des dépôts fictifs qui retournent de fausses données au lieu des données de la base de données.</span><span class="sxs-lookup"><span data-stu-id="648a6-147">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="648a6-148">Cette approche découplée vous permet de créer et d’exécuter des tests unitaires permettant de tester seulement la logique de votre application sans nécessiter de connectivité à la base de données.</span><span class="sxs-lookup"><span data-stu-id="648a6-148">This decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="648a6-149">Les connexions aux bases de données peuvent échouer et, ce qui est plus important, l’exécution de centaines de tests sur une base de données est mauvaise pour deux raisons.</span><span class="sxs-lookup"><span data-stu-id="648a6-149">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="648a6-150">Tout d’abord, elle peut s’avérer très chronophage en raison du grand nombre de tests.</span><span class="sxs-lookup"><span data-stu-id="648a6-150">First, it can take a long time because of the large number of tests.</span></span> <span data-ttu-id="648a6-151">Ensuite, les enregistrements de base de données peuvent changer et affecter les résultats de vos tests, qui peuvent ne pas être cohérents.</span><span class="sxs-lookup"><span data-stu-id="648a6-151">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="648a6-152">Un test sur la base de données n’est pas un test unitaire, mais un test d’intégration.</span><span class="sxs-lookup"><span data-stu-id="648a6-152">Testing against the database isn't a unit test but an integration test.</span></span> <span data-ttu-id="648a6-153">Vous devez effectuer de nombreux tests unitaires qui s’exécutent rapidement, mais un nombre moindre de tests d’intégration sur les bases de données.</span><span class="sxs-lookup"><span data-stu-id="648a6-153">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="648a6-154">En termes de séparation des responsabilités pour les tests unitaires, votre logique s’exécute sur des entités de domaine dans la mémoire.</span><span class="sxs-lookup"><span data-stu-id="648a6-154">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="648a6-155">Elle suppose que la classe de dépôt les a remises.</span><span class="sxs-lookup"><span data-stu-id="648a6-155">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="648a6-156">Une fois que votre logique modifie les entités de domaine, elle suppose que la classe de dépôt les stocke correctement.</span><span class="sxs-lookup"><span data-stu-id="648a6-156">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="648a6-157">Il est important de créer des tests unitaires sur votre modèle de domaine et sa logique de domaine.</span><span class="sxs-lookup"><span data-stu-id="648a6-157">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="648a6-158">Les racines d’agrégat correspondent aux limites de cohérence principales dans la conception DDD.</span><span class="sxs-lookup"><span data-stu-id="648a6-158">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="648a6-159">La différence entre le modèle Dépôt et le modèle de la classe d’accès aux données héritée (classe DAL)</span><span class="sxs-lookup"><span data-stu-id="648a6-159">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="648a6-160">Un objet d’accès aux données exécute directement des opérations d’accès aux données et de persistance des données dans le stockage.</span><span class="sxs-lookup"><span data-stu-id="648a6-160">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="648a6-161">Un dépôt marque les données avec les opérations à effectuer dans la mémoire d’une unité d’objet de travail (comme dans EF lorsque vous utilisez la classe <xref:Microsoft.EntityFrameworkCore.DbContext>), mais ces mises à jour ne sont pas effectuées immédiatement.</span><span class="sxs-lookup"><span data-stu-id="648a6-161">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the <xref:Microsoft.EntityFrameworkCore.DbContext> class), but these updates aren't performed immediately.</span></span>

<span data-ttu-id="648a6-162">Une unité de travail est définie comme une transaction unique qui implique plusieurs opérations d’insertion, de mise à jour ou de suppression.</span><span class="sxs-lookup"><span data-stu-id="648a6-162">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="648a6-163">En termes simples, cela signifie que, pour une action utilisateur spécifique, telle qu’une inscription sur un site web, toutes les transactions d’insertion, de mise à jour et de suppression sont gérées dans une transaction unique.</span><span class="sxs-lookup"><span data-stu-id="648a6-163">In simple terms, it means that for a specific user action, such as a registration on a website, all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="648a6-164">Une telle gestion est plus efficace que de gérer plusieurs transactions de base de données d’une manière plus bavarde.</span><span class="sxs-lookup"><span data-stu-id="648a6-164">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="648a6-165">Ces multiples opérations de persistance sont effectuées ultérieurement en une seule action quand votre code de la couche Application la commande.</span><span class="sxs-lookup"><span data-stu-id="648a6-165">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="648a6-166">La décision d’appliquer les modifications en mémoire au stockage réel de la base de données se base généralement sur le [modèle Unité de travail](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="648a6-166">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="648a6-167">Dans EF, le modèle Unité de travail est implémenté en tant que <xref:Microsoft.EntityFrameworkCore.DbContext>.</span><span class="sxs-lookup"><span data-stu-id="648a6-167">In EF, the Unit of Work pattern is implemented as the <xref:Microsoft.EntityFrameworkCore.DbContext>.</span></span>

<span data-ttu-id="648a6-168">Dans de nombreux cas, ce modèle ou cette façon d’appliquer des opérations dans le stockage peut augmenter les performances de l’application et réduire le risque d’incohérences.</span><span class="sxs-lookup"><span data-stu-id="648a6-168">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="648a6-169">Cela réduit également le blocage des transactions dans les tables de base de données, car toutes les opérations prévues sont validées dans le cadre d’une seule transaction.</span><span class="sxs-lookup"><span data-stu-id="648a6-169">It also reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="648a6-170">Ce modèle est plus efficace que l’exécution de nombreuses opérations isolées sur la base de données.</span><span class="sxs-lookup"><span data-stu-id="648a6-170">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="648a6-171">Par conséquent, le mappage relationnel objet (ORM) sélectionné peut optimiser l’exécution sur la base de données en regroupant plusieurs actions de mise à jour au sein de la même transaction, au lieu d’exécuter de nombreuses transactions distinctes de petite taille.</span><span class="sxs-lookup"><span data-stu-id="648a6-171">Therefore, the selected ORM can optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-shouldnt-be-mandatory"></a><span data-ttu-id="648a6-172">Les dépôts ne doivent pas être obligatoires</span><span class="sxs-lookup"><span data-stu-id="648a6-172">Repositories shouldn't be mandatory</span></span>

<span data-ttu-id="648a6-173">Les dépôts personnalisés sont utiles pour les raisons citées précédemment. C’est l’approche utilisée pour le microservice de passation de commandes dans eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="648a6-173">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="648a6-174">Toutefois, il ne s’agit pas d’un modèle essentiel à implémenter dans une conception DDD ni même dans le cadre d’un développement .NET général.</span><span class="sxs-lookup"><span data-stu-id="648a6-174">However, it isn't an essential pattern to implement in a DDD design or even in general .NET development.</span></span>

<span data-ttu-id="648a6-175">Par exemple, Jimmy Bogard, en commentant directement le présent guide, a tenu les propos suivants :</span><span class="sxs-lookup"><span data-stu-id="648a6-175">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

> <span data-ttu-id="648a6-176">Ces commentaires seront probablement mes plus longs.</span><span class="sxs-lookup"><span data-stu-id="648a6-176">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="648a6-177">Je ne suis vraiment pas fan des dépôts, principalement parce qu’ils cachent les détails importants du mécanisme de persistance sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="648a6-177">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="648a6-178">C’est pour cela que je préfère MediatR pour les commandes, aussi.</span><span class="sxs-lookup"><span data-stu-id="648a6-178">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="648a6-179">Je peux utiliser toute la puissance de la couche de persistance et transmettre tout ce comportement de domaine à mes racines d’agrégat.</span><span class="sxs-lookup"><span data-stu-id="648a6-179">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="648a6-180">En général, je ne veux pas simuler mes dépôts. J’ai quand même besoin de confronter ce test d’intégration avec la réalité.</span><span class="sxs-lookup"><span data-stu-id="648a6-180">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="648a6-181">L’adoption de CQRS signifie que nous n’avons plus vraiment besoin des dépôts.</span><span class="sxs-lookup"><span data-stu-id="648a6-181">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="648a6-182">Les dépôts sont utiles, mais ils ne sont pas essentiels pour votre DDD, comme le sont le modèle Agrégat et le modèle de domaine riche.</span><span class="sxs-lookup"><span data-stu-id="648a6-182">Repositories are useful, but they aren't critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="648a6-183">Par conséquent, utilisez le modèle Dépôt ou ne l’utilisez pas, en fonction de vos besoins.</span><span class="sxs-lookup"><span data-stu-id="648a6-183">Therefore, use the Repository pattern or not, as you see fit.</span></span>

## <a name="the-specification-pattern"></a><span data-ttu-id="648a6-184">Le modèle Spécification</span><span class="sxs-lookup"><span data-stu-id="648a6-184">The Specification pattern</span></span>

<span data-ttu-id="648a6-185">Le modèle de spécification (son nom complet est modèle Spécification de requêtes) est un modèle DDD conçu comme l’emplacement où vous pouvez placer la définition d’une requête avec une éventuelle logique de tri et de pagination.</span><span class="sxs-lookup"><span data-stu-id="648a6-185">The specification pattern (its full name would be Query-specification pattern) is a DDD pattern designed as the place where you can put the definition of a query with optional sorting and paging logic.</span></span>

<span data-ttu-id="648a6-186">Le modèle de spécification définit une requête dans un objet.</span><span class="sxs-lookup"><span data-stu-id="648a6-186">The specification pattern defines a query in an object.</span></span> <span data-ttu-id="648a6-187">Par exemple, pour encapsuler une requête paginée qui recherche certains produits, vous pouvez créer une spécification `PagedProduct` qui accepte les paramètres d’entrée nécessaires, tels que `pageNumber`, `pageSize`, `filter`, etc. Ensuite, au sein de toute méthode de dépôt (généralement une surcharge List()), elle peut accepter une `ISpecification` et exécuter la requête prévue en fonction de cette spécification.</span><span class="sxs-lookup"><span data-stu-id="648a6-187">For example, to encapsulate a paged query that searches for some products, you can create a `PagedProduct` specification that takes the necessary input parameters, such as `pageNumber`, `pageSize`, `filter`, etc. Then, within any Repository method (usually a List() overload), it'd accept an `ISpecification` and run the expected query based on that specification.</span></span>

<span data-ttu-id="648a6-188">Il existe plusieurs avantages à cette approche :</span><span class="sxs-lookup"><span data-stu-id="648a6-188">There are several benefits to this approach:</span></span>

- <span data-ttu-id="648a6-189">La spécification porte un nom (par opposition à une simple série d’expressions LINQ) dont vous pouvez discuter.</span><span class="sxs-lookup"><span data-stu-id="648a6-189">The specification has a name (as opposed to just a bunch of LINQ expressions) that you can discuss about.</span></span>

- <span data-ttu-id="648a6-190">La spécification peut faire l’objet d’un test unitaire de manière isolée pour vérifier qu’elle est correcte.</span><span class="sxs-lookup"><span data-stu-id="648a6-190">The specification can be unit tested in isolation to ensure it's right.</span></span> <span data-ttu-id="648a6-191">Elle peut aussi être réutilisée facilement si vous avez besoin d’un comportement similaire.</span><span class="sxs-lookup"><span data-stu-id="648a6-191">It can also easily be reused if you need similar behavior.</span></span> <span data-ttu-id="648a6-192">Par exemple, sur une action de vue MVC et une action d’API web, ainsi que dans divers services.</span><span class="sxs-lookup"><span data-stu-id="648a6-192">For example, on an MVC View action and a Web API action, as well as in various services.</span></span>

- <span data-ttu-id="648a6-193">Une spécification peut également servir à décrire la forme des données à retourner, afin que les requêtes puissent retourner uniquement les données requises.</span><span class="sxs-lookup"><span data-stu-id="648a6-193">A specification can also be used to describe the shape of the data to be returned, so that queries can return just the data they required.</span></span> <span data-ttu-id="648a6-194">Le besoin de chargement différé est ainsi éliminé dans les applications web, ce qui n’est généralement recommandé, et les implémentations de dépôt ne s’encombrent pas avec ces détails.</span><span class="sxs-lookup"><span data-stu-id="648a6-194">This eliminates the need for lazy loading in web applications, which is usually not recommended, and helps keep repository implementations from becoming cluttered with these details.</span></span>

<span data-ttu-id="648a6-195">Le code suivant issu d’[eShopOnweb](https://github.com/dotnet-architecture/eShopOnWeb) est un exemple d’interface de spécification générique.</span><span class="sxs-lookup"><span data-stu-id="648a6-195">An example of a generic specification interface is the following code from [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb).</span></span>

```csharp
// https://github.com/dotnet-architecture/eShopOnWeb
public interface ISpecification<T>
{
    Expression<Func<T, bool>> Criteria { get; }
    List<Expression<Func<T, object>>> Includes { get; }
    List<string> IncludeStrings { get; }
}
```

<span data-ttu-id="648a6-196">Les sections ci-après expliquent la manière d’implémenter le modèle de spécification avec EF Core 2.x et la manière de l’utiliser à partir d’une classe de dépôt.</span><span class="sxs-lookup"><span data-stu-id="648a6-196">The upcoming sections explain how to implement the specification pattern with EF Core 2.x and how to use it from any Repository class.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="648a6-197">Le modèle de spécification est un ancien modèle qui peut être implémenté de différentes façons, comme dans les ressources supplémentaires suivantes.</span><span class="sxs-lookup"><span data-stu-id="648a6-197">The specification pattern is an old pattern that can be implemented in many different ways, as in the following additional resources.</span></span> <span data-ttu-id="648a6-198">En tant que modèle/idée, les approches plus anciennes sont bonnes à savoir, mais méfiez-vous des implémentations plus anciennes qui n’exploitent pas les fonctionnalités des langages modernes comme Linq et les expressions.</span><span class="sxs-lookup"><span data-stu-id="648a6-198">As a pattern/idea, older approaches are good to know, but beware of older implementations that are not taking advantage of modern language capabilities like Linq and expressions.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="648a6-199">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="648a6-199">Additional resources</span></span>

### <a name="the-repository-pattern"></a><span data-ttu-id="648a6-200">Le modèle Dépôt</span><span class="sxs-lookup"><span data-stu-id="648a6-200">The Repository pattern</span></span>

- <span data-ttu-id="648a6-201">**Modèle Dépôt**
  [https://deviq.com/repository-pattern/](https://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="648a6-201">**The Repository pattern**
[https://deviq.com/repository-pattern/](https://deviq.com/repository-pattern/)</span></span>

- <span data-ttu-id="648a6-202">**Edward Hieatt et Rob Mee. Repository pattern.**
  [_https://martinfowler.com/eaaCatalog/repository.html_](https://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="648a6-202">**Edward Hieatt and Rob Mee. Repository pattern.**
[_https://martinfowler.com/eaaCatalog/repository.html_](https://martinfowler.com/eaaCatalog/repository.html)</span></span>

- <span data-ttu-id="648a6-203">**The Repository pattern**
  [_https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)_](https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10))</span><span class="sxs-lookup"><span data-stu-id="648a6-203">**The Repository pattern**
[_https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)_](https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10))</span></span>

- <span data-ttu-id="648a6-204">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span><span class="sxs-lookup"><span data-stu-id="648a6-204">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="648a6-205">(Book; includes a discussion of the Repository pattern) [_https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/_](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="648a6-205">(Book; includes a discussion of the Repository pattern) [_https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/_](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="648a6-206">Modèle Unité de travail</span><span class="sxs-lookup"><span data-stu-id="648a6-206">Unit of Work pattern</span></span>

- <span data-ttu-id="648a6-207">**Martin Fowler. Unit of Work pattern.**
  [_https://martinfowler.com/eaaCatalog/unitOfWork.html_](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="648a6-207">**Martin Fowler. Unit of Work pattern.**
[_https://martinfowler.com/eaaCatalog/unitOfWork.html_](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

- <span data-ttu-id="648a6-208">**Implémentation du dépôt et des modèles d’unité de travail dans une application ASP.NET MVC**
  [_https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application_](https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span><span class="sxs-lookup"><span data-stu-id="648a6-208">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[_https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application_](https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>

### <a name="the-specification-pattern"></a><span data-ttu-id="648a6-209">Le modèle Spécification</span><span class="sxs-lookup"><span data-stu-id="648a6-209">The Specification pattern</span></span>

- <span data-ttu-id="648a6-210">**The Specification pattern.**
  [_https://deviq.com/specification-pattern/_](https://deviq.com/specification-pattern/)</span><span class="sxs-lookup"><span data-stu-id="648a6-210">**The Specification pattern.**
[_https://deviq.com/specification-pattern/_](https://deviq.com/specification-pattern/)</span></span>

- <span data-ttu-id="648a6-211">**Evans, Eric (2004). Domain Driven Design. Addison-Wesley. p. 224.**</span><span class="sxs-lookup"><span data-stu-id="648a6-211">**Evans, Eric (2004). Domain Driven Design. Addison-Wesley. p. 224.**</span></span>

- <span data-ttu-id="648a6-212">**Specifications. Martin Fowler**
  [_https://www.martinfowler.com/apsupp/spec.pdf/_](https://www.martinfowler.com/apsupp/spec.pdf)</span><span class="sxs-lookup"><span data-stu-id="648a6-212">**Specifications. Martin Fowler**
[_https://www.martinfowler.com/apsupp/spec.pdf/_](https://www.martinfowler.com/apsupp/spec.pdf)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="648a6-213">[Précédent](domain-events-design-implementation.md)
[Suivant](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="648a6-213">[Previous](domain-events-design-implementation.md)
[Next](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
