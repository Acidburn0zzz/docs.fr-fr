---
title: "Application simplifiée des modèles CQRS et DDD dans un microservice."
description: "Architecture de Microservices .NET pour les Applications .NET en conteneur | Application simplifiée des modèles CQRS et DDD dans un microservice."
keywords: Docker, microservices, ASP.NET, conteneur
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 99fd7ce32039742e23f8e01aa4c33cddd7a9f698
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/18/2017
---
# <a name="applying-simplified-cqrs-and-ddd-patterns-in-a-microservice"></a><span data-ttu-id="4def4-104">Application simplifiée des modèles CQRS et DDD dans un microservice.</span><span class="sxs-lookup"><span data-stu-id="4def4-104">Applying simplified CQRS and DDD patterns in a microservice</span></span>

<span data-ttu-id="4def4-105">CQRS est un modèle d’architecture qui sépare les modèles pour lire et écrire des données.</span><span class="sxs-lookup"><span data-stu-id="4def4-105">CQRS is an architectural pattern that separates the models for reading and writing data.</span></span> <span data-ttu-id="4def4-106">Le terme connexe [séparation de requête de commande (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) a été initialement définie par Bertrand Meyer dans son livre *Construction de logiciel orienté objet*.</span><span class="sxs-lookup"><span data-stu-id="4def4-106">The related term [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) was originally defined by Bertrand Meyer in his book *Object Oriented Software Construction*.</span></span> <span data-ttu-id="4def4-107">L’idée est que vous pouvez diviser les opérations d’un système en deux catégories nettement séparées :</span><span class="sxs-lookup"><span data-stu-id="4def4-107">The basic idea is that you can divide a system’s operations into two sharply separated categories:</span></span>

-   <span data-ttu-id="4def4-108">Requêtes.</span><span class="sxs-lookup"><span data-stu-id="4def4-108">Queries.</span></span> <span data-ttu-id="4def4-109">Ces retournent un résultat et que vous ne modifiez pas l’état du système, et ils ne contiennent pas d’effets secondaires.</span><span class="sxs-lookup"><span data-stu-id="4def4-109">These return a result and do not change the state of the system, and they are free of side effects.</span></span>

-   <span data-ttu-id="4def4-110">Commandes.</span><span class="sxs-lookup"><span data-stu-id="4def4-110">Commands.</span></span> <span data-ttu-id="4def4-111">Ces modifications de l’état d’un système.</span><span class="sxs-lookup"><span data-stu-id="4def4-111">These change the state of a system.</span></span>

<span data-ttu-id="4def4-112">CQS est un concept simple : il s’agit de méthodes dans le même objet en cours de requêtes ou commandes.</span><span class="sxs-lookup"><span data-stu-id="4def4-112">CQS is a simple concept—it is about methods within the same object being either queries or commands.</span></span> <span data-ttu-id="4def4-113">Chaque méthode retourne l’état ou mute, état, mais pas les deux.</span><span class="sxs-lookup"><span data-stu-id="4def4-113">Each method either returns state or mutates state, but not both.</span></span> <span data-ttu-id="4def4-114">Même un objet de modèle de référentiel unique peut respecter CQS.</span><span class="sxs-lookup"><span data-stu-id="4def4-114">Even a single repository pattern object can comply with CQS.</span></span> <span data-ttu-id="4def4-115">CQS peut être considéré comme un principe fondamental pour CQRS.</span><span class="sxs-lookup"><span data-stu-id="4def4-115">CQS can be considered a foundational principle for CQRS.</span></span>

<span data-ttu-id="4def4-116">[Commande et répartition de responsabilité de requête (CQRS)](https://martinfowler.com/bliki/CQRS.html) a été introduite par Greg Young et fortement promue par Udi Dahan et d’autres.</span><span class="sxs-lookup"><span data-stu-id="4def4-116">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly promoted by Udi Dahan and others.</span></span> <span data-ttu-id="4def4-117">Il est basé sur le principe CQS, bien qu’il est plus détaillée.</span><span class="sxs-lookup"><span data-stu-id="4def4-117">It is based on the CQS principle, although it is more detailed.</span></span> <span data-ttu-id="4def4-118">Il peut être considéré comme un modèle basé sur les commandes et les événements et éventuellement de messages asynchrones.</span><span class="sxs-lookup"><span data-stu-id="4def4-118">It can be considered a pattern based on commands and events plus optionally on asynchronous messages.</span></span> <span data-ttu-id="4def4-119">Dans de nombreux cas, CQRS est lié à des scénarios plus avancés, comme une base de données physique pour les lectures (requêtes) que pour les écritures (mises à jour).</span><span class="sxs-lookup"><span data-stu-id="4def4-119">In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates).</span></span> <span data-ttu-id="4def4-120">En outre, un système CQRS plus ont évolué peut implémenter [(ES) événement rurale](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/) pour votre base de données mises à jour, par conséquent, vous serez uniquement stocker les événements dans le modèle de domaine au lieu de stocker les données d’état actuel.</span><span class="sxs-lookup"><span data-stu-id="4def4-120">Moreover, a more evolved CQRS system might implement [Event-Sourcing (ES)](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/) for your updates database, so you would only store events in the domain model instead of storing the current-state data.</span></span> <span data-ttu-id="4def4-121">Toutefois, cela n’est pas l’approche utilisée dans ce guide ; Nous utilisons l’approche la plus simple de la CQRS, qui se compose uniquement de séparer les requêtes à partir des commandes.</span><span class="sxs-lookup"><span data-stu-id="4def4-121">However, this is not the approach used in this guide; we are using the simplest CQRS approach, which consists of just separating the queries from the commands.</span></span>

<span data-ttu-id="4def4-122">L’aspect de séparation de CQRS est obtenue en regroupant les opérations de requête dans une couche et les commandes dans une autre couche.</span><span class="sxs-lookup"><span data-stu-id="4def4-122">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer.</span></span> <span data-ttu-id="4def4-123">Chaque couche possède son propre modèle de données (Notez que nous dire le modèle, pas nécessairement une base de données) et est construit à l’aide de sa propre combinaison de technologies et de modèles.</span><span class="sxs-lookup"><span data-stu-id="4def4-123">Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies.</span></span> <span data-ttu-id="4def4-124">Plus important encore, les deux couches peuvent être dans le même niveau ou microservice, comme dans l’exemple (classement microservice) utilisé dans ce guide.</span><span class="sxs-lookup"><span data-stu-id="4def4-124">More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide.</span></span> <span data-ttu-id="4def4-125">Ou peut être implémentés sur microservices différents ou des processus afin de pouvoir être optimisés et monté en charge séparément sans affecter les unes des autres.</span><span class="sxs-lookup"><span data-stu-id="4def4-125">Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</span></span>

<span data-ttu-id="4def4-126">CQRS implique deux objets pour une opération de lecture/écriture où dans d’autres contextes existe.</span><span class="sxs-lookup"><span data-stu-id="4def4-126">CQRS means having two objects for a read/write operation where in other contexts there is one.</span></span> <span data-ttu-id="4def4-127">Il existe des raisons d’avoir une base de données dénormalisées lectures, vous pouvez en savoir plus sur dans la documentation CQRS plus avancée.</span><span class="sxs-lookup"><span data-stu-id="4def4-127">There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature.</span></span> <span data-ttu-id="4def4-128">Mais nous n’utilisons pas cette approche ici, où l’objectif est d’avoir plus de souplesse dans les requêtes au lieu de limiter les requêtes avec des contraintes à partir de modèles DDD comme agrégats.</span><span class="sxs-lookup"><span data-stu-id="4def4-128">But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</span></span>

<span data-ttu-id="4def4-129">Un exemple de ce type de service est le tri microservice à partir de l’application de référence eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="4def4-129">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application.</span></span> <span data-ttu-id="4def4-130">Ce service implémente un microservice basé sur une approche CQRS simplifiée.</span><span class="sxs-lookup"><span data-stu-id="4def4-130">This service implements a microservice based on a simplified CQRS approach.</span></span> <span data-ttu-id="4def4-131">Il utilise une source de données ou base de données, mais deux modèles logiques plus les modèles DDD pour le domaine transactionnels, comme illustré dans la Figure 9-2.</span><span class="sxs-lookup"><span data-stu-id="4def4-131">It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 9-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="4def4-132">**Figure 9-2**.</span><span class="sxs-lookup"><span data-stu-id="4def4-132">**Figure 9-2**.</span></span> <span data-ttu-id="4def4-133">Simplifiée CQRS et DDD basés sur un microservice</span><span class="sxs-lookup"><span data-stu-id="4def4-133">Simplified CQRS- and DDD-based microservice</span></span>

<span data-ttu-id="4def4-134">La couche application peut être l’API Web elle-même.</span><span class="sxs-lookup"><span data-stu-id="4def4-134">The application layer can be the Web API itself.</span></span> <span data-ttu-id="4def4-135">L’aspect de conception importante ici est que le microservice a fractionne les requêtes et les ViewModel (modèles de données créés spécialement pour les applications clientes) à partir des commandes, de modèle de domaine et de transactions suivant le modèle CQRS.</span><span class="sxs-lookup"><span data-stu-id="4def4-135">The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</span></span> <span data-ttu-id="4def4-136">Cette approche permet de conserver les requêtes indépendante de restrictions et les contraintes provenant des modèles DDD qui ne sont pertinentes pour les transactions et les mises à jour, comme expliqué dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="4def4-136">This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="4def4-137">[Précédente] (index.md) [suivant] (eshoponcontainers-cqrs-ddd-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="4def4-137">[Previous] (index.md) [Next] (eshoponcontainers-cqrs-ddd-microservice.md)</span></span>
