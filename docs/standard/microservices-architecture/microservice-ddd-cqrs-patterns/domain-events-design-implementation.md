---
title: "Événements de domaine. Conception et implémentation"
description: "Architecture de Microservices .NET pour les Applications .NET en conteneur | Événements de domaine, de conception et implémentation"
keywords: Docker, microservices, ASP.NET, conteneur
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 2d98b302be4ee72d8225526944fc3e41cbadcb5f
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/18/2017
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="94c18-105">Événements de domaine : conception et implémentation</span><span class="sxs-lookup"><span data-stu-id="94c18-105">Domain events: design and implementation</span></span>

<span data-ttu-id="94c18-106">Événements de domaine permet d’implémenter explicitement des effets des modifications de votre domaine.</span><span class="sxs-lookup"><span data-stu-id="94c18-106">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="94c18-107">Dans d’autres mots et à l’aide de la terminologie DDD, utilisez les événements de domaine d’implémenter explicitement des effets secondaires sur plusieurs regroupements.</span><span class="sxs-lookup"><span data-stu-id="94c18-107">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="94c18-108">Si vous le souhaitez, pour une meilleure évolutivité et moins d’impact sur les verrous de base de données, utilisez la cohérence éventuelle entre les agrégats au sein du même domaine.</span><span class="sxs-lookup"><span data-stu-id="94c18-108">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="94c18-109">Qu’est un événement de domaine ?</span><span class="sxs-lookup"><span data-stu-id="94c18-109">What is a domain event?</span></span>

<span data-ttu-id="94c18-110">Un événement est un élément qui s’est produite dans le passé.</span><span class="sxs-lookup"><span data-stu-id="94c18-110">An event is something that has happened in the past.</span></span> <span data-ttu-id="94c18-111">Un événement de domaine est logiquement, quelque chose qui s’est produite dans un domaine particulier, et quelque chose vous souhaitez d’autres parties du même domaine (-process) pour connaître et potentiellement réagir à.</span><span class="sxs-lookup"><span data-stu-id="94c18-111">A domain event is, logically, something that happened in a particular domain, and something you want other parts of the same domain (in-process) to be aware of and potentially react to.</span></span>

<span data-ttu-id="94c18-112">Un avantage important d’événements de domaine est que les effets secondaires après qu’un problème est survenu dans un domaine peut être exprimés explicitement au lieu de manière implicite.</span><span class="sxs-lookup"><span data-stu-id="94c18-112">An important benefit of domain events is that side effects after something happened in a domain can be expressed explicitly instead of implicitly.</span></span> <span data-ttu-id="94c18-113">Ces effets doivent être cohérentes pour soit toutes les opérations relatives à la tâche d’entreprise se produisent de côté, ou aucun d'entre eux.</span><span class="sxs-lookup"><span data-stu-id="94c18-113">Those side effects must be consistent so either all the operations related to the business task happen, or none of them.</span></span> <span data-ttu-id="94c18-114">En outre, les événements de domaine permettent une meilleure séparation nette entre les classes dans le même domaine.</span><span class="sxs-lookup"><span data-stu-id="94c18-114">In addition, domain events enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="94c18-115">Par exemple, si vous utilisez simplement simplement les Entity Framework et les entités ou les agrégats de même, s’il faut effets causées par un cas d’usage, celles seront implémentées comme un concept implicit dans le code couplé après qu’un problème est survenu.</span><span class="sxs-lookup"><span data-stu-id="94c18-115">For example, if you are just using just Entity Framework and entities or even aggregates, if there have to be side effects provoked by a use case, those will be implemented as an implicit concept in the coupled code after something happened.</span></span> <span data-ttu-id="94c18-116">Toutefois, si vous voyez uniquement ce code, vous ne savez pas si ce code (comme effet secondaire) fait partie de l’opération principale ou s’il s’agit réellement d’un effet secondaire.</span><span class="sxs-lookup"><span data-stu-id="94c18-116">But, if you just see that code, you might not know if that code (the side effect) is part of the main operation or if it really is a side effect.</span></span> <span data-ttu-id="94c18-117">En revanche, à l’aide d’événements de domaine rend le concept explicite et dans le cadre du langage omniprésent.</span><span class="sxs-lookup"><span data-stu-id="94c18-117">On the other hand, using domain events makes the concept explicit and part of the ubiquitous language.</span></span> <span data-ttu-id="94c18-118">Par exemple, dans l’application eShopOnContainers, création d’une commande n’est pas simplement sur la commande. Il met à jour ou crée un acheteur d’agrégation en fonction de l’utilisateur d’origine, car l’utilisateur n’est pas un acheteur jusqu'à ce qu’il existe une commande en vigueur.</span><span class="sxs-lookup"><span data-stu-id="94c18-118">For example, in the eShopOnContainers application, creating an order is not just about the order; it updates or creates a buyer aggregate based on the original user, because the user is not a buyer until there is an order in place.</span></span> <span data-ttu-id="94c18-119">Si vous utilisez des événements de domaine, vous pouvez exprimer explicitement cette règle de domaine dans le langage omniprésent fournie par les experts de domaine.</span><span class="sxs-lookup"><span data-stu-id="94c18-119">If you use domain events, you can explicitly express that domain rule based in the ubiquitous language provided by the domain experts.</span></span>

<span data-ttu-id="94c18-120">Événements de domaine sont quelque peu similaires aux événements de style de messagerie, avec une différence importante.</span><span class="sxs-lookup"><span data-stu-id="94c18-120">Domain events are somewhat similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="94c18-121">Avec messagerie réel, message queuing, brokers de message ou un bus de service à l’aide de AMPQ, un message est toujours envoyé de manière asynchrone et communiqué à travers des processus et des ordinateurs.</span><span class="sxs-lookup"><span data-stu-id="94c18-121">With real messaging, message queuing, message brokers, or a service bus using AMPQ, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="94c18-122">Cela est utile pour l’intégration de plusieurs contextes de délimitée, microservices ou même différentes applications.</span><span class="sxs-lookup"><span data-stu-id="94c18-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="94c18-123">Toutefois, avec les événements de domaine, vous souhaitez déclencher un événement à partir de l’opération de domaine en cours d’exécution, mais que vous souhaitez que les effets secondaires se produisent dans le même domaine.</span><span class="sxs-lookup"><span data-stu-id="94c18-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="94c18-124">Les événements de domaine et leurs effets secondaires (les actions déclenchées par la suite qui sont gérées par les gestionnaires d’événements) doit se produire presque immédiatement, généralement in-process et dans le même domaine.</span><span class="sxs-lookup"><span data-stu-id="94c18-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="94c18-125">Par conséquent, les événements de domaine peuvent être synchrone ou asynchrone.</span><span class="sxs-lookup"><span data-stu-id="94c18-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="94c18-126">Événements d’intégration, toutefois, doivent toujours être asynchrones.</span><span class="sxs-lookup"><span data-stu-id="94c18-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="94c18-127">Événements de domaine par rapport aux événements d’intégration</span><span class="sxs-lookup"><span data-stu-id="94c18-127">Domain events versus integration events</span></span>

<span data-ttu-id="94c18-128">Sémantiquement, les événements de domaine et d’intégration sont la même chose : des notifications sur un élément qui vient de se produire.</span><span class="sxs-lookup"><span data-stu-id="94c18-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="94c18-129">Toutefois, leur implémentation doit être différente.</span><span class="sxs-lookup"><span data-stu-id="94c18-129">However, their implementation must be different.</span></span> <span data-ttu-id="94c18-130">Événements de domaine sont des messages uniquement vers un répartiteur d’événements de domaine, qui peut être implémenté comme un médiateur en mémoire basé sur un conteneur inversion de contrôle ou toute autre méthode.</span><span class="sxs-lookup"><span data-stu-id="94c18-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="94c18-131">En revanche, des événements d’intégration vise à propager les transactions validées et mises à jour des sous-systèmes supplémentaires, qu’ils soient autres microservices, les contextes de limitées ou les applications externes même.</span><span class="sxs-lookup"><span data-stu-id="94c18-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="94c18-132">Par conséquent, ils doivent se produire uniquement si l’entité est rendue persistante avec succès, depuis dans de nombreux scénarios en cas d’échec, l’opération entière jamais s’est produite.</span><span class="sxs-lookup"><span data-stu-id="94c18-132">Hence, they should occur only if the entity is successfully persisted, since in many scenarios if this fails, the entire operation effectively never happened.</span></span>

<span data-ttu-id="94c18-133">En outre et comme indiquée, intégration événements doivent être basés sur la communication asynchrone entre plusieurs microservices (autres contextes délimitée) ou systèmes externes même et d’applications.</span><span class="sxs-lookup"><span data-stu-id="94c18-133">In addition, and as mentioned, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span> <span data-ttu-id="94c18-134">Par conséquent, l’interface de bus d’événements a besoin de certaines infrastructure qui permet de processus entre et distribués de communication entre services potentiellement à distance.</span><span class="sxs-lookup"><span data-stu-id="94c18-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="94c18-135">Il peut reposer sur un bus des services commerciaux, les files d’attente, une base de données partagée utilisée comme une boîte aux lettres ou n’importe quel autre distribué et push dans l’idéal, de système de messagerie basée sur.</span><span class="sxs-lookup"><span data-stu-id="94c18-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="94c18-136">Événements de domaine par défaut afin de déclencher des effets secondaires sur plusieurs regroupements au sein du même domaine</span><span class="sxs-lookup"><span data-stu-id="94c18-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="94c18-137">Si l’exécution d’une commande liée à une instance d’agrégation requiert des règles de domaine supplémentaire à exécuter sur un ou plusieurs agrégats supplémentaires, vous devez concevoir et implémenter ces effets secondaires doit être déclenchée par les événements de domaine.</span><span class="sxs-lookup"><span data-stu-id="94c18-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="94c18-138">Comme indiqué dans la Figure 9-14 et comme l’un des principaux cas d’utilisation, un événement de domaine doit être utilisé pour propager les modifications d’état entre plusieurs agrégats dans le même modèle de domaine.</span><span class="sxs-lookup"><span data-stu-id="94c18-138">As shown in Figure 9-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![](./media/image15.png)

<span data-ttu-id="94c18-139">**Figure 9-14**.</span><span class="sxs-lookup"><span data-stu-id="94c18-139">**Figure 9-14**.</span></span> <span data-ttu-id="94c18-140">Événements de domaine pour appliquer la cohérence entre plusieurs agrégats dans le même domaine</span><span class="sxs-lookup"><span data-stu-id="94c18-140">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="94c18-141">Dans l’illustration, lorsque l’utilisateur lance une commande, l’événement de domaine OrderStarted déclenche la création d’un objet de l’acheteur dans l’ordre de tri microservice, selon les informations utilisateur d’origine à partir de l’identité de microservice (avec les informations fournies dans la commande CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="94c18-141">In the figure, when the user initiates an order, the OrderStarted domain event triggers creation of a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span> <span data-ttu-id="94c18-142">L’événement de domaine est généré par l’agrégat de la commande lorsqu’elle est créée en premier lieu.</span><span class="sxs-lookup"><span data-stu-id="94c18-142">The domain event is generated by the order aggregate when it is created in the first place.</span></span>

<span data-ttu-id="94c18-143">Vous pouvez également avoir la racine d’agrégation inscrit pour les événements déclenchés par les membres de son agrégats (entités enfants).</span><span class="sxs-lookup"><span data-stu-id="94c18-143">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="94c18-144">Par exemple, chaque entité d’enfant OrderItem peut déclencher un événement lorsque le prix est supérieur à une quantité spécifique, ou lorsque le montant de l’élément est trop élevé.</span><span class="sxs-lookup"><span data-stu-id="94c18-144">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="94c18-145">La racine d’agrégation peut ensuite recevoir ces événements et effectuer un calcul global ou une agrégation.</span><span class="sxs-lookup"><span data-stu-id="94c18-145">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="94c18-146">Il est important de comprendre que cette communication basée sur les événements n’est pas implémentée directement dans les fonctions d’agrégation ; Vous devez implémenter des gestionnaires d’événements de domaine.</span><span class="sxs-lookup"><span data-stu-id="94c18-146">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span> <span data-ttu-id="94c18-147">Gestion des événements de domaine sont un problème d’application.</span><span class="sxs-lookup"><span data-stu-id="94c18-147">Handling the domain events is an application concern.</span></span> <span data-ttu-id="94c18-148">La couche de modèle de domaine doit se concentrer uniquement sur la logique de domaine, les éléments par un expert du domaine, pas infrastructure d’application telles que les gestionnaires et les actions de persistance de l’effet secondaire à l’aide de référentiels.</span><span class="sxs-lookup"><span data-stu-id="94c18-148">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="94c18-149">Par conséquent, le niveau de la couche application est où vous devez avoir des gestionnaires d’événements de domaine déclenchent des actions lorsqu’un événement de domaine est déclenché.</span><span class="sxs-lookup"><span data-stu-id="94c18-149">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="94c18-150">Événements de domaine peuvent également servir à déclencher des actions de l’application, et ce qui est plus important, doit être ouvert pour augmenter ce nombre dans le futur d’une manière découplée.</span><span class="sxs-lookup"><span data-stu-id="94c18-150">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="94c18-151">Par exemple, l’ordre de démarrage, vous souhaiterez publier un événement de domaine pour propager ces informations à d’autres fonctions d’agrégation ou même à déclencher des actions telles que les notifications.</span><span class="sxs-lookup"><span data-stu-id="94c18-151">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="94c18-152">Le point essentiel est le nombre ouvrir des actions à exécuter lorsqu’un événement de domaine se produit.</span><span class="sxs-lookup"><span data-stu-id="94c18-152">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="94c18-153">Finalement, les actions et les règles dans le domaine et l’application augmente.</span><span class="sxs-lookup"><span data-stu-id="94c18-153">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="94c18-154">La complexité ou le nombre d’actions d’effet lorsque quelque chose se produit augmente, mais si votre code a été couplé avec le type « glue » (autrement dit, simplement l’instanciation d’objets avec le mot clé new dans C\#), vous devez à chaque fois que vous avez besoin d’ajouter une nouvelle action modifier le code d’origine.</span><span class="sxs-lookup"><span data-stu-id="94c18-154">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, just instantiating objects with the new keyword in C\#), then every time you needed to add a new action you would need to change the original code.</span></span> <span data-ttu-id="94c18-155">Cela peut entraîner nouveaux bogues, étant donné que chaque nouvelle exigence, vous devez modifier le flux de code d’origine.</span><span class="sxs-lookup"><span data-stu-id="94c18-155">This could result in new bugs, because with each new requirement you would need to change the original code flow.</span></span> <span data-ttu-id="94c18-156">Cela va à l’encontre du [principe ouvert/fermé](https://en.wikipedia.org/wiki/Open/closed_principle) de [solide](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span><span class="sxs-lookup"><span data-stu-id="94c18-156">This goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span></span> <span data-ttu-id="94c18-157">N’est pas la classe d’origine qui a été orchestrer les opérations serait croître et croître, ce qui va à l’encontre du [principe de responsabilité unique (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span><span class="sxs-lookup"><span data-stu-id="94c18-157">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="94c18-158">En revanche, si vous utilisez des événements de domaine, vous pouvez créer une implémentation affinée et découplée en séparant les responsabilités à l’aide de cette approche :</span><span class="sxs-lookup"><span data-stu-id="94c18-158">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1.  <span data-ttu-id="94c18-159">Envoyer une commande (par exemple, CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="94c18-159">Send a command (for example, CreateOrder).</span></span>
2.  <span data-ttu-id="94c18-160">Recevoir la commande dans un gestionnaire de commandes.</span><span class="sxs-lookup"><span data-stu-id="94c18-160">Receive the command in a command handler.</span></span>
    -   <span data-ttu-id="94c18-161">Exécuter les transactions d’un agrégat unique.</span><span class="sxs-lookup"><span data-stu-id="94c18-161">Execute a single aggregate’s transaction.</span></span>
    -   <span data-ttu-id="94c18-162">(Facultatif) Déclencher des événements de domaine pour les effets secondaires (par exemple, OrderStartedDomainDvent).</span><span class="sxs-lookup"><span data-stu-id="94c18-162">(Optional) Raise domain events for side effects (for example, OrderStartedDomainDvent).</span></span>
1.  <span data-ttu-id="94c18-163">Handle de domaine (dans le processus en cours), les événements thast s’exécute un nombre ouvert d’effets secondaires dans plusieurs agrégats ou des actions de l’application.</span><span class="sxs-lookup"><span data-stu-id="94c18-163">Handle domain events (within the current process) thast will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="94c18-164">Exemple :</span><span class="sxs-lookup"><span data-stu-id="94c18-164">For example:</span></span>
    -   <span data-ttu-id="94c18-165">Vérifiez ou créez la méthode acheteur et de paiement.</span><span class="sxs-lookup"><span data-stu-id="94c18-165">Verify or create buyer and payment method.</span></span>
    -   <span data-ttu-id="94c18-166">Créer et envoyer un événement d’intégration connexes pour le bus d’événements se propager les États sur microservices ou un déclencheur actions externes telles qu’envoyant un e-mail à l’acheteur.</span><span class="sxs-lookup"><span data-stu-id="94c18-166">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
    -   <span data-ttu-id="94c18-167">Gérer d’autres effets secondaires.</span><span class="sxs-lookup"><span data-stu-id="94c18-167">Handle other side effects.</span></span>

<span data-ttu-id="94c18-168">Comme indiqué dans la Figure 9-15, en commençant à partir du même événement de domaine, vous pouvez gérer plusieurs actions liées à d’autres fonctions d’agrégation dans le domaine ou les actions d’application supplémentaires que vous devez effectuer sur la connexion avec le bus d’événements et les événements d’intégration de microservices.</span><span class="sxs-lookup"><span data-stu-id="94c18-168">As shown in Figure 9-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![](./media/image16.png)

<span data-ttu-id="94c18-169">**Figure 9-15**.</span><span class="sxs-lookup"><span data-stu-id="94c18-169">**Figure 9-15**.</span></span> <span data-ttu-id="94c18-170">Gestion de plusieurs actions par domaine</span><span class="sxs-lookup"><span data-stu-id="94c18-170">Handling multiple actions per domain</span></span>

<span data-ttu-id="94c18-171">Les gestionnaires d’événements sont en général dans la couche application, car vous allez utiliser les objets d’infrastructure comme référentiels ou une API d’application pour le comportement de la microservice.</span><span class="sxs-lookup"><span data-stu-id="94c18-171">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior.</span></span> <span data-ttu-id="94c18-172">Dans ce sens, les gestionnaires d’événements sont similaires aux gestionnaires de commandes, pour que tous deux partie de la couche application.</span><span class="sxs-lookup"><span data-stu-id="94c18-172">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="94c18-173">La principale différence est qu’une commande doit être traitée une seule fois.</span><span class="sxs-lookup"><span data-stu-id="94c18-173">The important difference is that a command should be processed just once.</span></span> <span data-ttu-id="94c18-174">Un événement de domaine peut être traité de zéro ou  *n*  délai d’attente, car si peut être reçu par plusieurs récepteurs ou des gestionnaires d’événements avec un objectif différent pour chaque gestionnaire.</span><span class="sxs-lookup"><span data-stu-id="94c18-174">A domain event could be processed zero or *n* times, because if can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="94c18-175">La possibilité d’un nombre ouvert de gestionnaires par événement de domaine vous permet d’ajouter plusieurs règles de domaine plus sans affecter votre code en cours.</span><span class="sxs-lookup"><span data-stu-id="94c18-175">The possibility of an open number of handlers per domain event allows you to add many more domain rules without impacting your current code.</span></span> <span data-ttu-id="94c18-176">Par exemple, la mise en œuvre de la règle d’entreprise suivant qui doit se produire droite après un événement peut être aussi simple que l’ajout de plusieurs gestionnaires d’événements (ou même un seul) :</span><span class="sxs-lookup"><span data-stu-id="94c18-176">For instance, implementing the following business rule that has to happen right after an event might be as easy as adding a few event handlers (or even just one):</span></span>

<span data-ttu-id="94c18-177">Lorsque le montant total acheté par un client dans le magasin, sur n’importe quel nombre de commandes, dépasse 6 000 $, appliquer une remise de 10 % à chaque nouvelle commande et avertir le client avec une adresse de messagerie sur cette remise pour les commandes futures.</span><span class="sxs-lookup"><span data-stu-id="94c18-177">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implementing-domain-events"></a><span data-ttu-id="94c18-178">Implémenter des événements de domaine</span><span class="sxs-lookup"><span data-stu-id="94c18-178">Implementing domain events</span></span>

<span data-ttu-id="94c18-179">En c#, un événement de domaine est simplement une structure de données-exploitation ou classe, comme un DTO, toutes les informations relatives à ce que simplement s’est produite dans le domaine, comme indiqué dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="94c18-179">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : IAsyncNotification
{
    public int CardTypeId { get; private set; }
    public string CardNumber { get; private set; }
    public string CardSecurityNumber { get; private set; }
    public string CardHolderName { get; private set; }
    public DateTime CardExpiration { get; private set; }
    public Order Order { get; private set; }

    public OrderStartedDomainEvent(Order order,
        int cardTypeId, string cardNumber,
        string cardSecurityNumber, string cardHolderName,
        DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="94c18-180">Il s’agit essentiellement d’une classe qui conserve toutes les données associées à l’événement OrderStarted.</span><span class="sxs-lookup"><span data-stu-id="94c18-180">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="94c18-181">En termes de langage omniprésent du domaine, dans la mesure où un événement est quelque chose qui se sont produits dans le passé, le nom de classe de l’événement doit être représenté comme un verbe passé, tels que OrderStartedDomainEvent ou OrderShippedDomainEvent.</span><span class="sxs-lookup"><span data-stu-id="94c18-181">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="94c18-182">Qui est l’implémentation de l’événement de domaine dans l’ordre de tri microservice dans eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="94c18-182">That is how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="94c18-183">Comme nous l’avons indiqué, une caractéristique importante d’événements qui est dans la mesure où un événement est quelque chose qui se sont produits dans le passé, il ne doit pas modifier.</span><span class="sxs-lookup"><span data-stu-id="94c18-183">As we have noted, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="94c18-184">Par conséquent, il doit être une classe immuable.</span><span class="sxs-lookup"><span data-stu-id="94c18-184">Therefore it must be an immutable class.</span></span> <span data-ttu-id="94c18-185">Vous pouvez voir dans le code précédent qui a les propriétés sont en lecture seule à partir d’en dehors de l’objet.</span><span class="sxs-lookup"><span data-stu-id="94c18-185">You can see in the preceding code that the properties are read-only from outside of the object.</span></span> <span data-ttu-id="94c18-186">La seule façon de mettre à jour de l’objet est via le constructeur lorsque vous créez l’objet d’événement.</span><span class="sxs-lookup"><span data-stu-id="94c18-186">The only way to update the object is through the constructor when you create the event object.</span></span>

### <a name="raising-domain-events"></a><span data-ttu-id="94c18-187">Le déclenchement d’événements de domaine</span><span class="sxs-lookup"><span data-stu-id="94c18-187">Raising domain events</span></span>

<span data-ttu-id="94c18-188">La question suivante consiste à déclencher un événement de domaine afin qu’il atteint ses gestionnaires d’événements connexes.</span><span class="sxs-lookup"><span data-stu-id="94c18-188">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="94c18-189">Vous pouvez utiliser plusieurs approches.</span><span class="sxs-lookup"><span data-stu-id="94c18-189">You can use multiple approaches.</span></span>

<span data-ttu-id="94c18-190">UDI Dahan proposée à l’origine (par exemple, dans plusieurs liées billets, tel que [domaine événements – prendre 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) à l’aide d’une classe statique pour la gestion et le déclenchement d’événements.</span><span class="sxs-lookup"><span data-stu-id="94c18-190">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="94c18-191">Cela peut inclure une classe statique nommée DomainEvents qui déclenche des événements de domaine immédiatement lorsqu’elle est appelée, à l’aide de la syntaxe comme DomainEvents.Raise (événement myEvent).</span><span class="sxs-lookup"><span data-stu-id="94c18-191">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like DomainEvents.Raise(Event myEvent).</span></span> <span data-ttu-id="94c18-192">Jimmy Bogard a écrit un billet de blog ([renforcer votre domaine : événements de domaine](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) qui recommande une approche similaire.</span><span class="sxs-lookup"><span data-stu-id="94c18-192">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="94c18-193">Toutefois, lorsque la classe d’événements de domaine est statique, il également distribue aux gestionnaires immédiatement.</span><span class="sxs-lookup"><span data-stu-id="94c18-193">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="94c18-194">Cela, test et de débogage plus difficile, car les gestionnaires d’événements avec une logique des effets secondaires sont exécutées immédiatement après que l’événement est déclenché.</span><span class="sxs-lookup"><span data-stu-id="94c18-194">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="94c18-195">Test et de débogage, vous souhaitez le focus sur uniquement ce qui se passe dans les classes d’agrégation en cours ; Vous ne souhaitez pas soudainement redirigé vers d’autres gestionnaires d’événements pour les effets liés à d’autres agrégats ou de la logique d’application.</span><span class="sxs-lookup"><span data-stu-id="94c18-195">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="94c18-196">Il s’agit de raison pour laquelle les autres approches ont évolué, comme expliqué dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="94c18-196">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-for-raising-and-dispatching-events"></a><span data-ttu-id="94c18-197">L’approche différée pour déclencher et la distribution des événements</span><span class="sxs-lookup"><span data-stu-id="94c18-197">The deferred approach for raising and dispatching events</span></span>

<span data-ttu-id="94c18-198">Au lieu de la distribution à un gestionnaire d’événements de domaine immédiatement, une meilleure approche consiste à ajouter les événements de domaine à une collection, puis à distribuer les événements de domaine *juste avant* ou *droit*  *une fois* validé la transaction (comme avec SaveChanges dans EF).</span><span class="sxs-lookup"><span data-stu-id="94c18-198">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="94c18-199">(Cette approche a été décrit par Jimmy Bogard dans ce billet [un modèle d’événements domaine mieux](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span><span class="sxs-lookup"><span data-stu-id="94c18-199">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="94c18-200">Décider si vous envoyer les événements de domaine droite avant ou vers la droite après avoir validé la transaction est important, car il détermine si vous allez inclure les effets secondaires dans le cadre de la même transaction ou dans différentes transactions.</span><span class="sxs-lookup"><span data-stu-id="94c18-200">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="94c18-201">Dans ce cas, vous devez traiter avec cohérence éventuelle entre plusieurs agrégats.</span><span class="sxs-lookup"><span data-stu-id="94c18-201">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="94c18-202">Cette rubrique est décrite dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="94c18-202">This topic is discussed in the next section.</span></span>

<span data-ttu-id="94c18-203">L’approche différée est quel eShopOnContainers utilise.</span><span class="sxs-lookup"><span data-stu-id="94c18-203">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="94c18-204">Tout d’abord, vous ajoutez les événements survenant dans vos entités dans une liste d’événements par l’entité ou la collection.</span><span class="sxs-lookup"><span data-stu-id="94c18-204">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="94c18-205">Cette liste doit être la partie de l’objet entité, ou mieux encore, une partie de votre classe d’entité de base, comme indiqué dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="94c18-205">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example:</span></span>

```csharp
public abstract class Entity
{
    private List<IAsyncNotification> _domainEvents;

    public List<IAsyncNotification> DomainEvents => _domainEvents;

    public void AddDomainEvent(IAsyncNotification eventItem)
    {
        _domainEvents = _domainEvents ?? new List<IAsyncNotification>();
        _domainEvents.Add(eventItem);
    }

    public void RemoveDomainEvent(IAsyncNotification eventItem)
    {
        if (_domainEvents is null) return;
        _domainEvents.Remove(eventItem);
    }
    // ...
}
```

<span data-ttu-id="94c18-206">Lorsque vous souhaitez déclencher un événement, vous l’ajoutez simplement à la collection d’événements doit être placé dans une méthode d’agrégation d’entité, comme le montre le code suivant :</span><span class="sxs-lookup"><span data-stu-id="94c18-206">When you want to raise an event, you just add it to the event collection to be placed within an aggregate entity method, as the following code shows:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
    cardTypeId,
    cardNumber,
    cardSecurityNumber,
    cardHolderName,
    cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="94c18-207">Notez que la seule chose qui effectue la méthode AddDomainEvent ajoute un événement à la liste.</span><span class="sxs-lookup"><span data-stu-id="94c18-207">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="94c18-208">Aucun événement n’est encore déclenché et aucun gestionnaire d’événements n’est appelé encore.</span><span class="sxs-lookup"><span data-stu-id="94c18-208">No event is raised yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="94c18-209">En fait, vous souhaitez distribuer les événements plus tard, lorsque vous validez la transaction à la base de données.</span><span class="sxs-lookup"><span data-stu-id="94c18-209">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="94c18-210">Si vous utilisez Entity Framework Core, cela signifie que dans la méthode SaveChanges de votre DbContext EF, comme dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="94c18-210">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<int> SaveEntitiesAsync()
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.
        await _mediator.DispatchDomainEventsAsync(this);
        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be commited
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="94c18-211">Avec ce code, vous expédiez les événements de l’entité à leurs gestionnaires d’événements respectif.</span><span class="sxs-lookup"><span data-stu-id="94c18-211">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="94c18-212">Le résultat global est que vous avez séparé le déclenchement d’un événement de domaine (un simple ajouter dans une liste en mémoire) à partir de sa distribution à un gestionnaire d’événements.</span><span class="sxs-lookup"><span data-stu-id="94c18-212">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="94c18-213">En outre, selon le type de l’expéditeur que vous utilisez, vous pourriez distribuer les événements de façon synchrone ou asynchrone.</span><span class="sxs-lookup"><span data-stu-id="94c18-213">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="94c18-214">N’oubliez pas que les limites transactionnelles entrent en important lire ici.</span><span class="sxs-lookup"><span data-stu-id="94c18-214">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="94c18-215">Si votre unité de travail et de la transaction peut s’étendre sur plusieurs agrégats (comme lorsque vous utilisez EF Core et une base de données relationnelle), cela peut fonctionner correctement.</span><span class="sxs-lookup"><span data-stu-id="94c18-215">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="94c18-216">Toutefois, si la transaction ne peut pas couvrir les agrégats, tels que lorsque vous utilisez une base de données NoSQL comme Azure DocumentDB, vous devrez implémenter des étapes supplémentaires pour garantir la cohérence.</span><span class="sxs-lookup"><span data-stu-id="94c18-216">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure DocumentDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="94c18-217">Il s’agit d’une autre raison pour laquelle ignorant la persistance n'est pas universelle ; il dépend du système de stockage que vous utilisez.</span><span class="sxs-lookup"><span data-stu-id="94c18-217">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="94c18-218">Transaction unique entre les agrégats et la cohérence éventuelle des agrégats</span><span class="sxs-lookup"><span data-stu-id="94c18-218">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="94c18-219">La question s’il faut effectuer une transaction unique entre les agrégats par rapport à la partie de confiance entre les agrégats sur la cohérence éventuelle est controversé.</span><span class="sxs-lookup"><span data-stu-id="94c18-219">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="94c18-220">Nombreux auteurs DDD comme Eric Evans et Vaughn Vernon préconisent la règle une transaction = un seul agrégat et par conséquent prétendent pour la cohérence éventuelle entre les agrégats.</span><span class="sxs-lookup"><span data-stu-id="94c18-220">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="94c18-221">Par exemple, dans son livre *la conception*, Eric Evans indique cela :</span><span class="sxs-lookup"><span data-stu-id="94c18-221">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

<span data-ttu-id="94c18-222">Une règle qui s’étend sur des agrégats ne sera pas censée être à jour en permanence.</span><span class="sxs-lookup"><span data-stu-id="94c18-222">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="94c18-223">Via le traitement des événements, le traitement par lots ou d’autres mécanismes de mise à jour, les autres dépendances peuvent être résolues dans le temps spécifique.</span><span class="sxs-lookup"><span data-stu-id="94c18-223">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="94c18-224">(groupe de protection.</span><span class="sxs-lookup"><span data-stu-id="94c18-224">(pg.</span></span> <span data-ttu-id="94c18-225">128)</span><span class="sxs-lookup"><span data-stu-id="94c18-225">128)</span></span>

<span data-ttu-id="94c18-226">Vaughn Vernon affiche le message suivant dans [efficaces de conception d’agrégation. Partie II : Fabrication travail agrège ensemble](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="94c18-226">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

<span data-ttu-id="94c18-227">Par conséquent, si l’exécution d’une commande sur une instance d’agrégation requiert que les autres règles d’entreprise s’exécuter sur un ou plusieurs agrégats, utilisez la cohérence éventuelle \[...\] Il existe un moyen pratique pour prendre en charge de la cohérence éventuelle dans un modèle DDD.</span><span class="sxs-lookup"><span data-stu-id="94c18-227">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="94c18-228">Une méthode d’agrégation publie un événement de domaine qui est remis à un ou plusieurs abonnés asynchrones.</span><span class="sxs-lookup"><span data-stu-id="94c18-228">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="94c18-229">Cette logique est basée sur adoption affinées transactions plutôt que de nombreux agrégats ou des entités de fractionnement des transactions.</span><span class="sxs-lookup"><span data-stu-id="94c18-229">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="94c18-230">L’idée est que dans le deuxième cas, le nombre de verrous de base de données sera important dans les applications à grande échelle avec les besoins de haute évolutivité.</span><span class="sxs-lookup"><span data-stu-id="94c18-230">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="94c18-231">Adoption du fait que les applications évolutives haute doivent n’a ne pas la cohérence transactionnelle instantanée entre plusieurs agrégats aide à accepter le concept de cohérence éventuelle.</span><span class="sxs-lookup"><span data-stu-id="94c18-231">Embracing the fact that high-scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="94c18-232">Modifications atomiques ne sont généralement pas nécessaires à l’activité, et il est dans tous les cas la responsabilité des experts de domaine pour vous si certaines opérations besoin des transactions atomiques ou non.</span><span class="sxs-lookup"><span data-stu-id="94c18-232">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="94c18-233">Si une opération toujours a besoin d’une transaction atomique entre plusieurs agrégats, vous pouvez demander si votre regroupement doit être supérieure ou n’a pas été conçue correctement.</span><span class="sxs-lookup"><span data-stu-id="94c18-233">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="94c18-234">Toutefois, les autres développeurs et les architectes de Jimmy Bogard sont OK lorsque la répartition d’une transaction unique entre plusieurs agrégats, mais uniquement lorsque les agrégats supplémentaires associés aux effets de la même commande d’origine.</span><span class="sxs-lookup"><span data-stu-id="94c18-234">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="94c18-235">Par exemple, dans [un modèle d’événements domaine mieux](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard indique cela :</span><span class="sxs-lookup"><span data-stu-id="94c18-235">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

<span data-ttu-id="94c18-236">En règle générale, je veux les effets d’un événement de domaine dans la même transaction logique, mais pas nécessairement dans la même étendue de déclencher l’événement domaine \[...\] Juste avant que nous commit transaction, nous distribuer notre événements à leurs gestionnaires respectifs.</span><span class="sxs-lookup"><span data-stu-id="94c18-236">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="94c18-237">Si vous expédiez le droit d’événements de domaine *avant* validé la transaction d’origine, il est, car vous souhaitez que les effets de ces événements à inclure dans la même transaction.</span><span class="sxs-lookup"><span data-stu-id="94c18-237">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="94c18-238">Par exemple, si la méthode SaveChanges de DbContext EF échoue, la transaction annule toutes les modifications, le résultat de toutes les opérations de l’effet secondaire implémentée par les gestionnaires d’événements de domaine connexes.</span><span class="sxs-lookup"><span data-stu-id="94c18-238">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="94c18-239">Cela est, car l’étendue de la durée de vie DbContext est par défaut défini comme « limitée. »</span><span class="sxs-lookup"><span data-stu-id="94c18-239">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="94c18-240">Par conséquent, l’objet DbContext est partagé entre plusieurs objets du référentiel en cours d’instanciation au sein de la même étendue ou un graphique d’objets.</span><span class="sxs-lookup"><span data-stu-id="94c18-240">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="94c18-241">Ceci coïncide avec l’étendue HttpRequest lors du développement d’applications Web API ou MVC.</span><span class="sxs-lookup"><span data-stu-id="94c18-241">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="94c18-242">En réalité, ces deux approches (transaction atomique unique et la cohérence éventuelle) peuvent être appropriées.</span><span class="sxs-lookup"><span data-stu-id="94c18-242">In reality, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="94c18-243">Il dépend vraiment les besoins de votre entreprise ou de domaine et ce que les experts de domaine vous dire.</span><span class="sxs-lookup"><span data-stu-id="94c18-243">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="94c18-244">Il dépend également de l’évolutivité que vous devez le service doit être (transactions plus granulaires ont moins d’impact en ce qui concerne les verrous de base de données).</span><span class="sxs-lookup"><span data-stu-id="94c18-244">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="94c18-245">Et dépend de la quantité investissement vous êtes prêt à effectuer dans votre code, étant donné que la cohérence éventuelle nécessite un code plus complexe afin de détecter les éventuelles incohérences entre les agrégats et la nécessité d’implémenter des actions de compensation.</span><span class="sxs-lookup"><span data-stu-id="94c18-245">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="94c18-246">Prendre en compte si vous validez des modifications à l’agrégat d’origine et par la suite, lorsque les événements sont distribués, il existe un problème et les gestionnaires d’événements ne peut pas valider leurs effets secondaires, vous devez les incohérences entre des agrégats.</span><span class="sxs-lookup"><span data-stu-id="94c18-246">Take into account that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="94c18-247">Est un moyen d’autoriser des actions de compensation pour stocker les événements de domaine dans les tables de base de données supplémentaires afin qu’ils peuvent faire partie de la transaction d’origine.</span><span class="sxs-lookup"><span data-stu-id="94c18-247">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="94c18-248">Ensuite, vous pourriez avoir un traitement par lots qui détecte des incohérences et exécute des actions de compensation en comparant la liste des événements avec l’état actuel des agrégats.</span><span class="sxs-lookup"><span data-stu-id="94c18-248">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="94c18-249">Les actions de compensation font partie d’un sujet complexe qui nécessite une analyse approfondie de votre côté, ce qui inclut discuter avec l’utilisateur des activités et les experts de domaine.</span><span class="sxs-lookup"><span data-stu-id="94c18-249">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="94c18-250">Dans tous les cas, vous pouvez choisir l’approche que vous avez besoin.</span><span class="sxs-lookup"><span data-stu-id="94c18-250">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="94c18-251">Mais initial différée approche, le déclenchement d’événements avant de valider, afin d’utiliser d’une transaction unique, est l’approche la plus simple lorsque vous utilisez EF Core et une base de données relationnelle.</span><span class="sxs-lookup"><span data-stu-id="94c18-251">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="94c18-252">Il est plus facile à implémenter et valide dans de nombreux cas.</span><span class="sxs-lookup"><span data-stu-id="94c18-252">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="94c18-253">Il est également l’approche utilisée dans l’ordre de tri microservice dans eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="94c18-253">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="94c18-254">Mais comment réellement répartition ces événements à leurs gestionnaires d’événements respectif ?</span><span class="sxs-lookup"><span data-stu-id="94c18-254">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="94c18-255">Quelle est la \_objet médiateur que vous voyez dans l’exemple précédent ?</span><span class="sxs-lookup"><span data-stu-id="94c18-255">What is the \_mediator object that you see in the previous example?</span></span> <span data-ttu-id="94c18-256">Qui doit faire avec les techniques et les artefacts que vous pouvez utiliser pour le mappage entre les événements et leurs gestionnaires d’événements.</span><span class="sxs-lookup"><span data-stu-id="94c18-256">That has to do with the techniques and artifacts you can use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="94c18-257">Le répartiteur d’événements de domaine : mappage à partir d’événements aux gestionnaires d’événements</span><span class="sxs-lookup"><span data-stu-id="94c18-257">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="94c18-258">Une fois que vous êtes en mesure de distribuer ou publier les événements, vous avez besoin d’un type d’artefact qui publiera l’événement afin que chaque gestionnaire associé peut l’obtenir et les effets de processus basé sur l’événement.</span><span class="sxs-lookup"><span data-stu-id="94c18-258">Once you are able to dispatch or publish the events, you need some kind of artifact that will publish the event so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="94c18-259">Une approche consiste à un système de messagerie réel ou même un bus d’événements, éventuellement en fonction d’un service bus par opposition aux événements de mémoire.</span><span class="sxs-lookup"><span data-stu-id="94c18-259">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="94c18-260">Toutefois, pour le premier cas, messagerie réels serait excessifs pour le traitement des événements de domaine, car il vous suffit de traiter ces événements dans le même processus (autrement dit, dans la même couche de domaine et d’application).</span><span class="sxs-lookup"><span data-stu-id="94c18-260">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="94c18-261">Une autre façon de mapper des événements sur plusieurs gestionnaires d’événements est à l’aide de l’inscription des types dans un conteneur inversion de contrôle afin que vous pouvez déduire dynamiquement vers où distribuer les événements.</span><span class="sxs-lookup"><span data-stu-id="94c18-261">Another way to map events to multiple event handlers is by using types registration in an IoC container so that you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="94c18-262">En d’autres termes, vous devez connaître les gestionnaires d’événements permettant d’obtenir un événement spécifique.</span><span class="sxs-lookup"><span data-stu-id="94c18-262">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="94c18-263">Figure 9-16 montre une approche simplifiée pour cela.</span><span class="sxs-lookup"><span data-stu-id="94c18-263">Figure 9-16 shows a simplified approach for that.</span></span>

![](./media/image17.png)

<span data-ttu-id="94c18-264">**Figure 9-16**.</span><span class="sxs-lookup"><span data-stu-id="94c18-264">**Figure 9-16**.</span></span> <span data-ttu-id="94c18-265">Répartiteur d’événements de domaine à l’aide d’inversion de contrôle</span><span class="sxs-lookup"><span data-stu-id="94c18-265">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="94c18-266">Vous pouvez créer tous les éléments et artefacts pour implémenter cette approche par vous-même.</span><span class="sxs-lookup"><span data-stu-id="94c18-266">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="94c18-267">Toutefois, vous pouvez également utiliser les bibliothèques disponibles comme [MediatR](https://github.com/jbogard/MediatR), qui les coulisses utilise votre conteneur IoT.</span><span class="sxs-lookup"><span data-stu-id="94c18-267">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR), which underneath the covers uses your IoT container.</span></span> <span data-ttu-id="94c18-268">Vous pouvez donc directement utiliser les interfaces prédéfinies et des méthodes de publication/distribution de l’objet médiateur.</span><span class="sxs-lookup"><span data-stu-id="94c18-268">You can therefore directly use the predefined interfaces and the mediator object’s publish/dispatch methods.</span></span>

<span data-ttu-id="94c18-269">Dans le code, vous devez d’abord inscrire les types de gestionnaires d’événements dans votre conteneur inversion de contrôle, comme indiqué dans l’exemple suivant :</span><span class="sxs-lookup"><span data-stu-id="94c18-269">In code, you first need to register the event handler types in your IoC container, as shown in the following example:</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement
        // IAsyncNotificationHandler<>) in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(
            typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
            .GetTypeInfo().Assembly)
            .Where(t => t.IsClosedTypeOf(typeof(IAsyncNotificationHandler<>)))
            .AsImplementedInterfaces();
        // Other registrations ...
    }
}
```

<span data-ttu-id="94c18-270">Le code identifie tout d’abord l’assembly qui contient les gestionnaires d’événements de domaine en recherchant l’assembly qui contient un des gestionnaires (à l’aide de typeof(ValidateOrAddBuyerAggregateWhenXxxx), mais vous auriez pu choisir n’importe quel autre gestionnaire d’événements pour rechercher l’assembly).</span><span class="sxs-lookup"><span data-stu-id="94c18-270">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="94c18-271">Étant donné que tous les gestionnaires d’événements implémentent l’interface IAsyncNotificationHandler, le code, puis recherche uniquement les types et enregistre tous les gestionnaires d’événements.</span><span class="sxs-lookup"><span data-stu-id="94c18-271">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="94c18-272">Comment s’abonner aux événements de domaine</span><span class="sxs-lookup"><span data-stu-id="94c18-272">How to subscribe to domain events</span></span>

<span data-ttu-id="94c18-273">Lorsque vous utilisez MediatR, chaque gestionnaire d’événements doit utiliser un type d’événement qui est fourni sur le paramètre générique de l’interface IAsyncNotificationHandler, comme vous pouvez le voir dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="94c18-273">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the IAsyncNotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="94c18-274">En fonction de la relation entre l’événement et le Gestionnaire d’événements qui peut être considérées comme l’abonnement, l’artefact MediatR peut détecter tous les gestionnaires d’événements pour chaque événement et déclencher chacun de ces gestionnaires d’événements.</span><span class="sxs-lookup"><span data-stu-id="94c18-274">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="94c18-275">Comment gérer les événements de domaine</span><span class="sxs-lookup"><span data-stu-id="94c18-275">How to handle domain events</span></span>

<span data-ttu-id="94c18-276">Enfin, le Gestionnaire d’événements implémente généralement code de couche application qui utilise des référentiels de l’infrastructure pour obtenir les fonctions d’agrégation supplémentaires requises et exécuter la logique de domaine de l’effet.</span><span class="sxs-lookup"><span data-stu-id="94c18-276">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="94c18-277">Le code suivant fournit un exemple.</span><span class="sxs-lookup"><span data-stu-id="94c18-277">The following code shows an example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
    : IAsyncNotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;
    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // Parameter validations
        //...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ?
            orderStartedEvent.CardTypeId : 1;
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;
        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }
        buyer.VerifyOrAddPaymentMethod(cardTypeId,
            $"Payment Method on {DateTime.UtcNow}",
            orderStartedEvent.CardNumber,
            orderStartedEvent.CardSecurityNumber,
            orderStartedEvent.CardHolderName,
            orderStartedEvent.CardExpiration,
            orderStartedEvent.Order.Id);
        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer) :
        _buyerRepository.Add(buyer);
        await _buyerRepository.UnitOfWork.SaveEntitiesAsync();
        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="94c18-278">Ce code de gestionnaire d’événements est considéré comme code de couche application, car elle utilise des référentiels de l’infrastructure, comme expliqué dans la section suivante sur la couche de persistance de l’infrastructure.</span><span class="sxs-lookup"><span data-stu-id="94c18-278">This event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="94c18-279">Gestionnaires d’événements peuvent également utiliser d’autres composants d’infrastructure.</span><span class="sxs-lookup"><span data-stu-id="94c18-279">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="94c18-280">Événements de domaine peuvent générer des événements d’intégration à publier en dehors des limites de microservice</span><span class="sxs-lookup"><span data-stu-id="94c18-280">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="94c18-281">Enfin, il est important de mentionner que vous souhaiterez parfois propager des événements sur plusieurs microservices.</span><span class="sxs-lookup"><span data-stu-id="94c18-281">Finally, is important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="94c18-282">Qui est considéré comme un événement d’intégration, et elle peut être publiée via un bus d’événements à partir de n’importe quel gestionnaire d’événements de domaine spécifique.</span><span class="sxs-lookup"><span data-stu-id="94c18-282">That is considered an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="94c18-283">Conclusions sur les événements de domaine</span><span class="sxs-lookup"><span data-stu-id="94c18-283">Conclusions on domain events</span></span> 

<span data-ttu-id="94c18-284">Comme indiqué, utilisez les événements de domaine d’implémenter explicitement des effets des modifications de votre domaine.</span><span class="sxs-lookup"><span data-stu-id="94c18-284">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="94c18-285">Pour utiliser la terminologie DDD, utilisez les événements de domaine d’implémenter explicitement des effets secondaires sur un ou plusieurs agrégats.</span><span class="sxs-lookup"><span data-stu-id="94c18-285">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="94c18-286">En outre et pour une meilleure évolutivité et moins d’impact sur les verrous de base de données, utilisez cohérence éventuelle entre les agrégats au sein du même domaine.</span><span class="sxs-lookup"><span data-stu-id="94c18-286">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="94c18-287">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="94c18-287">Additional resources</span></span>

-   <span data-ttu-id="94c18-288">**Greg Young. Qu’est un événement de domaine ? ** 
     [ *http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span><span class="sxs-lookup"><span data-stu-id="94c18-288">**Greg Young. What is a Domain Event?**
[*http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span></span>

-   <span data-ttu-id="94c18-289">**Jan Stenberg. Événements de domaine et de la cohérence éventuelle**
    [*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span><span class="sxs-lookup"><span data-stu-id="94c18-289">**Jan Stenberg. Domain Events and Eventual Consistency**
[*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span></span>

-   <span data-ttu-id="94c18-290">**Jimmy Bogard. Un modèle d’événements domaine mieux**
    [*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span><span class="sxs-lookup"><span data-stu-id="94c18-290">**Jimmy Bogard. A better domain events pattern**
[*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span></span>

-   <span data-ttu-id="94c18-291">**Vaughn Vernon. Efficace d’agrégation conception partie II : Effectue le travail agrégats ensemble**
    [*http://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_ 2. fichier pdf de*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span><span class="sxs-lookup"><span data-stu-id="94c18-291">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together**
[*http://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span></span>

-   <span data-ttu-id="94c18-292">**Jimmy Bogard. Renforcement de votre domaine : événements de domaine**
    *<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/>*</span><span class="sxs-lookup"><span data-stu-id="94c18-292">**Jimmy Bogard. Strengthening your domain: Domain Events**
*<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/> *</span></span>

-   <span data-ttu-id="94c18-293">**Tony Truong. Exemple de modèle de domaine événements**
    [*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span><span class="sxs-lookup"><span data-stu-id="94c18-293">**Tony Truong. Domain Events Pattern Example**
[*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span></span>

-   <span data-ttu-id="94c18-294">**UDI Dahan. Comment créer entièrement encapsulé les modèles de domaine**
    [*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span><span class="sxs-lookup"><span data-stu-id="94c18-294">**Udi Dahan. How to create fully encapsulated Domain Models**
[*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span></span>

-   <span data-ttu-id="94c18-295">**UDI Dahan. Événements de domaine – prendre 2**
    [*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span><span class="sxs-lookup"><span data-stu-id="94c18-295">**Udi Dahan. Domain Events – Take 2**
[*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span></span>

-   <span data-ttu-id="94c18-296">**UDI Dahan. Événements de domaine – Salvation**
    [*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span><span class="sxs-lookup"><span data-stu-id="94c18-296">**Udi Dahan. Domain Events – Salvation**
[*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span></span>

-   <span data-ttu-id="94c18-297">**Jan Kronquist. Ne pas publier des événements de domaine, les retourner ! ** 
     [ *https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span><span class="sxs-lookup"><span data-stu-id="94c18-297">**Jan Kronquist. Don't publish Domain Events, return them!**
[*https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span></span>

-   <span data-ttu-id="94c18-298">**Cesar de la Torre. Événements de domaine Visual Studio. Événements d’intégration dans les architectures DDD et microservices**
    [*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span><span class="sxs-lookup"><span data-stu-id="94c18-298">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures**
[*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="94c18-299">[Précédente] (client-côté-validation.md) [suivant] (infrastructure-persistance-layer-design.md)</span><span class="sxs-lookup"><span data-stu-id="94c18-299">[Previous] (client-side-validation.md) [Next] (infrastructure-persistence-layer-design.md)</span></span>
