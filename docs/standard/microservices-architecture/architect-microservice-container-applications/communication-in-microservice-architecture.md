---
title: "Communication au sein d’une architecture de microservice"
description: "Architecture de Microservices .NET pour les Applications .NET en conteneur | Communication dans un architectures d’architecture de microservice"
keywords: Docker, microservices, ASP.NET, conteneur
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 8d38095a151b7568619b17340d768eff684d3271
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/22/2017
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="e1c14-104">Communication au sein d’une architecture de microservice</span><span class="sxs-lookup"><span data-stu-id="e1c14-104">Communication in a microservice architecture</span></span>

<span data-ttu-id="e1c14-105">Dans une application monolithique en cours d’exécution sur un processus unique, les composants invoquer mutuellement à l’aide d’appels de fonction ou de méthode au niveau du langage.</span><span class="sxs-lookup"><span data-stu-id="e1c14-105">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="e1c14-106">Ceux-ci peuvent être fortement couplés si vous créez des objets avec le code (par exemple, `new ClassName()`), ou peut être appelée de façon découplée si vous utilisez l’Injection de dépendances en faisant référence à des abstractions plutôt que des instances d’objet concret.</span><span class="sxs-lookup"><span data-stu-id="e1c14-106">These can be strongly coupled if you are creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you are using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="e1c14-107">Dans les deux cas, les objets sont en cours d’exécution dans le même processus.</span><span class="sxs-lookup"><span data-stu-id="e1c14-107">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="e1c14-108">Le défi le plus important lors de la modification d’une application monolithique vers une application basée sur des microservices se trouve dans le mécanisme de communication.</span><span class="sxs-lookup"><span data-stu-id="e1c14-108">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="e1c14-109">Une conversion directe dans le processus appels de méthode dans les appels aux services RPC provoque un bavard et une communication efficace pas qui ne s’exécutera pas correctement dans les environnements distribués.</span><span class="sxs-lookup"><span data-stu-id="e1c14-109">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that will not perform well in distributed environments.</span></span> <span data-ttu-id="e1c14-110">Les défis de la conception d’un système distribué correctement suffisamment bien connus qu’il existe encore un canon appelé le [les fallacies de l’informatique distribuée](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) qui répertorie les hypothèses sur lesquelles les développeurs font souvent lors du déplacement de monolithique de conceptions distribuées.</span><span class="sxs-lookup"><span data-stu-id="e1c14-110">The challenges of designing distributed system properly are well enough known that there is even a canon known as the [The fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="e1c14-111">Il est n’est pas une solution, mais plusieurs.</span><span class="sxs-lookup"><span data-stu-id="e1c14-111">There is not one solution, but several.</span></span> <span data-ttu-id="e1c14-112">Une solution consiste à isoler le microservices business autant que possible.</span><span class="sxs-lookup"><span data-stu-id="e1c14-112">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="e1c14-113">Ensuite, utilisent la communication asynchrone entre les microservices interne et remplacez affinée communication standard dans une communication intra-PROCEDE entre les objets de communication de plus grande ampleur.</span><span class="sxs-lookup"><span data-stu-id="e1c14-113">You then use asynchronous communication between the internal microservices and replace fine-grained communication that is typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="e1c14-114">Vous pouvez effectuer cela en regroupant les appels et en retournant des données qui agrège les résultats de plusieurs appels internes au client.</span><span class="sxs-lookup"><span data-stu-id="e1c14-114">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="e1c14-115">Une application basée sur des microservices est un système distribué en cours d’exécution sur plusieurs processus ou des services, généralement même entre plusieurs serveurs ou ordinateurs hôtes.</span><span class="sxs-lookup"><span data-stu-id="e1c14-115">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="e1c14-116">Chaque instance de service est généralement un processus.</span><span class="sxs-lookup"><span data-stu-id="e1c14-116">Each service instance is typically a process.</span></span> <span data-ttu-id="e1c14-117">Par conséquent, les services doivent interagissent à l’aide d’un protocole de communication inter-processus comme un protocole binaire, tel que TCP, selon la nature de chaque service, AMQP ou HTTP.</span><span class="sxs-lookup"><span data-stu-id="e1c14-117">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="e1c14-118">La Communauté microservice promeut la philosophie de «[actives des points de terminaison et des canaux passifs](http://simplicable.com/new/smart-endpoints-and-dumb-pipes). »</span><span class="sxs-lookup"><span data-stu-id="e1c14-118">The microservice community promotes the philosophy of “[smart endpoints and dumb pipes](http://simplicable.com/new/smart-endpoints-and-dumb-pipes).”</span></span> <span data-ttu-id="e1c14-119">Ce slogan encourage une conception qui est dissocié que possible entre microservices et aussi cohérents que possible au sein d’un seul microservice.</span><span class="sxs-lookup"><span data-stu-id="e1c14-119">This slogan encourages a design that is as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="e1c14-120">Comme expliqué précédemment, chaque microservice possède ses propres données et sa propre logique de domaine.</span><span class="sxs-lookup"><span data-stu-id="e1c14-120">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="e1c14-121">Mais les composition d’une application de bout en bout de microservices sont généralement simplement précis en utilisant les communications reste plutôt que les protocoles complexes telles que WS -\* et flexibles communications pilotée par événements au lieu de centralisé processus-Business-orchestrators.</span><span class="sxs-lookup"><span data-stu-id="e1c14-121">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="e1c14-122">Les deux protocoles couramment utilisées sont demande/réponse HTTP avec l’API (lors de l’interrogation de la plupart des tous) de ressources et léger de messagerie asynchrone lors de la communication des mises à jour sur plusieurs microservices.</span><span class="sxs-lookup"><span data-stu-id="e1c14-122">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="e1c14-123">Ils sont expliqués plus en détail dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="e1c14-123">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="e1c14-124">Types de communication</span><span class="sxs-lookup"><span data-stu-id="e1c14-124">Communication types</span></span>

<span data-ttu-id="e1c14-125">Client et services puissent communiquer via différents types de communication, chacun d'entre eux ciblant un autre scénario et vos objectifs.</span><span class="sxs-lookup"><span data-stu-id="e1c14-125">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="e1c14-126">Au départ, ces types de communication peuvent être classées dans les deux axes.</span><span class="sxs-lookup"><span data-stu-id="e1c14-126">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="e1c14-127">Le premier axe consiste à définir si le protocole est synchrone ou asynchrone :</span><span class="sxs-lookup"><span data-stu-id="e1c14-127">The first axis is defining if the protocol is synchronous or asynchronous:</span></span>

-   <span data-ttu-id="e1c14-128">Protocole synchrone.</span><span class="sxs-lookup"><span data-stu-id="e1c14-128">Synchronous protocol.</span></span> <span data-ttu-id="e1c14-129">HTTP est un protocole synchrone.</span><span class="sxs-lookup"><span data-stu-id="e1c14-129">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="e1c14-130">Le client envoie une demande et attend une réponse du service.</span><span class="sxs-lookup"><span data-stu-id="e1c14-130">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="e1c14-131">Qui est indépendante de l’exécution du code client qui peut être synchrone (le thread est bloqué) ou asynchrone (thread n’est pas bloqué, et la réponse atteindra un rappel par la suite).</span><span class="sxs-lookup"><span data-stu-id="e1c14-131">That is independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread is not blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="e1c14-132">Le point important ici est que le protocole (HTTP/HTTPS) est synchrone et que le code client peut continuer uniquement sa tâche lorsqu’il reçoit la réponse du serveur HTTP.</span><span class="sxs-lookup"><span data-stu-id="e1c14-132">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

-   <span data-ttu-id="e1c14-133">Protocole asynchrone.</span><span class="sxs-lookup"><span data-stu-id="e1c14-133">Asynchronous protocol.</span></span> <span data-ttu-id="e1c14-134">D’autres protocoles comme AMQP (un protocole pris en charge par de nombreux systèmes d’exploitation et les environnements de cloud) utilisent des messages asynchrones.</span><span class="sxs-lookup"><span data-stu-id="e1c14-134">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="e1c14-135">Généralement, l’expéditeur du message ou le code client n’attend pas de réponse.</span><span class="sxs-lookup"><span data-stu-id="e1c14-135">The client code or message sender usually does not wait for a response.</span></span> <span data-ttu-id="e1c14-136">Il transmet le message en tant que lors de l’envoi d’un message à une file d’attente RabbitMQ ou tout autre service broker de message.</span><span class="sxs-lookup"><span data-stu-id="e1c14-136">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="e1c14-137">Le deuxième axe consiste à définir si la communication a un destinataire unique ou plusieurs destinataires :</span><span class="sxs-lookup"><span data-stu-id="e1c14-137">The second axis is defining if the communication has a single receiver or multiple receivers:</span></span>

-   <span data-ttu-id="e1c14-138">Destinataire unique.</span><span class="sxs-lookup"><span data-stu-id="e1c14-138">Single receiver.</span></span> <span data-ttu-id="e1c14-139">Chaque demande doit être traité par un seul récepteur ou service.</span><span class="sxs-lookup"><span data-stu-id="e1c14-139">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="e1c14-140">Un exemple de cette communication est la [modèle Command](https://en.wikipedia.org/wiki/Command_pattern).</span><span class="sxs-lookup"><span data-stu-id="e1c14-140">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

-   <span data-ttu-id="e1c14-141">Plusieurs destinataires.</span><span class="sxs-lookup"><span data-stu-id="e1c14-141">Multiple receivers.</span></span> <span data-ttu-id="e1c14-142">Chaque demande peut être traité par zéro à plusieurs destinataires.</span><span class="sxs-lookup"><span data-stu-id="e1c14-142">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="e1c14-143">Ce type de communication doit être asynchrone.</span><span class="sxs-lookup"><span data-stu-id="e1c14-143">This type of communication must be asynchronous.</span></span> <span data-ttu-id="e1c14-144">Par exemple le [de publication/abonnement](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mécanisme utilisé dans les modèles comme [pilotée par événements une architecture](http://microservices.io/patterns/data/event-driven-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="e1c14-144">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](http://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="e1c14-145">Il repose sur un broker de message ou d’interface de bus d’événements lors de la propagation des mises à jour des données entre plusieurs microservices via des événements ; Il est généralement implémenté via un bus de service ou un artefact similaire comme [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) à l’aide de [rubriques et abonnements](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="e1c14-145">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it is usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="e1c14-146">Une application basée sur les microservice utilisent souvent une combinaison de ces styles de communication.</span><span class="sxs-lookup"><span data-stu-id="e1c14-146">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="e1c14-147">Le type le plus courant est unique-récepteur la communication avec un protocole synchrone comme HTTP/HTTPS lors de l’appel d’un service Web API HTTP normal.</span><span class="sxs-lookup"><span data-stu-id="e1c14-147">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="e1c14-148">Microservices utilisent également généralement les protocoles de messagerie pour la communication asynchrone entre microservices.</span><span class="sxs-lookup"><span data-stu-id="e1c14-148">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="e1c14-149">Ces axes sont important de connaître afin d’avoir plus de clarté sur les mécanismes de communication possibles, mais ils ne sont pas des préoccupations importantes lors de la création de microservices.</span><span class="sxs-lookup"><span data-stu-id="e1c14-149">These axes are good to know so you have clarity on the possible communication mechanisms, but they are not the important concerns when building microservices.</span></span> <span data-ttu-id="e1c14-150">La nature asynchrone de l’exécution dans le thread de client sans la nature asynchrone du protocole sélectionné sont les points importants lors de l’intégration de microservices.</span><span class="sxs-lookup"><span data-stu-id="e1c14-150">The asynchronous nature of client thread execution not even the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="e1c14-151">Ce que *est* important est en cours d’intégrer votre microservices asynchrone tout en conservant l’indépendance des microservices, comme expliqué dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="e1c14-151">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="e1c14-152">Intégration de microservice asynchrone applique l’autonomie de microservice.</span><span class="sxs-lookup"><span data-stu-id="e1c14-152">Asynchronous microservice integration enforces microservice’s autonomy</span></span>

<span data-ttu-id="e1c14-153">Comme indiqué, le point important lors de la création d’une application basée sur des microservices est celle que vous intégrez votre microservices.</span><span class="sxs-lookup"><span data-stu-id="e1c14-153">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="e1c14-154">Dans l’idéal, vous essayez de réduire la communication entre le microservices interne.</span><span class="sxs-lookup"><span data-stu-id="e1c14-154">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="e1c14-155">Le moins les communications entre microservices, mieux ce.</span><span class="sxs-lookup"><span data-stu-id="e1c14-155">The less communications between microservices, the better.</span></span> <span data-ttu-id="e1c14-156">Mais bien entendu, dans de nombreux cas vous devez intégrer une certaine manière du microservices.</span><span class="sxs-lookup"><span data-stu-id="e1c14-156">But of course, in many cases you will have to somehow integrate the microservices.</span></span> <span data-ttu-id="e1c14-157">Lorsque vous avez besoin pour ce faire, la règle essentielle ici est que la communication entre le microservices doit être asynchrone.</span><span class="sxs-lookup"><span data-stu-id="e1c14-157">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="e1c14-158">Cela ne signifie pas que vous devez utiliser un protocole spécifique (par exemple, une messagerie asynchrone ou synchrone HTTP).</span><span class="sxs-lookup"><span data-stu-id="e1c14-158">That does not mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="e1c14-159">Cela signifie simplement que la communication entre microservices doit être effectuée uniquement par la propagation des données de façon asynchrone, mais essayez de ne pas dépendent d’autres microservices interne dans le cadre de l’opération de demande/réponse HTTP du service initial.</span><span class="sxs-lookup"><span data-stu-id="e1c14-159">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service’s HTTP request/response operation.</span></span>

<span data-ttu-id="e1c14-160">Si possible, jamais dépendent de communication synchrone (requête/réponse) entre plusieurs microservices, même pour les requêtes.</span><span class="sxs-lookup"><span data-stu-id="e1c14-160">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="e1c14-161">L’objectif de chaque microservice doit être autonome et disponible pour le consommateur du client, même si les autres services qui font partie de l’application de bout en bout sont en panne ou défectueux.</span><span class="sxs-lookup"><span data-stu-id="e1c14-161">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="e1c14-162">Si vous pensez que vous avez besoin effectuer un appel à partir d’un microservice à d’autres microservices (par exemple, l’exécution d’une requête HTTP pour une requête de données) dans afin d’être en mesure de fournir une réponse à une application cliente, vous disposez d’une architecture qui ne sera pas résiliente quand certains Échec de microservices.</span><span class="sxs-lookup"><span data-stu-id="e1c14-162">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) in order to be able to provide a response to a client application, you have an architecture that will not be resilient when some microservices fail.</span></span>

<span data-ttu-id="e1c14-163">En outre, votre microservices ayant des dépendances HTTP entre microservices, comme lors de la création de longs cycles de demande/réponse avec HTTP demande chaînes, comme indiqué dans la première partie de la Figure 4-15, seulement ne rend pas autonome mais aussi leurs performances affectés dès que l’un des services dans cette chaîne n’effectue pas correctement.</span><span class="sxs-lookup"><span data-stu-id="e1c14-163">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain is not performing well.</span></span> 

<span data-ttu-id="e1c14-164">Plus vous ajoutez des dépendances synchrones entre microservices, comme les demandes de requête, plus le temps de réponse global obtient pour les applications clientes.</span><span class="sxs-lookup"><span data-stu-id="e1c14-164">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![](./media/image15.png)

<span data-ttu-id="e1c14-165">**Figure 4-15**.</span><span class="sxs-lookup"><span data-stu-id="e1c14-165">**Figure 4-15**.</span></span> <span data-ttu-id="e1c14-166">Anti-modèles et modèles de communication entre microservices</span><span class="sxs-lookup"><span data-stu-id="e1c14-166">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="e1c14-167">Si votre microservice doit déclencher une action supplémentaire dans un autre microservice, si possible, n’effectuez pas cette action de façon synchrone et dans le cadre de l’opération de demande et réponse microservice d’origine.</span><span class="sxs-lookup"><span data-stu-id="e1c14-167">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="e1c14-168">Effectuez plutôt de façon asynchrone (à l’aide de la messagerie asynchrone ou les événements d’intégration, les files d’attente, etc.).</span><span class="sxs-lookup"><span data-stu-id="e1c14-168">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="e1c14-169">Toutefois, autant que possible, ne pas appeler l’action de façon synchrone dans le cadre de l’opération de demande et de réponse synchrone d’origine.</span><span class="sxs-lookup"><span data-stu-id="e1c14-169">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="e1c14-170">Et enfin (et il s’agit d’où la plupart des problèmes surviennent lors de la génération des microservices), si votre microservice initiale nécessite des données qui appartient à l’origine par les autres microservices, ne comptez pas sur effectuant des demandes synchrones pour ces données.</span><span class="sxs-lookup"><span data-stu-id="e1c14-170">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that is originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="e1c14-171">Au lieu de cela, répliquer ou propager ces données (uniquement les attributs) dans la base de données du service initial à l’aide de la cohérence éventuelle (généralement par à l’aide des événements d’intégration, comme expliqué dans les prochaines sections).</span><span class="sxs-lookup"><span data-stu-id="e1c14-171">Instead, replicate or propagate that data (only the attributes you need) into the initial service’s database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="e1c14-172">Comme indiqué précédemment dans la section [identification des limites de modèle de domaine pour chaque microservice](#identifying-domain-model-boundaries-for-each-microservice), duplication des données entre plusieurs microservices n’est pas une conception incorrecte, au contraire, lorsque effectuant que vous pouvez traduire les données dans la langue spécifique ou les termes de ce domaine supplémentaire ou d’un contexte de limitées.</span><span class="sxs-lookup"><span data-stu-id="e1c14-172">As noted earlier in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice), duplicating some data across several microservices is not an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="e1c14-173">Par exemple, dans le [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) application que vous avez un microservice nommé identity.api qui est responsable de la plupart des données de l’utilisateur avec une entité nommée utilisateur.</span><span class="sxs-lookup"><span data-stu-id="e1c14-173">For instance, in the [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) application you have a microservice named identity.api that is in charge of most of the user’s data with an entity named User.</span></span> <span data-ttu-id="e1c14-174">Toutefois, lorsque vous avez besoin stocker les données relatives à l’utilisateur dans le classement microservice, vous le stocker en tant qu’une autre entité nommée acheteur.</span><span class="sxs-lookup"><span data-stu-id="e1c14-174">However, when you need to store data about the user within the Ordering microservice, you store it as a different entity named Buyer.</span></span> <span data-ttu-id="e1c14-175">L’entité de l’acheteur partage la même identité avec l’entité d’utilisateur d’origine, mais il peut avoir uniquement le peu d’attributs requis par le domaine de classement et pas le profil utilisateur entière.</span><span class="sxs-lookup"><span data-stu-id="e1c14-175">The Buyer entity shares the same identity with the original User entity, but it might have only the few attributes needed by the Ordering domain, and not the whole user profile.</span></span>

<span data-ttu-id="e1c14-176">Vous pouvez utiliser n’importe quel protocole de communiquer et de propagation des données de façon asynchrone entre microservices pour disposer de la cohérence éventuelle.</span><span class="sxs-lookup"><span data-stu-id="e1c14-176">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="e1c14-177">Comme mentionné, vous pouvez utiliser les événements d’intégration à l’aide d’un bus d’événements ou d’un message broker, ou vous pouvez même utiliser HTTP en interrogeant les autres services à la place.</span><span class="sxs-lookup"><span data-stu-id="e1c14-177">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="e1c14-178">Il n’a pas d’importance.</span><span class="sxs-lookup"><span data-stu-id="e1c14-178">It does not matter.</span></span> <span data-ttu-id="e1c14-179">La règle importante est de ne pas créer de dépendances synchrones entre votre microservices.</span><span class="sxs-lookup"><span data-stu-id="e1c14-179">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="e1c14-180">Les sections suivantes expliquent les styles de communication plusieurs, que vous pouvez envisager d’utiliser dans une application basée sur un microservice.</span><span class="sxs-lookup"><span data-stu-id="e1c14-180">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="e1c14-181">Styles de communication</span><span class="sxs-lookup"><span data-stu-id="e1c14-181">Communication styles</span></span>

<span data-ttu-id="e1c14-182">Il existe de nombreux protocoles et les choix que vous pouvez utiliser pour la communication, en fonction du type de communication que vous souhaitez utiliser.</span><span class="sxs-lookup"><span data-stu-id="e1c14-182">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="e1c14-183">Si vous utilisez un mécanisme de communication synchrone de demande/réponse de, protocoles tels que HTTP et autres approches sont les plus courantes, notamment si vous publiez vos services hors du cluster hôte ou microservice de Docker.</span><span class="sxs-lookup"><span data-stu-id="e1c14-183">If you are using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you are publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="e1c14-184">Si vous communiquez entre les services en interne (au sein de votre cluster hôte ou microservices Docker) vous souhaiterez également utiliser les mécanismes de communication de format binaire (par exemple, la communication à distance du Service Fabric ou WCF à l’aide de TCP et au format binaire).</span><span class="sxs-lookup"><span data-stu-id="e1c14-184">If you are communicating between services internally (within your Docker host or microservices cluster) you might also want to use binary format communication mechanisms (like Service Fabric remoting or WCF using TCP and binary format).</span></span> <span data-ttu-id="e1c14-185">Vous pouvez également utiliser les mécanismes de communication asynchrone basée sur message, tels que AMQP.</span><span class="sxs-lookup"><span data-stu-id="e1c14-185">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="e1c14-186">Il existe également plusieurs message formats comme JSON ou XML, ou même binaire, qui peut être plus efficace.</span><span class="sxs-lookup"><span data-stu-id="e1c14-186">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="e1c14-187">Si votre format binaire choisi n’est pas un standard, il n’est probablement pas judicieux de publiquement publier vos services à l’aide de ce format.</span><span class="sxs-lookup"><span data-stu-id="e1c14-187">If your chosen binary format is not a standard, it is probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="e1c14-188">Vous pouvez utiliser un format non standard pour la communication interne entre votre microservices.</span><span class="sxs-lookup"><span data-stu-id="e1c14-188">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="e1c14-189">Vous pouvez effectuer cela lors de la communication entre microservices dans votre cluster Docker hôte ou microservice (orchestrators de Docker ou Azure Service Fabric), ou pour les applications clientes propriétaire qui communique avec le microservices.</span><span class="sxs-lookup"><span data-stu-id="e1c14-189">You might do this when communicating between microservices within your Docker host or microservice cluster (Docker orchestrators or Azure Service Fabric), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="e1c14-190">Communication demande/réponse HTTP et REST</span><span class="sxs-lookup"><span data-stu-id="e1c14-190">Request/response communication with HTTP and REST</span></span> 

<span data-ttu-id="e1c14-191">Lorsqu’un client utilise une communication demande/réponse, il envoie une demande à un service, puis le service traite la demande et renvoie une réponse.</span><span class="sxs-lookup"><span data-stu-id="e1c14-191">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="e1c14-192">Communication de demande/réponse est particulièrement bien adaptée pour interroger des données pour une interface utilisateur en temps réel (une interface utilisateur dynamique) à partir d’applications clientes.</span><span class="sxs-lookup"><span data-stu-id="e1c14-192">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="e1c14-193">Par conséquent, dans une architecture de microservice vous allez probablement utiliser ce mécanisme de communication pour la plupart des requêtes, comme indiqué dans la Figure 4-16.</span><span class="sxs-lookup"><span data-stu-id="e1c14-193">Therefore, in a microservice architecture you will probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![](./media/image16.png)

<span data-ttu-id="e1c14-194">**Figure 4-16**.</span><span class="sxs-lookup"><span data-stu-id="e1c14-194">**Figure 4-16**.</span></span> <span data-ttu-id="e1c14-195">À l’aide de la communication demande/réponse HTTP (synchrone ou asynchrone)</span><span class="sxs-lookup"><span data-stu-id="e1c14-195">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="e1c14-196">Lorsqu’un client utilise une communication demande/réponse, il suppose que la réponse arriveront dans une courte période, en général moins d’une seconde ou quelques secondes au maximum.</span><span class="sxs-lookup"><span data-stu-id="e1c14-196">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="e1c14-197">Pour les réponses différées, vous devez implémenter la communication asynchrone basée sur [modèles de messagerie](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) et [technologies de messagerie](https://en.wikipedia.org/wiki/Message-oriented_middleware), qui est une approche différente qui nous expliquons dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="e1c14-197">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="e1c14-198">Un style populaires architectural pour la communication de demande/réponse est [reste](https://en.wikipedia.org/wiki/Representational_state_transfer).</span><span class="sxs-lookup"><span data-stu-id="e1c14-198">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="e1c14-199">Cette approche est basée sur et étroitement couplée, les [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) de protocole, adoptent les verbes HTTP tels que GET, POST et le placer.</span><span class="sxs-lookup"><span data-stu-id="e1c14-199">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="e1c14-200">REST est l’approche architecturale communication couramment utilisées lors de la création de services.</span><span class="sxs-lookup"><span data-stu-id="e1c14-200">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="e1c14-201">Vous pouvez implémenter des services REST lorsque vous développez des services de l’API Web ASP.NET principale.</span><span class="sxs-lookup"><span data-stu-id="e1c14-201">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="e1c14-202">A une valeur supplémentaire à l’aide des services HTTP REST comme votre langage de définition d’interface.</span><span class="sxs-lookup"><span data-stu-id="e1c14-202">There is additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="e1c14-203">Par exemple, si vous utilisez [Swagger métadonnées](http://swagger.io/) pour décrire votre API de service, vous pouvez utiliser les outils qui génèrent des stubs de client peuvent directement de détecter et d’utiliser vos services.</span><span class="sxs-lookup"><span data-stu-id="e1c14-203">For instance, if you use [Swagger metadata](http://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="e1c14-204">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="e1c14-204">Additional resources</span></span>

-   <span data-ttu-id="e1c14-205">**Martin Fowler. Richardson Maturity Model.**</span><span class="sxs-lookup"><span data-stu-id="e1c14-205">**Martin Fowler. Richardson Maturity Model.**</span></span> <span data-ttu-id="e1c14-206">Description du modèle REST.</span><span class="sxs-lookup"><span data-stu-id="e1c14-206">A description of the REST model.</span></span>
    [<span data-ttu-id="e1c14-207">*http://martinfowler.com/articles/richardsonMaturityModel.HTML*</span><span class="sxs-lookup"><span data-stu-id="e1c14-207">*http://martinfowler.com/articles/richardsonMaturityModel.html*</span></span>](http://martinfowler.com/articles/richardsonMaturityModel.html)

-   <span data-ttu-id="e1c14-208">**Swagger.**</span><span class="sxs-lookup"><span data-stu-id="e1c14-208">**Swagger.**</span></span> <span data-ttu-id="e1c14-209">Le site officiel.</span><span class="sxs-lookup"><span data-stu-id="e1c14-209">The official site.</span></span>
    [<span data-ttu-id="e1c14-210">*http://swagger.IO/*</span><span class="sxs-lookup"><span data-stu-id="e1c14-210">*http://swagger.io/*</span></span>](http://swagger.io/)

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="e1c14-211">Push et communication en temps réel basés sur HTTP</span><span class="sxs-lookup"><span data-stu-id="e1c14-211">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="e1c14-212">Une autre possibilité (généralement fins différentes reste) est une communication un-à-plusieurs et en temps réel avec les infrastructures de niveau supérieur telles que [ASP.NET SignalR](https://www.asp.net/signalr) et protocoles tels que [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span><span class="sxs-lookup"><span data-stu-id="e1c14-212">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="e1c14-213">Comme le montre la Figure 4-17, la communication HTTP en temps réel signifie que vous pouvez avoir le code serveur en exécutant un push contenu aux clients connectés à mesure que les données disponibles, au lieu du serveur attendre un client demander de nouvelles données.</span><span class="sxs-lookup"><span data-stu-id="e1c14-213">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![](./media/image17.png)

<span data-ttu-id="e1c14-214">**Figure 4-17**.</span><span class="sxs-lookup"><span data-stu-id="e1c14-214">**Figure 4-17**.</span></span> <span data-ttu-id="e1c14-215">Communication d’un message d’asynchrone en temps réel</span><span class="sxs-lookup"><span data-stu-id="e1c14-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="e1c14-216">Étant donné que la communication est en temps réel, les applications clientes affichent les modifications quasiment instantanément.</span><span class="sxs-lookup"><span data-stu-id="e1c14-216">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="e1c14-217">Cela est généralement gérée par un protocole tel que WebSockets, à l’aide de nombreuses connexions WebSocket (un par client).</span><span class="sxs-lookup"><span data-stu-id="e1c14-217">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="e1c14-218">Un exemple classique est lorsqu’un service communique une modification dans le score d’un jeu de sports pour beaucoup d’applications web client simultanément.</span><span class="sxs-lookup"><span data-stu-id="e1c14-218">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="e1c14-219">[Précédente] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [suivant] (asynchrone-message-base-communication.md)</span><span class="sxs-lookup"><span data-stu-id="e1c14-219">[Previous] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [Next] (asynchronous-message-based-communication.md)</span></span>
