---
title: Architectures courantes des applications web
description: Architecturer des applications web modernes avec ASP.NET Core et Microsoft Azure | Architectures courantes des applications web
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.openlocfilehash: cb9a1d68d4c7c66c6adab3a5e932ee37c3ea22b0
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/29/2018
ms.locfileid: "37106421"
---
# <a name="common-web-application-architectures"></a><span data-ttu-id="01de0-103">Architectures courantes des applications web</span><span class="sxs-lookup"><span data-stu-id="01de0-103">Common Web Application Architectures</span></span>

> <span data-ttu-id="01de0-104">« Si vous pensez qu’une bonne architecture est coûteuse, faites l’expérience d’une mauvaise architecture. »</span><span class="sxs-lookup"><span data-stu-id="01de0-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="01de0-105">_- Brian Foote et Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="01de0-105">_- Brian Foote and Joseph Yoder_</span></span>

## <a name="summary"></a><span data-ttu-id="01de0-106">Récapitulatif</span><span class="sxs-lookup"><span data-stu-id="01de0-106">Summary</span></span>

<span data-ttu-id="01de0-107">La plupart des applications .NET conventionnelles sont déployées sous forme d’unités individuelles qui correspondent à un exécutable ou à une application web unique s’exécutant dans un seul domaine d’application IIS.</span><span class="sxs-lookup"><span data-stu-id="01de0-107">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="01de0-108">C’est le modèle de déploiement le plus simple, qui convient parfaitement à beaucoup d’applications internes et applications publiques de petite taille.</span><span class="sxs-lookup"><span data-stu-id="01de0-108">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="01de0-109">Toutefois, même avec ce déploiement en unités individuelles, la majorité des applications métier non triviales tirent avantage à avoir leur logique séparée en plusieurs couches.</span><span class="sxs-lookup"><span data-stu-id="01de0-109">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="01de0-110">Qu’est-ce qu’une application monolithique ?</span><span class="sxs-lookup"><span data-stu-id="01de0-110">What is a monolithic application?</span></span>

<span data-ttu-id="01de0-111">Une application monolithique est une application qui se comporte de façon totalement autonome.</span><span class="sxs-lookup"><span data-stu-id="01de0-111">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="01de0-112">Elle peut avoir des interactions avec d’autres services ou magasins de données pendant son exécution, mais son comportement est fondamentalement géré en interne. L’ensemble de l’application est généralement déployée comme une seule unité.</span><span class="sxs-lookup"><span data-stu-id="01de0-112">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="01de0-113">Quand une application monolithique doit faire l’objet d’une mise à l’échelle horizontale, en général, l’application entière est dupliquée sur plusieurs serveurs ou machines virtuelles.</span><span class="sxs-lookup"><span data-stu-id="01de0-113">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="01de0-114">Des applications tout-en-un</span><span class="sxs-lookup"><span data-stu-id="01de0-114">All-in-One applications</span></span>

<span data-ttu-id="01de0-115">L’architecture d’une application peut se réduire à un seul projet.</span><span class="sxs-lookup"><span data-stu-id="01de0-115">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="01de0-116">Dans cette architecture, toute la logique de l’application est contenue dans un seul projet, compilé dans un assembly unique et déployé comme une seule unité.</span><span class="sxs-lookup"><span data-stu-id="01de0-116">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="01de0-117">Tout nouveau projet ASP.NET Core, créé dans Visual Studio ou à partir de la ligne de commande, est au début une simple application monolithique « tout-en-un ».</span><span class="sxs-lookup"><span data-stu-id="01de0-117">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="01de0-118">Le projet contient le comportement complet de l’application, y compris la logique de présentation, métier et d’accès aux données.</span><span class="sxs-lookup"><span data-stu-id="01de0-118">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="01de0-119">La figure 5-1 montre la structure de fichiers d’une application à projet unique.</span><span class="sxs-lookup"><span data-stu-id="01de0-119">Figure 5-1 shows the file structure of a single-project app.</span></span>

<span data-ttu-id="01de0-120">**Figure 5-1.**</span><span class="sxs-lookup"><span data-stu-id="01de0-120">**Figure 5-1.**</span></span> <span data-ttu-id="01de0-121">Application ASP.NET Core à projet unique</span><span class="sxs-lookup"><span data-stu-id="01de0-121">A single project ASP.NET Core app</span></span>

![](./media/image5-1.png)

<span data-ttu-id="01de0-122">Dans un scénario de projet unique, la séparation des préoccupations s’obtient par l’utilisation de dossiers.</span><span class="sxs-lookup"><span data-stu-id="01de0-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="01de0-123">Le modèle par défaut inclut des dossiers distincts pour les responsabilités des modèles, vues et contrôleurs du schéma MVC, ainsi que des dossiers supplémentaires pour les services et les données.</span><span class="sxs-lookup"><span data-stu-id="01de0-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="01de0-124">Dans cette organisation, les détails de présentation doivent être limités autant que possible au dossier Vues, et les détails d’implémentation de l’accès aux données doivent être limités aux classes stockées dans le dossier Données.</span><span class="sxs-lookup"><span data-stu-id="01de0-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="01de0-125">La logique métier doit résider dans les services et les classes contenus dans le dossier Modèles.</span><span class="sxs-lookup"><span data-stu-id="01de0-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="01de0-126">La solution monolithique à projet unique est simple, mais elle présente certains inconvénients.</span><span class="sxs-lookup"><span data-stu-id="01de0-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="01de0-127">Le nombre de fichiers et de dossiers augmente à mesure que le projet grossit et devient plus complexe.</span><span class="sxs-lookup"><span data-stu-id="01de0-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="01de0-128">Les préoccupations de l’interface utilisateur (modèles, vues, contrôleurs) sont réparties entre plusieurs dossiers qui ne sont pas regroupés par ordre alphabétique.</span><span class="sxs-lookup"><span data-stu-id="01de0-128">UI concerns (models, views, controllers) reside in multiple folders, which are not grouped together alphabetically.</span></span> <span data-ttu-id="01de0-129">Cela devient un réel problème quand des constructions de niveau interface utilisateur supplémentaires, telles que des filtres ou des classeurs de modèles (ModelBinder), sont ajoutées dans leurs propres dossiers.</span><span class="sxs-lookup"><span data-stu-id="01de0-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="01de0-130">La logique métier est répartie entre les dossiers Modèles et les dossiers Services, mais les dépendances entre les classes contenues dans ces dossiers ne sont pas clairement indiquées.</span><span class="sxs-lookup"><span data-stu-id="01de0-130">Business logic is scattered between the Models and Services folders, and there is no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="01de0-131">Cette mauvaise organisation au niveau du projet se traduit fréquemment par la création de [code spaghetti](http://deviq.com/spaghetti-code/).</span><span class="sxs-lookup"><span data-stu-id="01de0-131">This lack of organization at the project level frequently leads to [spaghetti code](http://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="01de0-132">Pour résoudre ces problèmes, les applications se transforment souvent en solutions à projets multiples, où chaque projet est censé résider dans une *couche* spécifique de l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-132">In order to address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular *layer* of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="01de0-133">Qu’est-ce qu’une architecture en couches ?</span><span class="sxs-lookup"><span data-stu-id="01de0-133">What are layers?</span></span>

<span data-ttu-id="01de0-134">Quand une application devient complexe, un moyen de gérer cette complexité est de scinder l’application en fonction de ses responsabilités ou préoccupations.</span><span class="sxs-lookup"><span data-stu-id="01de0-134">As applications grow in complexity, one way to manage that complexity is to break the application up according to its responsibilities or concerns.</span></span> <span data-ttu-id="01de0-135">Basée sur le principe de séparation des préoccupations, cette solution contribue à maintenir le code base parfaitement organisé à mesure qu’il grossit, ce qui permet aux développeurs de retrouver facilement les fonctionnalités implémentées.</span><span class="sxs-lookup"><span data-stu-id="01de0-135">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="01de0-136">L’architecture en couches offre d’autres avantages que la simple organisation du code.</span><span class="sxs-lookup"><span data-stu-id="01de0-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="01de0-137">En effet, l’organisation du code en couches permet également la réutilisation des fonctionnalités communes de bas niveau dans l’ensemble de l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="01de0-138">Cette possibilité est intéressante, car elle réduit la quantité de code à écrire et permet la normalisation de l’application sur une implémentation unique, selon le principe DRY (« Ne vous répétez pas »).</span><span class="sxs-lookup"><span data-stu-id="01de0-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the DRY principle.</span></span>

<span data-ttu-id="01de0-139">Avec une architecture en couches, les applications peuvent appliquer des restrictions sur les échanges autorisés entre les différentes couches.</span><span class="sxs-lookup"><span data-stu-id="01de0-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="01de0-140">Cela contribue à améliorer l’encapsulation.</span><span class="sxs-lookup"><span data-stu-id="01de0-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="01de0-141">De cette façon, quand une couche est modifiée ou remplacée, seules les couches qui interagissent avec elle sont impactées.</span><span class="sxs-lookup"><span data-stu-id="01de0-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="01de0-142">En limitant l’interdépendance des couches, l’impact des modifications peut être atténué afin qu’une modification donnée n’impacte pas l’application entière.</span><span class="sxs-lookup"><span data-stu-id="01de0-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="01de0-143">Les couches (et l’encapsulation) facilitent le remplacement des fonctionnalités dans l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="01de0-144">Par exemple, une application peut initialement utiliser sa propre base de données SQL Server pour la persistance, mais plus tard choisir d’utiliser une stratégie de persistance basée sur le cloud ou située derrière une API web.</span><span class="sxs-lookup"><span data-stu-id="01de0-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="01de0-145">Si l’application a correctement encapsulé son implémentation de persistance au sein d’une couche logique, cette couche spécifique de SQL Server peut être remplacée par une nouvelle couche qui implémente la même interface publique.</span><span class="sxs-lookup"><span data-stu-id="01de0-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="01de0-146">Outre la possibilité de permuter des implémentations en réponse à des changements ultérieurs dans les exigences, les couches d’application facilitent également la permutation des implémentations pour les besoins de test.</span><span class="sxs-lookup"><span data-stu-id="01de0-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="01de0-147">Au lieu d’écrire des tests qui s’exécutent sur la couche des données réelles ou sur la couche de l’interface utilisateur de l’application, vous pouvez remplacer ces couches durant la phase de test par des implémentations fictives qui fournissent des réponses connues aux requêtes.</span><span class="sxs-lookup"><span data-stu-id="01de0-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="01de0-148">Cette possibilité simplifie considérablement l’écriture des tests et rend leur exécution beaucoup plus rapide par rapport à l’exécution de tests dans l’infrastructure réelle de l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-148">This typically makes tests much easier to write and much faster to run when compared to running tests again the application's real infrastructure.</span></span>

<span data-ttu-id="01de0-149">La mise en couches logiques est une technique courante pour améliorer l’organisation du code dans les applications d’entreprise. Le code peut être organisé en couches de plusieurs façons.</span><span class="sxs-lookup"><span data-stu-id="01de0-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
> <span data-ttu-id="01de0-150">Les *couches* représentent une séparation logique au sein de l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-150">*Layers* represent logical separation within the application.</span></span> <span data-ttu-id="01de0-151">Si la logique de l’application est répartie physiquement entre plusieurs serveurs ou processus séparés, ces différentes cibles de déploiement physiques sont appelées *niveaux*.</span><span class="sxs-lookup"><span data-stu-id="01de0-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as *tiers*.</span></span> <span data-ttu-id="01de0-152">Il est possible, et relativement courant, de déployer une application en N couches sur un seul niveau.</span><span class="sxs-lookup"><span data-stu-id="01de0-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="01de0-153">Applications avec une architecture en N couches conventionnelle</span><span class="sxs-lookup"><span data-stu-id="01de0-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="01de0-154">La figure 5-2 illustre l’organisation la plus courante d’une logique d’application en couches.</span><span class="sxs-lookup"><span data-stu-id="01de0-154">The most common organization of application logic into layers it shown in Figure 5-2.</span></span>

<span data-ttu-id="01de0-155">**Figure 5-2.**</span><span class="sxs-lookup"><span data-stu-id="01de0-155">**Figure 5-2.**</span></span> <span data-ttu-id="01de0-156">Couches d’application classiques.</span><span class="sxs-lookup"><span data-stu-id="01de0-156">Typical application layers.</span></span>

![](./media/image5-2.png)

<span data-ttu-id="01de0-157">Ces couches sont souvent abrégées comme ceci : UI (couche d’interface utilisateur), BLL (couche métier) et DAL (couche d’accès aux données).</span><span class="sxs-lookup"><span data-stu-id="01de0-157">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="01de0-158">Avec cette architecture, les utilisateurs effectuent des requêtes par le biais de la couche UI, qui interagit uniquement avec la couche BLL.</span><span class="sxs-lookup"><span data-stu-id="01de0-158">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="01de0-159">La couche BLL, à son tour, peut appeler la couche DAL pour les requêtes d’accès aux données.</span><span class="sxs-lookup"><span data-stu-id="01de0-159">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="01de0-160">La couche UI ne doit pas faire de requêtes directes à la couche DAL, ni interagir avec persistance directement par d’autres moyens.</span><span class="sxs-lookup"><span data-stu-id="01de0-160">The UI layer should not make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="01de0-161">De même, la couche BLL doit uniquement interagir avec persistance en passant par la couche DAL.</span><span class="sxs-lookup"><span data-stu-id="01de0-161">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="01de0-162">De cette manière, chaque couche a sa propre responsabilité connue.</span><span class="sxs-lookup"><span data-stu-id="01de0-162">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="01de0-163">Cette approche en couches classique a un inconvénient, à savoir que les dépendances de compilation s’exécutent de haut en bas.</span><span class="sxs-lookup"><span data-stu-id="01de0-163">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="01de0-164">Autrement dit, la couche UI dépend de la couche BLL, qui dépend elle-même de la couche DAL.</span><span class="sxs-lookup"><span data-stu-id="01de0-164">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="01de0-165">La couche BLL, qui contient généralement la logique la plus importante de l’application, est dépendante des détails d’implémentation de l’accès aux données (et souvent de l’existence d’une base de données).</span><span class="sxs-lookup"><span data-stu-id="01de0-165">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="01de0-166">Il est souvent difficile de tester la logique métier dans ce type d’architecture, car il faut utiliser une base de données de test.</span><span class="sxs-lookup"><span data-stu-id="01de0-166">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="01de0-167">Le principe d’inversion des dépendances peut être une solution à ce problème, comme vous le verrez dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="01de0-167">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="01de0-168">La figure 5-3 montre un exemple de solution qui scinde l’application en trois projets par responsabilité (ou couche).</span><span class="sxs-lookup"><span data-stu-id="01de0-168">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

<span data-ttu-id="01de0-169">**Figure 5-3.**</span><span class="sxs-lookup"><span data-stu-id="01de0-169">**Figure 5-3.**</span></span> <span data-ttu-id="01de0-170">Application monolithique simple constituée de trois projets.</span><span class="sxs-lookup"><span data-stu-id="01de0-170">A simple monolithic application with three projects.</span></span>

![](./media/image5-3.png)

<span data-ttu-id="01de0-171">Cette application utilise plusieurs projets à des fins d’organisation, mais en réalité, elle est déployée comme une seule unité, et ses clients interagissent avec elle en la considérant comme une application web unique.</span><span class="sxs-lookup"><span data-stu-id="01de0-171">Although this application uses several projects for organizational purposes, it is still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="01de0-172">Cela simplifie nettement le processus de déploiement.</span><span class="sxs-lookup"><span data-stu-id="01de0-172">This allows for very simple deployment process.</span></span> <span data-ttu-id="01de0-173">La figure 5-4 montre comment Microsoft Azure peut héberger ce type d’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-173">Figure 5-4 shows how such an app might be hosted using Windows Azure.</span></span>

![](./media/image5-4.png)

<span data-ttu-id="01de0-174">**Figure 5-4.**</span><span class="sxs-lookup"><span data-stu-id="01de0-174">**Figure 5-4.**</span></span> <span data-ttu-id="01de0-175">Déploiement simple d’une application web Azure</span><span class="sxs-lookup"><span data-stu-id="01de0-175">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="01de0-176">Quand l’application doit grossir, des solutions de déploiement plus complexes et robustes peuvent être nécessaires.</span><span class="sxs-lookup"><span data-stu-id="01de0-176">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="01de0-177">La figure 5-5 montre un exemple de plan de déploiement plus complexe qui prend en charge des fonctionnalités supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="01de0-177">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

<span data-ttu-id="01de0-178">**Figure 5-5.**</span><span class="sxs-lookup"><span data-stu-id="01de0-178">**Figure 5-5.**</span></span> <span data-ttu-id="01de0-179">Déploiement d’une application web sur Azure App Service</span><span class="sxs-lookup"><span data-stu-id="01de0-179">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="01de0-180">En interne, l’organisation de ce projet en plusieurs projets par responsabilité facilite la maintenance de l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-180">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="01de0-181">Il est possible d’augmenter ou de diminuer la taille des instances de cette unité pour tirer parti de l’extensibilité à la demande sur le cloud.</span><span class="sxs-lookup"><span data-stu-id="01de0-181">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="01de0-182">L’augmentation de la taille des instances revient à ajouter de l’UC, de la mémoire, de l’espace disque ou d’autres ressources sur le ou les serveurs qui hébergent votre application.</span><span class="sxs-lookup"><span data-stu-id="01de0-182">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="01de0-183">La diminution de la taille des instances revient à ajouter des instances supplémentaires de ces serveurs (physiques ou virtuels).</span><span class="sxs-lookup"><span data-stu-id="01de0-183">Scaling out means adding additional instances of such servers, whether these are physical servers or virtual machines.</span></span> <span data-ttu-id="01de0-184">Quand votre application est hébergée sur plusieurs instances, un équilibreur de charge assigne les requêtes aux différentes instances de l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-184">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="01de0-185">L’approche la plus simple pour mettre à l’échelle une application web dans Azure est de configurer la mise à l’échelle manuellement dans le plan App Service de l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-185">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="01de0-186">La figure 5-6 illustre le tableau de bord Azure qui permet de configurer le nombre d’instances d’une application.</span><span class="sxs-lookup"><span data-stu-id="01de0-186">Figure 5-6 show the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

<span data-ttu-id="01de0-187">**Figure 5-6.**</span><span class="sxs-lookup"><span data-stu-id="01de0-187">**Figure 5-6.**</span></span> <span data-ttu-id="01de0-188">Mise à l’échelle du plan App Service dans Azure.</span><span class="sxs-lookup"><span data-stu-id="01de0-188">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="01de0-189">Architecture propre</span><span class="sxs-lookup"><span data-stu-id="01de0-189">Clean architecture</span></span>

<span data-ttu-id="01de0-190">Les applications conçues selon le principe d’inversion des dépendances et les principes DDD (conception pilotée par le domaine) présentent plus ou moins la même architecture.</span><span class="sxs-lookup"><span data-stu-id="01de0-190">Applications that follow the Dependency Inversion Principle as well as Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="01de0-191">Les noms donnés à cette architecture ont beaucoup varié au fil des années.</span><span class="sxs-lookup"><span data-stu-id="01de0-191">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="01de0-192">Au début, on l’a nommée architecture hexagonale, puis architecture ports-adaptateurs.</span><span class="sxs-lookup"><span data-stu-id="01de0-192">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="01de0-193">Plus récemment, on l’a appelée [architecture en oignon](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) ou [architecture propre](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="01de0-193">More recently, it's been cited as the [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="01de0-194">C’est le terme d’architecture propre que nous allons principalement utiliser dans ce livre électronique pour décrire l’architecture.</span><span class="sxs-lookup"><span data-stu-id="01de0-194">It is this last name, Clean Architecture, that is used as the basis for describing the architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="01de0-195">Ce terme s’applique aussi bien aux applications conçues selon les principes DDD qu’à celles qui ne le sont pas.</span><span class="sxs-lookup"><span data-stu-id="01de0-195">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="01de0-196">Les premières peuvent être désignées sous le terme combiné « architecture DDD propre ».</span><span class="sxs-lookup"><span data-stu-id="01de0-196">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="01de0-197">L’architecture propre met la logique métier et le modèle d’application au centre même de l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-197">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="01de0-198">Au lieu que la logique métier dépende des préoccupations de l’accès aux données ou d’une autre infrastructure, cette dépendance est inversée : les détails de l’infrastructure et de l’implémentation dépendent du noyau de l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-198">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="01de0-199">Cela s’obtient par la définition d’abstractions, ou interfaces, dans la couche Noyau de l’application, lesquels sont ensuite implémentés par les types définis dans la couche Infrastructure.</span><span class="sxs-lookup"><span data-stu-id="01de0-199">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="01de0-200">Cette architecture est souvent représentée sous la forme d’une série de cercles concentriques, à l’image des couches d’un oignon.</span><span class="sxs-lookup"><span data-stu-id="01de0-200">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="01de0-201">La figure 5-X montre un exemple de ce style de représentation architecturale.</span><span class="sxs-lookup"><span data-stu-id="01de0-201">Figure 5-X shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

<span data-ttu-id="01de0-202">**Figure 5-7.**</span><span class="sxs-lookup"><span data-stu-id="01de0-202">**Figure 5-7.**</span></span> <span data-ttu-id="01de0-203">Architecture propre ; représentation des couches en oignon</span><span class="sxs-lookup"><span data-stu-id="01de0-203">Clean Architecture; onion view</span></span>

<span data-ttu-id="01de0-204">Dans ce diagramme, le flux des dépendances va du cercle extérieur vers le cercle le plus intérieur.</span><span class="sxs-lookup"><span data-stu-id="01de0-204">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="01de0-205">Vous pouvez constater que la couche Noyau de l’application (qui tire son nom de sa position au centre de ce diagramme) n’a aucune dépendance sur les autres couches de l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-205">Thus, you can see that the Application Core (which takes its name from its position at the core of this diagram) has no dependencies on other application layers.</span></span> <span data-ttu-id="01de0-206">Au centre même du diagramme se trouvent les entités et les interfaces de l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-206">At the very center are the application's entities and interfaces.</span></span> <span data-ttu-id="01de0-207">Juste après vers l’extérieur, mais toujours dans la couche Noyau de l’application, viennent les services de domaine, qui implémentent généralement les interfaces définies dans le cercle central.</span><span class="sxs-lookup"><span data-stu-id="01de0-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="01de0-208">À l’extérieur de la couche Noyau de l’application, il y a les couches Interface utilisateur et Infrastructure. Ces deux couches dépendent de la couche Noyau de l’application, mais elles n’ont pas de dépendances entre elles (obligatoirement).</span><span class="sxs-lookup"><span data-stu-id="01de0-208">Outside of the Application Core, both the User Interface and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="01de0-209">La figure 5-X montre une représentation horizontale des couches plus classique, qui reflète mieux la dépendance entre la couche Interface utilisateur et les autres couches.</span><span class="sxs-lookup"><span data-stu-id="01de0-209">Figure 5-X shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

<span data-ttu-id="01de0-210">**Figure 5-8.**</span><span class="sxs-lookup"><span data-stu-id="01de0-210">**Figure 5-8.**</span></span> <span data-ttu-id="01de0-211">Architecture propre ; représentation horizontale des couches</span><span class="sxs-lookup"><span data-stu-id="01de0-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="01de0-212">Notez que les flèches pleines représentent les dépendances à la compilation, tandis que la flèche en pointillé représente une dépendance à l’exécution uniquement.</span><span class="sxs-lookup"><span data-stu-id="01de0-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="01de0-213">Dans une architecture propre, la couche Interface utilisateur interagit avec les interfaces définies dans la couche Noyau de l’application au moment de la compilation. Dans l’idéal, elle ne doit pas avoir connaissance des types d’implémentation définis dans la couche Infrastructure.</span><span class="sxs-lookup"><span data-stu-id="01de0-213">Using the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally should not have any knowledge of the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="01de0-214">Au moment de l’exécution, toutefois, ces types d’implémentation sont nécessaires pour exécuter l’application. Ils doivent donc être définis et transmis jusqu’aux interfaces de la couche Noyau de l’application au moyen de l’injection de dépendances.</span><span class="sxs-lookup"><span data-stu-id="01de0-214">At runtime, however, these implementation types will be required for the app to execute, so they will need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="01de0-215">La figure 5-9 est une représentation plus détaillée de l’architecture d’une application ASP.NET Core conçue selon ces recommandations.</span><span class="sxs-lookup"><span data-stu-id="01de0-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![Architecture ASPNET Core](./media/image5-9.png)

<span data-ttu-id="01de0-217">**Figure 5-9**.</span><span class="sxs-lookup"><span data-stu-id="01de0-217">**Figure 5-9.**</span></span> <span data-ttu-id="01de0-218">Diagramme d’une architecture ASP.NET Core propre.</span><span class="sxs-lookup"><span data-stu-id="01de0-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="01de0-219">Étant donné que la couche Noyau de l’application ne dépend pas de la couche Infrastructure, il est très facile d’écrire des tests unitaires automatisés pour cette couche.</span><span class="sxs-lookup"><span data-stu-id="01de0-219">Because the Application Core doesn't depend on Infrastructure, it is very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="01de0-220">Les figures 5-10 et 5-11 montrent comment les tests s’intègrent à cette architecture.</span><span class="sxs-lookup"><span data-stu-id="01de0-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="01de0-222">**Figure 5-10.**</span><span class="sxs-lookup"><span data-stu-id="01de0-222">**Figure 5-10.**</span></span> <span data-ttu-id="01de0-223">Tests unitaires, couche Noyau de l’application isolée.</span><span class="sxs-lookup"><span data-stu-id="01de0-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="01de0-225">**Figure 5-11.**</span><span class="sxs-lookup"><span data-stu-id="01de0-225">**Figure 5-11.**</span></span> <span data-ttu-id="01de0-226">Tests d’intégration, implémentations dans Infrastructure avec des dépendances externes.</span><span class="sxs-lookup"><span data-stu-id="01de0-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="01de0-227">Comme la couche Interface utilisateur n’a pas de dépendance directe sur les types définis dans le projet Infrastructure, il est également très facile de permuter les implémentations, pour les besoins de test ou en réponse à des changements dans les exigences de l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it is likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="01de0-228">Grâce à la prise en charge et à l’utilisation intégrée de l’injection de dépendances dans une application ASP.NET Core, cette architecture est la plus performante pour organiser des applications monolithiques non triviales.</span><span class="sxs-lookup"><span data-stu-id="01de0-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="01de0-229">Dans les applications monolithiques, les projets Noyau de l’application, Infrastructure et Interface utilisateur sont tous exécutés comme une seule application.</span><span class="sxs-lookup"><span data-stu-id="01de0-229">For monolithic applications the Application Core, Infrastructure, and User Interface projects are all run as a single application.</span></span> <span data-ttu-id="01de0-230">La figure 5-12 illustre un exemple d’architecture d’exécution d’une application.</span><span class="sxs-lookup"><span data-stu-id="01de0-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![Architecture ASPNET Core 2](./media/image5-12.png)

<span data-ttu-id="01de0-232">**Figure 5-12.**</span><span class="sxs-lookup"><span data-stu-id="01de0-232">**Figure 5-12.**</span></span> <span data-ttu-id="01de0-233">Exemple d’architecture d’exécution d’une application ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="01de0-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="01de0-234">Organisation du code dans une architecture propre</span><span class="sxs-lookup"><span data-stu-id="01de0-234">Organizing Code in Clean Architecture</span></span>

<span data-ttu-id="01de0-235">Dans une architecture propre, les responsabilités de chaque projet sont clairement établies.</span><span class="sxs-lookup"><span data-stu-id="01de0-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="01de0-236">Comme certains types sont communs à chaque projet, vous trouverez souvent plusieurs dossiers correspondant à ces types dans le projet en question.</span><span class="sxs-lookup"><span data-stu-id="01de0-236">As such, certain types will belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="01de0-237">La couche Noyau de l’application contient le modèle métier, qui définit les entités, les services et les interfaces.</span><span class="sxs-lookup"><span data-stu-id="01de0-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="01de0-238">Ces interfaces renferment les abstractions des opérations à effectuer dans la couche Infrastructure, comme l’accès aux données, les accès au système de fichiers, les appels réseau, etc. Les services ou interfaces définis dans cette couche doivent parfois interagir avec des types qui ne sont pas des entités et qui n’ont pas de dépendance sur les couches Interface utilisateur ou Infrastructure.</span><span class="sxs-lookup"><span data-stu-id="01de0-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="01de0-239">Ils peuvent alors être définis comme objets de transfert de données (DTO).</span><span class="sxs-lookup"><span data-stu-id="01de0-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

> ### <a name="application-core-types"></a><span data-ttu-id="01de0-240">Types de base dans une application</span><span class="sxs-lookup"><span data-stu-id="01de0-240">Application Core Types</span></span>
> -   <span data-ttu-id="01de0-241">Entités (classes persistantes du modèle métier)</span><span class="sxs-lookup"><span data-stu-id="01de0-241">Entities (business model classes that are persisted)</span></span>
> -   <span data-ttu-id="01de0-242">Interfaces</span><span class="sxs-lookup"><span data-stu-id="01de0-242">Interfaces</span></span>
> -   <span data-ttu-id="01de0-243">Services</span><span class="sxs-lookup"><span data-stu-id="01de0-243">Services</span></span>
> -   <span data-ttu-id="01de0-244">Objets DTO</span><span class="sxs-lookup"><span data-stu-id="01de0-244">DTOs</span></span>

<span data-ttu-id="01de0-245">Le projet Infrastructure inclut généralement les implémentations de l’accès aux données.</span><span class="sxs-lookup"><span data-stu-id="01de0-245">The Infrastructure project will typically include data access implementations.</span></span> <span data-ttu-id="01de0-246">Dans une application web ASP.NET Core conventionnelle, ce projet contient la classe DbContext d’Entity Framework, les migrations d’EF Core qui ont été définies, ainsi que les classes d’implémentation de l’accès aux données.</span><span class="sxs-lookup"><span data-stu-id="01de0-246">In a typical ASP.NET Core web application, this will include the Entity Framework DbContext, any EF Core Migrations that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="01de0-247">La méthode la plus courante pour abstraire le code d’implémentation de l’accès aux données est d’utiliser le [modèle de conception de référentiel](http://deviq.com/repository-pattern/).</span><span class="sxs-lookup"><span data-stu-id="01de0-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](http://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="01de0-248">En plus des implémentations de l’accès aux données, le projet Infrastructure doit contenir les implémentations des services qui interagissent avec les préoccupations de l’infrastructure.</span><span class="sxs-lookup"><span data-stu-id="01de0-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="01de0-249">Ces services doivent implémenter les interfaces définies dans la couche Noyau de l’application, et la couche Infrastructure doit donc référencer le projet Noyau de l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

> ### <a name="infrastructure-types"></a><span data-ttu-id="01de0-250">Types de la couche Infrastructure</span><span class="sxs-lookup"><span data-stu-id="01de0-250">Infrastructure Types</span></span>
> -   <span data-ttu-id="01de0-251">Types EF Core (DbContext, migrations)</span><span class="sxs-lookup"><span data-stu-id="01de0-251">EF Core types (DbContext, Migrations)</span></span>
> -   <span data-ttu-id="01de0-252">Types d’implémentation de l’accès aux données (référentiels)</span><span class="sxs-lookup"><span data-stu-id="01de0-252">Data access implementation types (Repositories)</span></span>
> -   <span data-ttu-id="01de0-253">Services spécifiques de la couche Infrastructure (FileLogger, SmtpNotifier, etc.)</span><span class="sxs-lookup"><span data-stu-id="01de0-253">Infrastructure-specific services (FileLogger, SmtpNotifier, etc.)</span></span>

<span data-ttu-id="01de0-254">Dans une application ASP.NET Core MVC, la couche Interface utilisateur est le point d’entrée de l’application et constitue un projet ASP.NET Core MVC.</span><span class="sxs-lookup"><span data-stu-id="01de0-254">The user interface layer in an ASP.NET Core MVC application will be the entry point for the application, and will be an ASP.NET Core MVC project.</span></span> <span data-ttu-id="01de0-255">Ce projet doit référencer le projet Noyau de l’application, et ses types doivent interagir avec l’infrastructure uniquement par le biais des interfaces définies dans la couche Noyau de l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="01de0-256">Les instanciations directes des types de la couche Infrastructure (ou les appels statiques à ces types) ne doivent pas être autorisées dans la couche Interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="01de0-256">No direct instantiation of (or static calls to) Infrastructure layer types should be permitted in the UI layer.</span></span>

> ### <a name="ui-layer-types"></a><span data-ttu-id="01de0-257">Types de la couche Interface utilisateur</span><span class="sxs-lookup"><span data-stu-id="01de0-257">UI Layer Types</span></span>
> -   <span data-ttu-id="01de0-258">Contrôleurs</span><span class="sxs-lookup"><span data-stu-id="01de0-258">Controllers</span></span>
> -   <span data-ttu-id="01de0-259">Filtres</span><span class="sxs-lookup"><span data-stu-id="01de0-259">Filters</span></span>
> -   <span data-ttu-id="01de0-260">Affichages</span><span class="sxs-lookup"><span data-stu-id="01de0-260">Views</span></span>
> -   <span data-ttu-id="01de0-261">ViewModels</span><span class="sxs-lookup"><span data-stu-id="01de0-261">ViewModels</span></span>
> -   <span data-ttu-id="01de0-262">Démarrage</span><span class="sxs-lookup"><span data-stu-id="01de0-262">Startup</span></span>

<span data-ttu-id="01de0-263">La classe Démarrage est responsable de la configuration de l’application, mais aussi de la transmission des types d’implémentation jusqu’aux interfaces, pour permettre le fonctionnement correct de l’injection de dépendances au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="01de0-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="01de0-264">Pour configurer l’injection de dépendances dans la section ConfigureServices du fichier Startup.cs associé au projet Interface utilisateur, celui-ci doit référencer le projet Infrastructure.</span><span class="sxs-lookup"><span data-stu-id="01de0-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="01de0-265">Cette dépendance peut très facilement être supprimée en utilisant un conteneur d’injection de dépendances personnalisé.</span><span class="sxs-lookup"><span data-stu-id="01de0-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="01de0-266">Dans cet exemple, l’approche la plus simple est d’autoriser le projet Interface utilisateur à référencer le projet Infrastructure.</span><span class="sxs-lookup"><span data-stu-id="01de0-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="01de0-267">Conteneurs et applications monolithiques</span><span class="sxs-lookup"><span data-stu-id="01de0-267">Monolithic Applications and Containers</span></span> 

<span data-ttu-id="01de0-268">Vous pouvez créer une application (ou service) web unique et monolithique, et la déployer en tant que conteneur.</span><span class="sxs-lookup"><span data-stu-id="01de0-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="01de0-269">En interne, l’application peut ne pas être monolithique, mais être organisée en bibliothèques, composants ou couches.</span><span class="sxs-lookup"><span data-stu-id="01de0-269">Within the application, it might not be monolithic but organized into several libraries, components or layers.</span></span> <span data-ttu-id="01de0-270">D’un point de vue externe, l’application est considérée comme un conteneur unique, de la même façon qu’un processus, une application web ou un service unique.</span><span class="sxs-lookup"><span data-stu-id="01de0-270">Externally it is a single container like a single process, single web application or single service.</span></span>

<span data-ttu-id="01de0-271">Pour gérer ce modèle, vous déployez un seul conteneur pour représenter l’application.</span><span class="sxs-lookup"><span data-stu-id="01de0-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="01de0-272">Pour effectuer une mise à l’échelle, vous ajoutez simplement des copies supplémentaires avec un équilibreur de charge en frontal.</span><span class="sxs-lookup"><span data-stu-id="01de0-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="01de0-273">Cette simplicité provient de la gestion d’un seul déploiement dans un seul conteneur ou une seule machine virtuelle.</span><span class="sxs-lookup"><span data-stu-id="01de0-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="01de0-274">Vous pouvez inclure plusieurs couches internes, composants ou bibliothèques dans chaque conteneur, comme illustré à la figure 5-X.</span><span class="sxs-lookup"><span data-stu-id="01de0-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-X.</span></span> <span data-ttu-id="01de0-275">Cependant, d’après le principe des conteneurs selon lequel « *un conteneur fait une chose et la fait dans un seul processus* », ce modèle monolithique peut être en conflit.</span><span class="sxs-lookup"><span data-stu-id="01de0-275">But, following the container principal of *"a container does one thing, and does it in one process*", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="01de0-276">Cette approche présente des inconvénients si/quand l’application grandit, nécessitant sa mise à l’échelle.</span><span class="sxs-lookup"><span data-stu-id="01de0-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="01de0-277">Si l’application entière est mise à l’échelle, ce n’est pas vraiment un problème.</span><span class="sxs-lookup"><span data-stu-id="01de0-277">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="01de0-278">Toutefois, dans la plupart des cas, la mise à l’échelle est nécessaire pour quelques parties de l’application seulement, mais elle est inutile pour d’autres composants moins utilisés.</span><span class="sxs-lookup"><span data-stu-id="01de0-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="01de0-279">Dans l’exemple classique du commerce électronique, c’est probablement le composant des informations produit qui a le plus besoin d’être mis à l’échelle.</span><span class="sxs-lookup"><span data-stu-id="01de0-279">Using the typical eCommerce example; what you likely need to scale is the product information component.</span></span> <span data-ttu-id="01de0-280">Les clients qui recherchent des produits sont beaucoup plus nombreux que ceux qui en achètent.</span><span class="sxs-lookup"><span data-stu-id="01de0-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="01de0-281">Plus de clients utilisent leur panier d’achat que ceux qui utilisent le pipeline de paiement.</span><span class="sxs-lookup"><span data-stu-id="01de0-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="01de0-282">Moins de clients ajoutent des commentaires ou consultent leur historique d’achat.</span><span class="sxs-lookup"><span data-stu-id="01de0-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="01de0-283">De même, seule une poignée d’employés, d’une seule région, doivent généralement gérer le contenu et les campagnes marketing.</span><span class="sxs-lookup"><span data-stu-id="01de0-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="01de0-284">La mise à l’échelle de la conception monolithique déploie tout le code plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="01de0-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="01de0-285">En plus du problème de la mise à l’échelle globale, quand des modifications sont apportées à un seul composant, il faut refaire un test complet de l’application entière et redéployer intégralement toutes les instances.</span><span class="sxs-lookup"><span data-stu-id="01de0-285">In addition to the scale everything problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="01de0-286">L’approche architecturale monolithique est fréquemment choisie pour le développement dans les organisations.</span><span class="sxs-lookup"><span data-stu-id="01de0-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="01de0-287">Beaucoup de ces organisations sont satisfaites des résultats obtenus, mais certaines se heurtent aux limites de ce modèle d’architecture.</span><span class="sxs-lookup"><span data-stu-id="01de0-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="01de0-288">Les organisations ont souvent conçu leurs applications d’après ce modèle, car les outils et l’infrastructure étaient trop complexes pour concevoir des architectures orientées services (SOA). Par ailleurs, elles ne voyaient pas le besoin de changer de modèle tant que leur application ne grossissait pas trop.</span><span class="sxs-lookup"><span data-stu-id="01de0-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service oriented architectures (SOA), and they didn't see the need - until the app grew.</span></span> <span data-ttu-id="01de0-289">Si vous vous heurtez aux limites de l’approche monolithique, la prochaine étape logique pour vous est peut-être de scinder votre application pour mieux tirer parti des conteneurs et microservices.</span><span class="sxs-lookup"><span data-stu-id="01de0-289">If you find you're hitting the limits of the monolithic approach, breaking the app up to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="01de0-290">Le déploiement d’applications monolithiques dans Microsoft Azure est possible en utilisant des machines virtuelles dédiées pour chaque instance.</span><span class="sxs-lookup"><span data-stu-id="01de0-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="01de0-291">Avec [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), vous pouvez facilement mettre à l’échelle les machines virtuelles.</span><span class="sxs-lookup"><span data-stu-id="01de0-291">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="01de0-292">[Azure App Service](https://azure.microsoft.com/services/app-service/) peut également exécuter des applications monolithiques et facilement mettre à l’échelle des instances sans nécessiter une gestion des machines virtuelles.</span><span class="sxs-lookup"><span data-stu-id="01de0-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="01de0-293">Azure App Service peut également exécuter des instances uniques de conteneurs Docker, ce qui simplifie le déploiement.</span><span class="sxs-lookup"><span data-stu-id="01de0-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="01de0-294">Avec Docker, vous pouvez déployer une seule machine virtuelle comme hôte Docker et exécuter plusieurs instances.</span><span class="sxs-lookup"><span data-stu-id="01de0-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="01de0-295">Vous pouvez gérer la mise à l’échelle à l’aide de l’équilibreur de charge Azure, comme indiqué dans la figure 5-14.</span><span class="sxs-lookup"><span data-stu-id="01de0-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="01de0-296">Le déploiement sur les différents hôtes peut être géré avec les techniques de déploiement traditionnelles.</span><span class="sxs-lookup"><span data-stu-id="01de0-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="01de0-297">Les hôtes Docker peuvent être gérés à l’aide de commandes exécutées manuellement, telles que **docker run**, ou de manière automatisée, comme les pipelines de livraison continue.</span><span class="sxs-lookup"><span data-stu-id="01de0-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="01de0-298">Application monolithique déployée comme conteneur</span><span class="sxs-lookup"><span data-stu-id="01de0-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="01de0-299">L’utilisation de conteneurs pour gérer les déploiements d’applications monolithiques présente des avantages.</span><span class="sxs-lookup"><span data-stu-id="01de0-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="01de0-300">La mise à l’échelle des instances des conteneurs est beaucoup plus rapide et facile que le déploiement de machines virtuelles supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="01de0-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="01de0-301">Même si vous utilisez VM Scale Sets pour mettre à l’échelle des machines virtuelles, leur instanciation prend du temps.</span><span class="sxs-lookup"><span data-stu-id="01de0-301">Even when using VM Scale Sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="01de0-302">Quand une machine virtuelle est déployée en tant qu’instance de l’application, la configuration de l’application est gérée en interne par la machine virtuelle.</span><span class="sxs-lookup"><span data-stu-id="01de0-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="01de0-303">Le déploiement de mises à jour comme images Docker est beaucoup plus rapide et efficace du point de vue du réseau.</span><span class="sxs-lookup"><span data-stu-id="01de0-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="01de0-304">Les images Docker démarrent généralement en quelques secondes, ce qui accélère les lancements.</span><span class="sxs-lookup"><span data-stu-id="01de0-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="01de0-305">La suppression d’une instance Docker se fait simplement en exécutant une commande **docker stop**. Cette opération prend normalement moins d’une seconde.</span><span class="sxs-lookup"><span data-stu-id="01de0-305">Tearing down a Docker instance is as easy as issuing a **docker stop** command, typically completing in less than a second.</span></span>

<span data-ttu-id="01de0-306">Comme les conteneurs sont immuables de par leur conception même, il n’y a pas de risques d’endommagement des machines virtuelles, au contraire des scripts de mise à jour qui peuvent oublier de prendre en compte une configuration ou un fichier spécifique sur le disque.</span><span class="sxs-lookup"><span data-stu-id="01de0-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="01de0-307">L’utilisation de Docker peut être utile pour les applications monolithiques, mais le fait de scinder une application monolithique en sous-systèmes qui peuvent être mis à l’échelle, développés et déployés individuellement, peut constituer votre point d’entrée dans le domaine des microservices.</span><span class="sxs-lookup"><span data-stu-id="01de0-307">While monolithic apps can benefit from Docker, breaking up the monolithic application into sub systems which can be scaled, developed and deployed individually may be your entry point into the realm of microservices.</span></span>

> ### <a name="references--common-web-architectures"></a><span data-ttu-id="01de0-308">Informations de référence sur les architectures web courantes</span><span class="sxs-lookup"><span data-stu-id="01de0-308">References – Common Web Architectures</span></span>
> - <span data-ttu-id="01de0-309">**L’architecture propre**</span><span class="sxs-lookup"><span data-stu-id="01de0-309">**The Clean Architecture**</span></span>  
> <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
> - <span data-ttu-id="01de0-310">**L’architecture en oignon**</span><span class="sxs-lookup"><span data-stu-id="01de0-310">**The Onion Architecture**</span></span>  
> <http://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
> - <span data-ttu-id="01de0-311">**Le modèle référentiel**</span><span class="sxs-lookup"><span data-stu-id="01de0-311">**The Repository Pattern**</span></span>  
> <http://deviq.com/repository-pattern/>
> - <span data-ttu-id="01de0-312">**Exemple d’une solution d’architecture propre**</span><span class="sxs-lookup"><span data-stu-id="01de0-312">**Clean Architecture Solution Sample**</span></span>  
> <https://github.com/ardalis/cleanarchitecture>
> - <span data-ttu-id="01de0-313">**Architecting Microservices (livre électronique)** <http://aka.ms/MicroservicesEbook></span><span class="sxs-lookup"><span data-stu-id="01de0-313">**Architecting Microservices e-book** <http://aka.ms/MicroservicesEbook></span></span>

>[!div class="step-by-step"]
<span data-ttu-id="01de0-314">[Précédent](architectural-principles.md)
[Suivant](common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="01de0-314">[Previous](architectural-principles.md)
[Next](common-client-side-web-technologies.md)</span></span>
