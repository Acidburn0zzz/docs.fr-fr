---
title: EventWaitHandle
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
caps.latest.revision: "9"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 1bd248133bd95ff05246eb36a8e250247fd7ed61
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/21/2017
---
# <a name="eventwaithandle"></a><span data-ttu-id="78c6f-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="78c6f-102">EventWaitHandle</span></span>
<span data-ttu-id="78c6f-103">La <xref:System.Threading.EventWaitHandle> classe permet aux threads de communiquer entre eux en signalant et en attendant des signaux.</span><span class="sxs-lookup"><span data-stu-id="78c6f-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="78c6f-104">Handles d’attente d’événement (également appelés événements) sont des handles d’attente qui peuvent être signalés afin de libérer un ou plusieurs threads en attente.</span><span class="sxs-lookup"><span data-stu-id="78c6f-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="78c6f-105">Une fois qu’il est signalé, un handle d’attente d’événement est réinitialisé manuellement ou automatiquement.</span><span class="sxs-lookup"><span data-stu-id="78c6f-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="78c6f-106">La <xref:System.Threading.EventWaitHandle> classe peut représenter soit un événement local handle d’attente (événement local) ou le handle (nommé événement ou système, visible pour tous les processus) d’attente d’un événement système nommé.</span><span class="sxs-lookup"><span data-stu-id="78c6f-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78c6f-107">Handles d’attente d’événements ne sont pas des événements dans le sens habituellement donné à ce terme dans le .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="78c6f-107">Event wait handles are not events in the sense usually meant by that word in the .NET Framework.</span></span> <span data-ttu-id="78c6f-108">Aucun délégué ou les gestionnaires d’événements ne sont impliqués.</span><span class="sxs-lookup"><span data-stu-id="78c6f-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="78c6f-109">Le terme « événement » est utilisé pour décrire les car elles ont généralement appelés en tant qu’événements du système d’exploitation, et le fait de signaler le handle d’attente indique aux threads en attente qu’un événement s’est produit.</span><span class="sxs-lookup"><span data-stu-id="78c6f-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="78c6f-110">Les handles d’attente d’événement locaux et nommés utilisent des objets de synchronisation de système, qui sont protégés par <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers pour vous assurer que les ressources sont libérées.</span><span class="sxs-lookup"><span data-stu-id="78c6f-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="78c6f-111">Vous pouvez utiliser la <xref:System.Threading.WaitHandle.Dispose%2A> méthode pour libérer les ressources immédiatement lorsque vous avez terminé à l’aide de l’objet.</span><span class="sxs-lookup"><span data-stu-id="78c6f-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="78c6f-112">Handles d’attente d’événements qui réinitialisent automatiquement</span><span class="sxs-lookup"><span data-stu-id="78c6f-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="78c6f-113">Vous créez un événement de réinitialisation automatique en spécifiant <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> lorsque vous créez le <xref:System.Threading.EventWaitHandle> objet.</span><span class="sxs-lookup"><span data-stu-id="78c6f-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="78c6f-114">Comme son nom l’indique, cet événement de synchronisation est réinitialisé automatiquement quand il est signalé, après avoir libéré un seul thread en attente.</span><span class="sxs-lookup"><span data-stu-id="78c6f-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="78c6f-115">Signaler l’événement en appelant son <xref:System.Threading.EventWaitHandle.Set%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="78c6f-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="78c6f-116">Événements de réinitialisation automatique sont généralement utilisées pour fournir un accès exclusif à une ressource pour un seul thread à la fois.</span><span class="sxs-lookup"><span data-stu-id="78c6f-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="78c6f-117">Un thread demande la ressource en appelant le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="78c6f-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="78c6f-118">Si aucun autre thread ne détient le handle d’attente, la méthode retourne `true` et le thread appelant possède le contrôle de la ressource.</span><span class="sxs-lookup"><span data-stu-id="78c6f-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="78c6f-119">Comme avec tous les mécanismes de synchronisation, vous devez vous assurer que tous les chemins de code attend la fin sur le handle d’attente approprié avant d’accéder à une ressource protégée.</span><span class="sxs-lookup"><span data-stu-id="78c6f-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="78c6f-120">Synchronisation de threads est coopérative.</span><span class="sxs-lookup"><span data-stu-id="78c6f-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="78c6f-121">Si un événement de réinitialisation automatique est signalé lorsque aucun thread n’attend, il reste signalé jusqu'à ce qu’un thread tente d’attendre.</span><span class="sxs-lookup"><span data-stu-id="78c6f-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="78c6f-122">L’événement libère le thread et est immédiatement réinitialisé, bloquant les threads suivants.</span><span class="sxs-lookup"><span data-stu-id="78c6f-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="78c6f-123">Handles d’attente d’événement réinitialiser manuellement</span><span class="sxs-lookup"><span data-stu-id="78c6f-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="78c6f-124">Vous créez un événement de réinitialisation manuelle en spécifiant <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> lorsque vous créez le <xref:System.Threading.EventWaitHandle> objet.</span><span class="sxs-lookup"><span data-stu-id="78c6f-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="78c6f-125">Comme son nom l’indique, cet événement de synchronisation doit être réinitialisé manuellement après avoir été signalé.</span><span class="sxs-lookup"><span data-stu-id="78c6f-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="78c6f-126">Jusqu'à ce qu’elle est réinitialisée, en appelant ses <xref:System.Threading.EventWaitHandle.Reset%2A> (méthode), les threads qui attendent que le handle d’événement procéder immédiatement sans blocage.</span><span class="sxs-lookup"><span data-stu-id="78c6f-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="78c6f-127">Événement des agit comme la barrière d’un corral de réinitialisation manuelle.</span><span class="sxs-lookup"><span data-stu-id="78c6f-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="78c6f-128">Lorsque l’événement n’est pas signalé, bloquent les threads qui attendent sur celui-ci, comme les chevaux dans un corral.</span><span class="sxs-lookup"><span data-stu-id="78c6f-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="78c6f-129">Lorsque l’événement est signalé, en appelant ses <xref:System.Threading.EventWaitHandle.Set%2A> (méthode), tous les threads en attente sont libres de continuer.</span><span class="sxs-lookup"><span data-stu-id="78c6f-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="78c6f-130">L’événement reste signalé jusqu'à ce que son <xref:System.Threading.EventWaitHandle.Reset%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="78c6f-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="78c6f-131">Cela rend une façon idéale de suspendre les threads qui doivent attendre jusqu'à ce qu’un thread termine une tâche à l’événement de réinitialisation manuelle.</span><span class="sxs-lookup"><span data-stu-id="78c6f-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="78c6f-132">Comme les chevaux qui quittent un corral, le temps requis pour les threads publiées pour être planifiée par le système d’exploitation et de reprendre l’exécution.</span><span class="sxs-lookup"><span data-stu-id="78c6f-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="78c6f-133">Si le <xref:System.Threading.EventWaitHandle.Reset%2A> méthode est appelée avant l’exécution de tous les threads ont repris, les threads restants sont encore une fois bloquent.</span><span class="sxs-lookup"><span data-stu-id="78c6f-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="78c6f-134">Le reprendre des threads et le threads se bloquent dépend de facteurs aléatoires tels que la charge sur le système, le nombre de threads en attente pour le planificateur et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="78c6f-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="78c6f-135">Cela n’est pas un problème si le thread qui signale l’événement se termine après avoir signalé, qui est le modèle d’utilisation courants.</span><span class="sxs-lookup"><span data-stu-id="78c6f-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="78c6f-136">Si vous souhaitez que le thread qui a signalé l’événement pour commencer une nouvelle tâche une fois tous les threads ont repris en attente, vous devez le bloquer jusqu'à ce que tous les threads en attente ont repris.</span><span class="sxs-lookup"><span data-stu-id="78c6f-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="78c6f-137">Sinon, vous avez une condition de concurrence et le comportement de votre code est imprévisible.</span><span class="sxs-lookup"><span data-stu-id="78c6f-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="78c6f-138">Fonctionnalités communes aux événements automatiques et manuels</span><span class="sxs-lookup"><span data-stu-id="78c6f-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="78c6f-139">En général, un ou plusieurs threads se bloquent sur un <xref:System.Threading.EventWaitHandle> jusqu'à ce qu’un thread débloqué appelle la <xref:System.Threading.EventWaitHandle.Set%2A> méthode, ce qui libère l’un des threads en attente (dans le cas des événements à réinitialisation automatique) ou tous les (manuel dans le cas d’événements de réinitialisation).</span><span class="sxs-lookup"><span data-stu-id="78c6f-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="78c6f-140">Un thread peut signaler un <xref:System.Threading.EventWaitHandle> et bloquer ensuite sur celui-ci, comme une opération atomique, en appelant la méthode statique <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="78c6f-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="78c6f-141"><xref:System.Threading.EventWaitHandle>objets peuvent être utilisés avec la méthode statique <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> et <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> méthodes.</span><span class="sxs-lookup"><span data-stu-id="78c6f-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="78c6f-142">Étant donné que la <xref:System.Threading.EventWaitHandle> et <xref:System.Threading.Mutex> dérivent de classes <xref:System.Threading.WaitHandle>, vous pouvez utiliser les deux classes avec ces méthodes.</span><span class="sxs-lookup"><span data-stu-id="78c6f-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="78c6f-143">Événements nommés</span><span class="sxs-lookup"><span data-stu-id="78c6f-143">Named Events</span></span>  
 <span data-ttu-id="78c6f-144">Le système d’exploitation Windows permet de handles d’attente d’événement d’avoir des noms.</span><span class="sxs-lookup"><span data-stu-id="78c6f-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="78c6f-145">Un événement nommé est au niveau du système.</span><span class="sxs-lookup"><span data-stu-id="78c6f-145">A named event is system wide.</span></span> <span data-ttu-id="78c6f-146">Autrement dit, une fois l’événement nommé est créé, il est visible pour tous les threads de tous les processus.</span><span class="sxs-lookup"><span data-stu-id="78c6f-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="78c6f-147">Par conséquent, les événements nommés peuvent être utilisés pour synchroniser les activités de processus, ainsi que des threads.</span><span class="sxs-lookup"><span data-stu-id="78c6f-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="78c6f-148">Vous pouvez créer un <xref:System.Threading.EventWaitHandle> objet qui représente un événement système nommé à l’aide d’un des constructeurs qui spécifient un nom d’événement.</span><span class="sxs-lookup"><span data-stu-id="78c6f-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78c6f-149">Étant donné que les événements nommés sont à l’échelle du système, il est possible d’avoir plusieurs <xref:System.Threading.EventWaitHandle> objets qui représentent le même événement de nommé.</span><span class="sxs-lookup"><span data-stu-id="78c6f-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="78c6f-150">Chaque fois que vous appelez un constructeur, ou le <xref:System.Threading.EventWaitHandle.OpenExisting%2A> (méthode), un nouveau <xref:System.Threading.EventWaitHandle> objet est créé.</span><span class="sxs-lookup"><span data-stu-id="78c6f-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="78c6f-151">En spécifiant le même nom à plusieurs reprises crée plusieurs objets qui représentent le même événement nommé.</span><span class="sxs-lookup"><span data-stu-id="78c6f-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="78c6f-152">Avec prudence dans à l’aide de ces événements.</span><span class="sxs-lookup"><span data-stu-id="78c6f-152">Caution is advised in using named events.</span></span> <span data-ttu-id="78c6f-153">Car elles sont au niveau du système, un autre processus qui utilise le même nom peut bloquer vos threads de manière inattendue.</span><span class="sxs-lookup"><span data-stu-id="78c6f-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="78c6f-154">Du code malveillant exécuté sur le même ordinateur pourrait s'en servir pour une attaque par déni de service.</span><span class="sxs-lookup"><span data-stu-id="78c6f-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="78c6f-155">Utiliser la sécurité de contrôle d’accès pour protéger un <xref:System.Threading.EventWaitHandle> objet qui représente un événement nommé, de préférence à l’aide d’un constructeur qui spécifie un <xref:System.Security.AccessControl.EventWaitHandleSecurity> objet.</span><span class="sxs-lookup"><span data-stu-id="78c6f-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="78c6f-156">Vous pouvez également appliquer la sécurité du contrôle d’accès à l’aide du <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> (méthode), mais cela laisse une fenêtre de vulnérabilité entre l’heure de création du handle d’attente de l’événement et le moment où il est protégé.</span><span class="sxs-lookup"><span data-stu-id="78c6f-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="78c6f-157">La protection des événements avec le contrôle d’accès sécurité empêche les attaques malveillantes, mais elle ne résout pas le problème des collisions de noms involontaires.</span><span class="sxs-lookup"><span data-stu-id="78c6f-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78c6f-158">Contrairement à la <xref:System.Threading.EventWaitHandle> (classe), les classes dérivées <xref:System.Threading.AutoResetEvent> et <xref:System.Threading.ManualResetEvent> pouvez handles d’attente représentent uniquement locale.</span><span class="sxs-lookup"><span data-stu-id="78c6f-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="78c6f-159">Ils ne peut pas représenter des événements système nommé.</span><span class="sxs-lookup"><span data-stu-id="78c6f-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="78c6f-160">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="78c6f-160">See Also</span></span>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 [<span data-ttu-id="78c6f-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="78c6f-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)
