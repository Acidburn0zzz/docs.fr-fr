---
title: Vue d’ensemble des primitives de synchronisation
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET Framework],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 37abcb6b3a8fdf4ef91d5e946a97db7ca1428ce8
ms.sourcegitcommit: fb78d8abbdb87144a3872cf154930157090dd933
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/27/2018
ms.locfileid: "47204597"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="c7e03-102">Vue d’ensemble des primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="c7e03-102">Overview of Synchronization Primitives</span></span>
<a name="top"></a> <span data-ttu-id="c7e03-103">Le .NET Framework fournit une plage de primitives de synchronisation pour contrôler les interactions de threads et éviter des conditions de concurrence.</span><span class="sxs-lookup"><span data-stu-id="c7e03-103">The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions.</span></span> <span data-ttu-id="c7e03-104">Celles-ci peuvent être divisées approximativement en trois catégories : le verrouillage, la signalisation et les opérations verrouillées.</span><span class="sxs-lookup"><span data-stu-id="c7e03-104">These can be roughly divided into three categories: locking, signaling, and interlocked operations.</span></span>  
  
 <span data-ttu-id="c7e03-105">Les catégories ne sont pas clairement définies : certains mécanismes de synchronisation possèdent des caractéristiques relevant de plusieurs catégories. Les événements qui libèrent un seul thread à la fois sont similaires à des verrous d’un point de vue fonctionnel. La libération d'un verrou quelconque peut être considérée comme un signal et les opérations verrouillées peuvent être utilisées pour construire des verrous.</span><span class="sxs-lookup"><span data-stu-id="c7e03-105">The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks.</span></span> <span data-ttu-id="c7e03-106">Toutefois, ces catégories restent utiles.</span><span class="sxs-lookup"><span data-stu-id="c7e03-106">However, the categories are still useful.</span></span>  
  
 <span data-ttu-id="c7e03-107">Il est important de se rappeler que la synchronisation de threads est coopérative.</span><span class="sxs-lookup"><span data-stu-id="c7e03-107">It is important to remember that thread synchronization is cooperative.</span></span> <span data-ttu-id="c7e03-108">Si un seul thread ignore un mécanisme de synchronisation et accède directement à la ressource protégée, ce mécanisme de synchronisation ne peut pas être efficace.</span><span class="sxs-lookup"><span data-stu-id="c7e03-108">If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.</span></span>  
  
 <span data-ttu-id="c7e03-109">Cette vue d'ensemble contient les sections suivantes :</span><span class="sxs-lookup"><span data-stu-id="c7e03-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="c7e03-110">Verrouillage</span><span class="sxs-lookup"><span data-stu-id="c7e03-110">Locking</span></span>](#locking)  
  
-   [<span data-ttu-id="c7e03-111">Signalisation</span><span class="sxs-lookup"><span data-stu-id="c7e03-111">Signaling</span></span>](#signaling)  
  
-   [<span data-ttu-id="c7e03-112">Types de synchronisation légers</span><span class="sxs-lookup"><span data-stu-id="c7e03-112">Lightweight Synchronization Types</span></span>](#lightweight_synchronization_types)  
  
-   [<span data-ttu-id="c7e03-113">SpinWait</span><span class="sxs-lookup"><span data-stu-id="c7e03-113">SpinWait</span></span>](#spinwait)  
  
-   [<span data-ttu-id="c7e03-114">Opérations verrouillées</span><span class="sxs-lookup"><span data-stu-id="c7e03-114">Interlocked Operations</span></span>](#interlocked_operations)  
  
<a name="locking"></a>   
## <a name="locking"></a><span data-ttu-id="c7e03-115">Verrouillage</span><span class="sxs-lookup"><span data-stu-id="c7e03-115">Locking</span></span>  
 <span data-ttu-id="c7e03-116">Les verrous donnent le contrôle d'une ressource à un seul thread à la fois ou à un nombre spécifié de threads.</span><span class="sxs-lookup"><span data-stu-id="c7e03-116">Locks give control of a resource to one thread at a time, or to a specified number of threads.</span></span> <span data-ttu-id="c7e03-117">Un thread qui demande un verrou exclusif alors que ce verrou est en cours d'utilisation se bloque jusqu'à ce que le verrou soit de nouveau disponible.</span><span class="sxs-lookup"><span data-stu-id="c7e03-117">A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.</span></span>  
  
### <a name="exclusive-locks"></a><span data-ttu-id="c7e03-118">Verrous exclusifs</span><span class="sxs-lookup"><span data-stu-id="c7e03-118">Exclusive Locks</span></span>  
 <span data-ttu-id="c7e03-119">La forme la plus simple de verrouillage est l’instruction `lock` en C# et l’instruction `SyncLock` en Visual Basic, qui contrôle l’accès à un bloc de code.</span><span class="sxs-lookup"><span data-stu-id="c7e03-119">The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code.</span></span> <span data-ttu-id="c7e03-120">Ce type de bloc est souvent appelé « section critique ».</span><span class="sxs-lookup"><span data-stu-id="c7e03-120">Such a block is frequently referred to as a critical section.</span></span> <span data-ttu-id="c7e03-121">L’instruction `lock` est implémentée à l’aide des méthodes <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> et <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>, et utilise un bloc `try…finally` pour garantir la libération du verrou.</span><span class="sxs-lookup"><span data-stu-id="c7e03-121">The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods, and it uses a `try…finally` block to ensure that the lock is released.</span></span>  
  
 <span data-ttu-id="c7e03-122">En général, l’utilisation de l’instruction `lock` ou `SyncLock` pour protéger de petits blocs de code sans jamais englober plus d'une méthode est la meilleure façon d'utiliser la classe <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-122">In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="c7e03-123">Bien que puissante, la classe <xref:System.Threading.Monitor> est susceptible de rendre orphelins des verrous et des blocages.</span><span class="sxs-lookup"><span data-stu-id="c7e03-123">Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks.</span></span>  
  
#### <a name="monitor-class"></a><span data-ttu-id="c7e03-124">Classe Monitor</span><span class="sxs-lookup"><span data-stu-id="c7e03-124">Monitor Class</span></span>  
 <span data-ttu-id="c7e03-125">La classe <xref:System.Threading.Monitor> fournit des fonctionnalités supplémentaires, qui peuvent être utilisée conjointement à l’instruction `lock` :</span><span class="sxs-lookup"><span data-stu-id="c7e03-125">The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:</span></span>  
  
-   <span data-ttu-id="c7e03-126">La méthode <xref:System.Threading.Monitor.TryEnter%2A> autorise un thread qui est bloqué en attente d’une ressource d'abandonner après un intervalle spécifié.</span><span class="sxs-lookup"><span data-stu-id="c7e03-126">The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval.</span></span> <span data-ttu-id="c7e03-127">Elle retourne une valeur booléenne qui indique la réussite ou l'échec, et qui peut être utilisée pour détecter et éviter des blocages potentiels.</span><span class="sxs-lookup"><span data-stu-id="c7e03-127">It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.</span></span>  
  
-   <span data-ttu-id="c7e03-128">La méthode <xref:System.Threading.Monitor.Wait%2A> est appelée par un thread dans une section critique.</span><span class="sxs-lookup"><span data-stu-id="c7e03-128">The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section.</span></span> <span data-ttu-id="c7e03-129">Elle abandonne le contrôle de la ressource et se bloque jusqu'à ce que la ressource soit de nouveau disponible.</span><span class="sxs-lookup"><span data-stu-id="c7e03-129">It gives up control of the resource and blocks until the resource is available again.</span></span>  
  
-   <span data-ttu-id="c7e03-130">Les méthodes <xref:System.Threading.Monitor.Pulse%2A> et <xref:System.Threading.Monitor.PulseAll%2A> autorisent un thread en passe de libérer le verrou ou d'appeler la méthode <xref:System.Threading.Monitor.Wait%2A> à placer un ou plusieurs threads dans la file d'attente opérationnelle, afin qu'ils puissent acquérir le verrou.</span><span class="sxs-lookup"><span data-stu-id="c7e03-130">The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock.</span></span>  
  
 <span data-ttu-id="c7e03-131">Les dépassements de délai sur les surcharges de la méthode <xref:System.Threading.Monitor.Wait%2A> permettent aux threads en attente de revenir à la file d'attente opérationnelle.</span><span class="sxs-lookup"><span data-stu-id="c7e03-131">Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue.</span></span>  
  
 <span data-ttu-id="c7e03-132">La classe <xref:System.Threading.Monitor> peut permettre un verrouillage dans plusieurs domaines d'application si l'objet utilisé comme verrou dérive de <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-132">The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
 <span data-ttu-id="c7e03-133"><xref:System.Threading.Monitor> possède l’affinité de thread.</span><span class="sxs-lookup"><span data-stu-id="c7e03-133"><xref:System.Threading.Monitor> has thread affinity.</span></span> <span data-ttu-id="c7e03-134">Autrement dit, un thread entré dans le moniteur doit sortir en appelant <xref:System.Threading.Monitor.Exit%2A> ou <xref:System.Threading.Monitor.Wait%2A>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-134">That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>.</span></span>  
  
 <span data-ttu-id="c7e03-135">Il est impossible d’instancier la classe <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-135">The <xref:System.Threading.Monitor> class is not instantiable.</span></span> <span data-ttu-id="c7e03-136">Ses méthodes sont statiques (`Shared` en Visual Basic) et agissent sur un objet verrou instanciable.</span><span class="sxs-lookup"><span data-stu-id="c7e03-136">Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object.</span></span>  
  
 <span data-ttu-id="c7e03-137">Pour bénéficier d’une vue d’ensemble conceptuelle, consultez [Moniteurs](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span><span class="sxs-lookup"><span data-stu-id="c7e03-137">For a conceptual overview, see [Monitors](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span></span>  
  
#### <a name="mutex-class"></a><span data-ttu-id="c7e03-138">Mutex, classe</span><span class="sxs-lookup"><span data-stu-id="c7e03-138">Mutex Class</span></span>  
 <span data-ttu-id="c7e03-139">Les threads demandent un <xref:System.Threading.Mutex> en appelant une surcharge de sa méthode <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-139">Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="c7e03-140">Des surcharges avec délais d'attente sont fournies, afin de permettre aux threads d'abandonner l'attente.</span><span class="sxs-lookup"><span data-stu-id="c7e03-140">Overloads with timeouts are provided, to allow threads to give up the wait.</span></span> <span data-ttu-id="c7e03-141">À la différence de la classe <xref:System.Threading.Monitor>, un mutex peut être local ou global.</span><span class="sxs-lookup"><span data-stu-id="c7e03-141">Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global.</span></span> <span data-ttu-id="c7e03-142">Les mutex globaux, appelés également mutex nommés, sont visibles dans tout le système d'exploitation et peuvent être utilisés pour synchroniser des threads dans plusieurs domaines d'application ou processus.</span><span class="sxs-lookup"><span data-stu-id="c7e03-142">Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes.</span></span> <span data-ttu-id="c7e03-143">Les mutex locaux dérivent de <xref:System.MarshalByRefObject> et peuvent être utilisés au-delà des limites des domaines d'application.</span><span class="sxs-lookup"><span data-stu-id="c7e03-143">Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="c7e03-144">Par ailleurs, <xref:System.Threading.Mutex> dérive de <xref:System.Threading.WaitHandle>, ce qui signifie qu'il peut être utilisé avec les mécanismes de signalisation fournis par <xref:System.Threading.WaitHandle>, tels que les méthodes <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> et <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-144">In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods.</span></span>  
  
 <span data-ttu-id="c7e03-145">À l’instar de <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> possède l'affinité de thread.</span><span class="sxs-lookup"><span data-stu-id="c7e03-145">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity.</span></span> <span data-ttu-id="c7e03-146">Contrairement à <xref:System.Threading.Monitor>, il est possible d’instancier un objet <xref:System.Threading.Mutex>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-146">Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object.</span></span>  
  
 <span data-ttu-id="c7e03-147">Pour bénéficier d’une vue d’ensemble conceptuelle, consultez [Mutex](../../../docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="c7e03-147">For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md).</span></span>  
  
#### <a name="spinlock-class"></a><span data-ttu-id="c7e03-148">Classe SpinLock</span><span class="sxs-lookup"><span data-stu-id="c7e03-148">SpinLock Class</span></span>  
 <span data-ttu-id="c7e03-149">À partir du [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], vous pouvez utiliser la classe <xref:System.Threading.SpinLock> quand la surcharge requise par <xref:System.Threading.Monitor> dégrade les performances.</span><span class="sxs-lookup"><span data-stu-id="c7e03-149">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance.</span></span> <span data-ttu-id="c7e03-150">Quand <xref:System.Threading.SpinLock> rencontre une section critique verrouillée, il tourne simplement en boucle jusqu'à ce que le verrou soit de nouveau disponible.</span><span class="sxs-lookup"><span data-stu-id="c7e03-150">When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available.</span></span> <span data-ttu-id="c7e03-151">Si le verrou est maintenu très peu de temps, la rotation peut fournir de meilleures performances que le blocage.</span><span class="sxs-lookup"><span data-stu-id="c7e03-151">If the lock is held for a very short time, spinning can provide better performance than blocking.</span></span> <span data-ttu-id="c7e03-152">Toutefois, si le verrou est maintenu pendant plusieurs dizaines de cycles, <xref:System.Threading.SpinLock> fonctionne aussi bien que <xref:System.Threading.Monitor>, mais utilise plus de cycles processeur et peut donc dégrader les performances d'autres threads ou processus.</span><span class="sxs-lookup"><span data-stu-id="c7e03-152">However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.</span></span>  
  
### <a name="other-locks"></a><span data-ttu-id="c7e03-153">Autres verrous</span><span class="sxs-lookup"><span data-stu-id="c7e03-153">Other Locks</span></span>  
 <span data-ttu-id="c7e03-154">Les verrous n'ont pas besoin d'être exclusifs.</span><span class="sxs-lookup"><span data-stu-id="c7e03-154">Locks need not be exclusive.</span></span> <span data-ttu-id="c7e03-155">Il est souvent utile d'autoriser un nombre limité d’accès simultanés de threads à une ressource.</span><span class="sxs-lookup"><span data-stu-id="c7e03-155">It is often useful to allow a limited number of threads concurrent access to a resource.</span></span> <span data-ttu-id="c7e03-156">Les sémaphores et les verrous de lecteur-writer sont conçus pour contrôler ce type d'accès à des ressources regroupées.</span><span class="sxs-lookup"><span data-stu-id="c7e03-156">Semaphores and reader-writer locks are designed to control this kind of pooled resource access.</span></span>  
  
#### <a name="readerwriterlock-class"></a><span data-ttu-id="c7e03-157">Classe ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="c7e03-157">ReaderWriterLock Class</span></span>  
 <span data-ttu-id="c7e03-158">La classe <xref:System.Threading.ReaderWriterLockSlim> est utile dans le cas où un thread qui modifie des données, le writer, doit disposer d’un accès exclusif à une ressource.</span><span class="sxs-lookup"><span data-stu-id="c7e03-158">The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource.</span></span> <span data-ttu-id="c7e03-159">Quand le writer n'est pas actif, un nombre quelconque de lecteurs peuvent accéder à la ressource (par exemple, en appelant la méthode <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>).</span><span class="sxs-lookup"><span data-stu-id="c7e03-159">When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method).</span></span> <span data-ttu-id="c7e03-160">Quand un thread demande un accès exclusif (par exemple, en appelant la méthode <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>), les demandes suivantes des lecteurs sont bloquées jusqu'à ce que tous les lecteurs existants aient libéré le verrou et que le writer ait acquis et libéré le verrou.</span><span class="sxs-lookup"><span data-stu-id="c7e03-160">When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>  
  
 <span data-ttu-id="c7e03-161"><xref:System.Threading.ReaderWriterLockSlim> possède l’affinité de thread.</span><span class="sxs-lookup"><span data-stu-id="c7e03-161"><xref:System.Threading.ReaderWriterLockSlim> has thread affinity.</span></span>  
  
 <span data-ttu-id="c7e03-162">Pour une vue d’ensemble conceptuelle, consultez [Verrous de lecteur-writer](../../../docs/standard/threading/reader-writer-locks.md).</span><span class="sxs-lookup"><span data-stu-id="c7e03-162">For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md).</span></span>  
  
#### <a name="semaphore-class"></a><span data-ttu-id="c7e03-163">Semaphore (classe)</span><span class="sxs-lookup"><span data-stu-id="c7e03-163">Semaphore Class</span></span>  
 <span data-ttu-id="c7e03-164">La classe <xref:System.Threading.Semaphore> permet à un nombre spécifié de threads d'accéder à une ressource.</span><span class="sxs-lookup"><span data-stu-id="c7e03-164">The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource.</span></span> <span data-ttu-id="c7e03-165">Les autres threads qui demandent la ressource sont bloqués jusqu'à ce qu'un thread libère le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="c7e03-165">Additional threads requesting the resource block until a thread releases the semaphore.</span></span>  
  
 <span data-ttu-id="c7e03-166">À l’instar de la classe <xref:System.Threading.Mutex>, <xref:System.Threading.Semaphore> dérive de <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-166">Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="c7e03-167">De plus, comme <xref:System.Threading.Mutex>, un <xref:System.Threading.Semaphore> peut être local ou global.</span><span class="sxs-lookup"><span data-stu-id="c7e03-167">Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global.</span></span> <span data-ttu-id="c7e03-168">Il peut être utilisé au-delà des limites des domaines d'application.</span><span class="sxs-lookup"><span data-stu-id="c7e03-168">It can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="c7e03-169">Contrairement à <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> et <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> ne possède pas l’affinité de thread.</span><span class="sxs-lookup"><span data-stu-id="c7e03-169">Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity.</span></span> <span data-ttu-id="c7e03-170">Cela signifie qu’il peut être utilisé dans des scénarios où un thread acquiert le sémaphore et un autre le libère.</span><span class="sxs-lookup"><span data-stu-id="c7e03-170">This means it can be used in scenarios where one thread acquires the semaphore and another releases it.</span></span>  
  
 <span data-ttu-id="c7e03-171">Pour une vue d’ensemble conceptuelle, consultez [Semaphore et SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="c7e03-171">For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="c7e03-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> est un sémaphore léger pour la synchronisation dans la limite d’un processus unique.</span><span class="sxs-lookup"><span data-stu-id="c7e03-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight semaphore for synchronization within a single process boundary.</span></span>  
  
 [<span data-ttu-id="c7e03-173">Retour au début</span><span class="sxs-lookup"><span data-stu-id="c7e03-173">Back to top</span></span>](#top)  
  
<a name="signaling"></a>   
## <a name="signaling"></a><span data-ttu-id="c7e03-174">Signalisation</span><span class="sxs-lookup"><span data-stu-id="c7e03-174">Signaling</span></span>  
 <span data-ttu-id="c7e03-175">La façon la plus simple d’attendre un signal d'un autre thread consiste à appeler la méthode <xref:System.Threading.Thread.Join%2A>, qui se bloque jusqu'à ce que l'autre thread se termine.</span><span class="sxs-lookup"><span data-stu-id="c7e03-175">The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes.</span></span> <span data-ttu-id="c7e03-176"><xref:System.Threading.Thread.Join%2A> a deux surcharges qui autorisent le thread bloqué à abandonner l'attente après un intervalle spécifié.</span><span class="sxs-lookup"><span data-stu-id="c7e03-176"><xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.</span></span>  
  
 <span data-ttu-id="c7e03-177">Les handles d'attente fournissent un ensemble beaucoup plus riche de fonctions d'attente et de signalisation.</span><span class="sxs-lookup"><span data-stu-id="c7e03-177">Wait handles provide a much richer set of waiting and signaling capabilities.</span></span>  
  
### <a name="wait-handles"></a><span data-ttu-id="c7e03-178">Handles d'attente</span><span class="sxs-lookup"><span data-stu-id="c7e03-178">Wait Handles</span></span>  
 <span data-ttu-id="c7e03-179">Les handles d'attente dérivent de la classe <xref:System.Threading.WaitHandle>, qui, elle-même, dérive de <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-179">Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="c7e03-180">Par conséquent, les handles d'attente peuvent être utilisés pour synchroniser les activités des threads au-delà des limites des domaines d'application.</span><span class="sxs-lookup"><span data-stu-id="c7e03-180">Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="c7e03-181">Les threads se bloquent sur les handles d’attente en appelant la méthode d'instance <xref:System.Threading.WaitHandle.WaitOne%2A> ou l'une des méthodes statiques <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> ou <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-181">Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span></span> <span data-ttu-id="c7e03-182">La façon dont ils sont libérés dépend de la méthode appelée et du type de handles d’attente.</span><span class="sxs-lookup"><span data-stu-id="c7e03-182">How they are released depends on which method was called, and on the kind of wait handles.</span></span>  
  
 <span data-ttu-id="c7e03-183">Pour bénéficier d’une vue d’ensemble conceptuelle, consultez [Handles d’attente](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span><span class="sxs-lookup"><span data-stu-id="c7e03-183">For a conceptual overview, see [Wait Handles](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span></span>  
  
#### <a name="event-wait-handles"></a><span data-ttu-id="c7e03-184">Handles d'attente d'événement</span><span class="sxs-lookup"><span data-stu-id="c7e03-184">Event Wait Handles</span></span>  
 <span data-ttu-id="c7e03-185">Les handles d'attente d'événement incluent la classe <xref:System.Threading.EventWaitHandle> et ses classes dérivées <xref:System.Threading.AutoResetEvent> et <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-185">Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="c7e03-186">Les threads sont libérés d'un handle d'attente d'événement quand ce dernier en reçoit le signal par l’appel à sa méthode <xref:System.Threading.EventWaitHandle.Set%2A> ou à l'aide de la méthode <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-186">Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span>  
  
 <span data-ttu-id="c7e03-187">Les handles d’attente d’événement se réinitialisent automatiquement, à l’instar d’un tourniquet qui permet le passage d’un seul thread à chaque signal reçu, ou ils doivent être réinitialisés manuellement, comme une barrière qui reste fermée jusqu'à la réception d’un signal d’ouverture, puis reste ouverte jusqu'à ce que quelqu'un la ferme.</span><span class="sxs-lookup"><span data-stu-id="c7e03-187">Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it.</span></span> <span data-ttu-id="c7e03-188">Comme leurs noms l'indiquent, <xref:System.Threading.AutoResetEvent> et <xref:System.Threading.ManualResetEvent> représentent le premier et le second type de réinitialisation, respectivement.</span><span class="sxs-lookup"><span data-stu-id="c7e03-188">As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively.</span></span> <span data-ttu-id="c7e03-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> est un événement léger pour la synchronisation dans une limite de processus unique.</span><span class="sxs-lookup"><span data-stu-id="c7e03-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight event for synchronization within a single process boundary.</span></span>  
  
 <span data-ttu-id="c7e03-190"><xref:System.Threading.EventWaitHandle> peut représenter les deux types d'événement et peut être local ou global.</span><span class="sxs-lookup"><span data-stu-id="c7e03-190">An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global.</span></span> <span data-ttu-id="c7e03-191">Les classes dérivées <xref:System.Threading.AutoResetEvent> et <xref:System.Threading.ManualResetEvent> sont toujours locales.</span><span class="sxs-lookup"><span data-stu-id="c7e03-191">The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local.</span></span>  
  
 <span data-ttu-id="c7e03-192">Les handles d'attente d'événement n'ont pas d'affinité de thread.</span><span class="sxs-lookup"><span data-stu-id="c7e03-192">Event wait handles do not have thread affinity.</span></span> <span data-ttu-id="c7e03-193">Un thread quelconque peut envoyer un signal à un handle d'attente d'événement.</span><span class="sxs-lookup"><span data-stu-id="c7e03-193">Any thread can signal an event wait handle.</span></span>  
  
 <span data-ttu-id="c7e03-194">Pour bénéficier d’une vue d’ensemble conceptuelle, consultez [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="c7e03-194">For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
#### <a name="mutex-and-semaphore-classes"></a><span data-ttu-id="c7e03-195">Classes Mutex et Semaphore</span><span class="sxs-lookup"><span data-stu-id="c7e03-195">Mutex and Semaphore Classes</span></span>  
 <span data-ttu-id="c7e03-196">Comme les classes <xref:System.Threading.Mutex> et <xref:System.Threading.Semaphore> dérivent de <xref:System.Threading.WaitHandle>, elles peuvent être utilisées avec les méthodes statiques de <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-196">Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="c7e03-197">Par exemple, un thread peut utiliser la méthode <xref:System.Threading.WaitHandle.WaitAll%2A> pour attendre que les trois conditions suivantes soient vraies : <xref:System.Threading.EventWaitHandle> est signalé, <xref:System.Threading.Mutex> est libéré et <xref:System.Threading.Semaphore> est libéré.</span><span class="sxs-lookup"><span data-stu-id="c7e03-197">For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released.</span></span> <span data-ttu-id="c7e03-198">De même, un thread peut utiliser la méthode <xref:System.Threading.WaitHandle.WaitAny%2A> pour attendre que l'une de ces conditions soit vraie.</span><span class="sxs-lookup"><span data-stu-id="c7e03-198">Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true.</span></span>  
  
 <span data-ttu-id="c7e03-199">Pour <xref:System.Threading.Mutex> ou <xref:System.Threading.Semaphore>, recevoir un signal signifie être libéré.</span><span class="sxs-lookup"><span data-stu-id="c7e03-199">For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released.</span></span> <span data-ttu-id="c7e03-200">Si l’un des deux types est utilisé comme premier argument de la méthode <xref:System.Threading.WaitHandle.SignalAndWait%2A>, il est libéré.</span><span class="sxs-lookup"><span data-stu-id="c7e03-200">If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released.</span></span> <span data-ttu-id="c7e03-201">Dans le cas de <xref:System.Threading.Mutex>, qui possède l’affinité de thread, une exception est levée si le thread appelant n’est pas propriétaire du mutex.</span><span class="sxs-lookup"><span data-stu-id="c7e03-201">In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex.</span></span> <span data-ttu-id="c7e03-202">Comme mentionné précédemment, les sémaphores n'ont pas d'affinité de thread.</span><span class="sxs-lookup"><span data-stu-id="c7e03-202">As noted previously, semaphores do not have thread affinity.</span></span>  
  
#### <a name="barrier"></a><span data-ttu-id="c7e03-203">Cloisonnement</span><span class="sxs-lookup"><span data-stu-id="c7e03-203">Barrier</span></span>  
 <span data-ttu-id="c7e03-204">La classe <xref:System.Threading.Barrier> permet de synchroniser plusieurs threads cycliquement afin qu'ils se bloquent tous au même point et attendent que tous les autres threads soient terminés.</span><span class="sxs-lookup"><span data-stu-id="c7e03-204">The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete.</span></span> <span data-ttu-id="c7e03-205">Le cloisonnement est utile quand un ou plusieurs threads requièrent les résultats d'un autre thread avant de passer à la phase suivante d'un algorithme.</span><span class="sxs-lookup"><span data-stu-id="c7e03-205">A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm.</span></span> <span data-ttu-id="c7e03-206">Pour plus d’informations, voir [Cloisonnement](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="c7e03-206">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>  
  
 [<span data-ttu-id="c7e03-207">Retour au début</span><span class="sxs-lookup"><span data-stu-id="c7e03-207">Back to top</span></span>](#top)  
  
<a name="lightweight_synchronization_types"></a>   
## <a name="lightweight-synchronization-types"></a><span data-ttu-id="c7e03-208">Types de synchronisation légers</span><span class="sxs-lookup"><span data-stu-id="c7e03-208">Lightweight Synchronization Types</span></span>  
 <span data-ttu-id="c7e03-209">À partir du [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], vous pouvez utiliser des primitives de synchronisation qui fournissent des performances rapides en évitant une dépendance complexe sur les objets de noyau Win32, tels que les handles d’attente, chaque fois que possible.</span><span class="sxs-lookup"><span data-stu-id="c7e03-209">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.</span></span> <span data-ttu-id="c7e03-210">En général, vous devez utiliser ces types quand les temps d’attente sont courts et uniquement lorsque les types de synchronisation d’origine ont été essayés et ont donné des résultats non satisfaisants.</span><span class="sxs-lookup"><span data-stu-id="c7e03-210">In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory.</span></span> <span data-ttu-id="c7e03-211">Les types légers ne peuvent pas être utilisés dans les scénarios qui requièrent une communication interprocessus.</span><span class="sxs-lookup"><span data-stu-id="c7e03-211">The lightweight types cannot be used in scenarios that require cross-process communication.</span></span>  
  
-   <span data-ttu-id="c7e03-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> est une version légère de <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="c7e03-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> est une version légère de <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="c7e03-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> représente un événement signalé quand son nombre est égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="c7e03-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> represents an event that becomes signaled when its count is zero.</span></span>  
  
-   <span data-ttu-id="c7e03-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> permet à plusieurs threads de se synchroniser les uns avec les autres sans nécessiter le contrôle d'un thread principal.</span><span class="sxs-lookup"><span data-stu-id="c7e03-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> enables multiple threads to synchronize with one another without requiring control by a master thread.</span></span> <span data-ttu-id="c7e03-216">Un cloisonnement empêche chaque thread de continuer jusqu'à ce que tous les threads aient atteint un point spécifié.</span><span class="sxs-lookup"><span data-stu-id="c7e03-216">A barrier prevents each thread from continuing until all threads have reached a specified point.</span></span>  
  
 [<span data-ttu-id="c7e03-217">Retour au début</span><span class="sxs-lookup"><span data-stu-id="c7e03-217">Back to top</span></span>](#top)  
  
<a name="spinwait"></a>   
## <a name="spinwait"></a><span data-ttu-id="c7e03-218">SpinWait</span><span class="sxs-lookup"><span data-stu-id="c7e03-218">SpinWait</span></span>  
 <span data-ttu-id="c7e03-219">À partir du [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], vous pouvez utiliser la structure <xref:System.Threading.SpinWait?displayProperty=nameWithType> quand un thread doit attendre le signalement d'un événement ou la satisfaction d'une condition, mais quand le temps d'attente réel est supposé être inférieur à la latence requise, en utilisant un descripteur d'attente ou en bloquant le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="c7e03-219">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread.</span></span> <span data-ttu-id="c7e03-220">À l'aide de <xref:System.Threading.SpinWait>, vous pouvez spécifier une courte période de rotation pendant l'attente, puis générer (par exemple, en attente ou en veille) uniquement si la condition n'a pas été remplie dans le délai spécifié.</span><span class="sxs-lookup"><span data-stu-id="c7e03-220">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>  
  
 [<span data-ttu-id="c7e03-221">Retour au début</span><span class="sxs-lookup"><span data-stu-id="c7e03-221">Back to top</span></span>](#top)  
  
<a name="interlocked_operations"></a>   
## <a name="interlocked-operations"></a><span data-ttu-id="c7e03-222">Opérations verrouillées</span><span class="sxs-lookup"><span data-stu-id="c7e03-222">Interlocked Operations</span></span>  
 <span data-ttu-id="c7e03-223">Les opérations verrouillées sont de simples opérations atomiques exécutées dans un emplacement de mémoire par les méthodes statiques de la classe <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="c7e03-223">Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="c7e03-224">Ces opérations atomiques incluent l'addition, l’incrémentation et la décrémentation, l’échange et l’échange conditionnel en fonction d'une comparaison, ainsi que des opérations de lecture pour des valeurs 64 bits sur les plateformes 32 bits.</span><span class="sxs-lookup"><span data-stu-id="c7e03-224">Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c7e03-225">L’atomicité n’est garantie que dans le cadre d’opérations individuelles. Quand plusieurs opérations doivent être exécutées en tant qu'unité, un mécanisme de synchronisation plus grossier doit être utilisé.</span><span class="sxs-lookup"><span data-stu-id="c7e03-225">The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.</span></span>  
  
 <span data-ttu-id="c7e03-226">Bien qu’aucune de ces opérations ne constitue un verrou ou un signal, elles peuvent être utilisées pour construire des verrous et des signaux.</span><span class="sxs-lookup"><span data-stu-id="c7e03-226">Although none of these operations are locks or signals, they can be used to construct locks and signals.</span></span> <span data-ttu-id="c7e03-227">Étant natives au système d'exploitation Windows, les opérations verrouillées sont extrêmement rapides.</span><span class="sxs-lookup"><span data-stu-id="c7e03-227">Because they are native to the Windows operating system, interlocked operations are extremely fast.</span></span>  
  
 <span data-ttu-id="c7e03-228">Elles peuvent être utilisées avec des garanties de mémoire volatile pour écrire des applications qui proposent un accès simultané non bloquant puissant.</span><span class="sxs-lookup"><span data-stu-id="c7e03-228">Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency.</span></span> <span data-ttu-id="c7e03-229">Toutefois, elles exigent une programmation de bas niveau sophistiquée et donc, dans la plupart des cas, les verrous simples constituent un choix plus adapté.</span><span class="sxs-lookup"><span data-stu-id="c7e03-229">However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.</span></span>  
  
 <span data-ttu-id="c7e03-230">Pour bénéficier d’une vue d’ensemble conceptuelle, consultez [Opérations verrouillées](../../../docs/standard/threading/interlocked-operations.md).</span><span class="sxs-lookup"><span data-stu-id="c7e03-230">For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c7e03-231">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="c7e03-231">See also</span></span>

- [<span data-ttu-id="c7e03-232">Synchronisation des données pour le multithreading</span><span class="sxs-lookup"><span data-stu-id="c7e03-232">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
- [<span data-ttu-id="c7e03-233">Moniteurs</span><span class="sxs-lookup"><span data-stu-id="c7e03-233">Monitors</span></span>](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)  
- [<span data-ttu-id="c7e03-234">Mutex</span><span class="sxs-lookup"><span data-stu-id="c7e03-234">Mutexes</span></span>](../../../docs/standard/threading/mutexes.md)  
- [<span data-ttu-id="c7e03-235">Semaphore et SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="c7e03-235">Semaphore and SemaphoreSlim</span></span>](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)  
- [<span data-ttu-id="c7e03-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="c7e03-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)  
- [<span data-ttu-id="c7e03-237">Descripteurs d’attente</span><span class="sxs-lookup"><span data-stu-id="c7e03-237">Wait Handles</span></span>](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)  
- [<span data-ttu-id="c7e03-238">Opérations verrouillées</span><span class="sxs-lookup"><span data-stu-id="c7e03-238">Interlocked Operations</span></span>](../../../docs/standard/threading/interlocked-operations.md)  
- [<span data-ttu-id="c7e03-239">Verrous de lecteur-writer</span><span class="sxs-lookup"><span data-stu-id="c7e03-239">Reader-Writer Locks</span></span>](../../../docs/standard/threading/reader-writer-locks.md)  
- [<span data-ttu-id="c7e03-240">Barrier</span><span class="sxs-lookup"><span data-stu-id="c7e03-240">Barrier</span></span>](../../../docs/standard/threading/barrier.md)  
- [<span data-ttu-id="c7e03-241">SpinWait</span><span class="sxs-lookup"><span data-stu-id="c7e03-241">SpinWait</span></span>](../../../docs/standard/threading/spinwait.md)  
- [<span data-ttu-id="c7e03-242">SpinLock</span><span class="sxs-lookup"><span data-stu-id="c7e03-242">SpinLock</span></span>](../../../docs/standard/threading/spinlock.md)
