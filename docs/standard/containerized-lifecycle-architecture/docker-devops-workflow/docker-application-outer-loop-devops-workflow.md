---
title: "Étapes de workflow DevOps boucle externe pour une application de Docker"
description: Cycle de vie des applications Docker en conteneur avec la plateforme et les outils Microsoft
keywords: Docker, microservices, ASP.NET, conteneur
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/22/2017
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: fe51fc4b5026d17f0f9b93e7fd0dedde93ef4a3c
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/23/2017
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="85db6-104">Étapes de workflow DevOps boucle externe pour une application de Docker</span><span class="sxs-lookup"><span data-stu-id="85db6-104">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="85db6-105">Figure 5-1 présente une description de bout en bout des étapes comprenant le flux de travail DevOps boucle externe.</span><span class="sxs-lookup"><span data-stu-id="85db6-105">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span>

![](./media/image1.png)

<span data-ttu-id="85db6-106">Flux de travail de la figure 5-1 : DevOps boucle externe pour les applications de Docker avec des outils Microsoft</span><span class="sxs-lookup"><span data-stu-id="85db6-106">Figure 5-1: DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="85db6-107">Maintenant, nous allons examiner chacune de ces étapes en détail.</span><span class="sxs-lookup"><span data-stu-id="85db6-107">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="85db6-108">Étape 1 : Processus de développement de la boucle interne</span><span class="sxs-lookup"><span data-stu-id="85db6-108">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="85db6-109">Cette étape est expliquée en détail dans le chapitre 4, mais, pour résumer, voici où la boucle externe commence, le moment auquel un développeur exécute un push de code pour le système de gestion de contrôle de source (comme Git) initiation d’actions de pipeline de l’élément de configuration.</span><span class="sxs-lookup"><span data-stu-id="85db6-109">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-visual-studio-team-services-and-git"></a><span data-ttu-id="85db6-110">Étape 2 : L’intégration du contrôle de Code Source et la gestion avec Visual Studio Team Services et Git</span><span class="sxs-lookup"><span data-stu-id="85db6-110">Step 2: Source-Code Control integration and management with Visual Studio Team Services and Git</span></span>

<span data-ttu-id="85db6-111">À cette étape, vous devez disposer d’un système de contrôle de version pour collecter une version consolidée de tout le code provenant des différents développeurs de l’équipe.</span><span class="sxs-lookup"><span data-stu-id="85db6-111">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="85db6-112">Même si le contrôle de code source (SCC) et de gestion de code source peuvent sembler à la plupart des développeurs, lors de la création d’applications de Docker dans une durée de vie DevOps cycle seconde-nature, il est essentiel de souligner que vous ne devez pas envoyer les images Docker avec l’application directement dans le Registre de Docker global (comme le Registre de conteneur Azure ou le Hub d’ancrage) à partir de l’ordinateur du développeur.</span><span class="sxs-lookup"><span data-stu-id="85db6-112">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it is critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="85db6-113">En revanche, les images Docker être libéré et déployées sur des environnements de production doivent être créés uniquement sur le code source qui sont intégré dans votre build global ou d’un pipeline de l’élément de configuration en fonction de votre référentiel de code source (comme Git).</span><span class="sxs-lookup"><span data-stu-id="85db6-113">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that is being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="85db6-114">Les images locales générées par les développeurs eux-mêmes doivent être utilisés uniquement par les développeurs lors du test au sein de leurs propres ordinateurs.</span><span class="sxs-lookup"><span data-stu-id="85db6-114">The local images generated by the developers themselves should be used just by the developers when testing within their own machines.</span></span> <span data-ttu-id="85db6-115">C’est pourquoi il est essentiel pour que le pipeline DevOps activé à partir du code de contrôle de code source.</span><span class="sxs-lookup"><span data-stu-id="85db6-115">This is why it is critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="85db6-116">Visual Studio Team Services et Team Foundation Server prend en charge Git et Team Foundation Version Control.</span><span class="sxs-lookup"><span data-stu-id="85db6-116">Visual Studio Team Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="85db6-117">Vous pouvez choisir entre eux et l’utiliser pour une expérience de Microsoft de bout en bout.</span><span class="sxs-lookup"><span data-stu-id="85db6-117">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="85db6-118">Toutefois, vous pouvez également gérer votre code dans des référentiels externes (tels que GitHub, les référentiels Git locaux ou Subversion) et toujours être en mesure de s’y connecter et obtenir le code comme point de départ pour votre pipeline de l’élément de configuration DevOps.</span><span class="sxs-lookup"><span data-stu-id="85db6-118">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-visual-studio-team-services-and-docker"></a><span data-ttu-id="85db6-119">Étape 3 : Build, l’élément de configuration, intégrer et tester avec Visual Studio Team Services et Docker</span><span class="sxs-lookup"><span data-stu-id="85db6-119">Step 3: Build, CI, Integrate, and Test with Visual Studio Team Services and Docker</span></span>

<span data-ttu-id="85db6-120">L’élément de configuration est devenue une norme pour le test de logiciels modernes et de remise.</span><span class="sxs-lookup"><span data-stu-id="85db6-120">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="85db6-121">La solution de Docker gère une séparation nette entre les équipes de développement et les opérations.</span><span class="sxs-lookup"><span data-stu-id="85db6-121">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="85db6-122">Immuabilité des images Docker permet de garantir un déploiement reproductible entre ce qui a développé, testé via l’élément de configuration et exécuter en production.</span><span class="sxs-lookup"><span data-stu-id="85db6-122">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="85db6-123">Moteur docker déployé sur les ordinateurs portables développeur et infrastructure de test rend les conteneurs portable dans des environnements.</span><span class="sxs-lookup"><span data-stu-id="85db6-123">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="85db6-124">À ce stade, une fois que vous avez un système de contrôle de version avec le code correct soumis, vous avez besoin une *service de build* pour récupérer le code et exécuter le build global et les tests.</span><span class="sxs-lookup"><span data-stu-id="85db6-124">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="85db6-125">Le flux de travail interne pour cette étape (l’élément de configuration, build, de test) est sur la construction d’un pipeline de l’élément de configuration consistant à votre référentiel de code (Git, etc.), votre serveur de builds (Visual Studio Team Services), moteur Docker et un Registre Docker.</span><span class="sxs-lookup"><span data-stu-id="85db6-125">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Visual Studio Team Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="85db6-126">Vous pouvez utiliser Visual Studio Team Services comme base pour la création de vos applications et la définition de votre pipeline de l’élément de configuration et pour la publication des génération « artefacts » pour un « référentiel d’artefacts, » qui est expliqué dans l’étape suivante.</span><span class="sxs-lookup"><span data-stu-id="85db6-126">You can use Visual Studio Team Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="85db6-127">Lors de l’utilisation de Docker pour le déploiement, les « artefacts finals » pour le déploiement sont les images Docker avec votre application ou les services incorporées dans les.</span><span class="sxs-lookup"><span data-stu-id="85db6-127">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="85db6-128">Ces images sont envoyées ou publiés sur un *Docker Registre* (référentiel privé, comme ceux que vous pouvez avoir dans le Registre de conteneur Azure ou une publique comme registre Docker Hub, qui est couramment utilisé pour les images de base officiels).</span><span class="sxs-lookup"><span data-stu-id="85db6-128">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="85db6-129">Voici le concept de base : l’élément de configuration du pipeline sera exclu-désactivée par une validation à un référentiel de contrôle de code source comme Git.</span><span class="sxs-lookup"><span data-stu-id="85db6-129">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="85db6-130">La validation entraîne Visual Studio Team Services exécuter une tâche de build dans un conteneur Docker et, en cas de réussite de ce travail, distribuer une image Docker dans le Registre Docker, comme illustré dans la Figure 5-2.</span><span class="sxs-lookup"><span data-stu-id="85db6-130">The commit will cause Visual Studio Team Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="85db6-131">Figure 5-2 : les étapes impliquées dans l’élément de configuration</span><span class="sxs-lookup"><span data-stu-id="85db6-131">Figure 5-2: The steps involved in CI</span></span>

<span data-ttu-id="85db6-132">Voici les étapes de flux de travail de l’élément de configuration base avec Docker et Visual Studio Team Services :</span><span class="sxs-lookup"><span data-stu-id="85db6-132">Here are the basic CI workflow steps with Docker and Visual Studio Team Services:</span></span>

1.  <span data-ttu-id="85db6-133">Le développeur exécute un push d’une validation à un référentiel de contrôle de code source (Git/Visual Studio Team Services, GitHub, etc.).</span><span class="sxs-lookup"><span data-stu-id="85db6-133">The developer pushes a commit to an SCC repository (Git/Visual Studio Team Services, GitHub, etc.).</span></span>

2.  <span data-ttu-id="85db6-134">Si vous utilisez Visual Studio Team Services ou Git, l’élément de configuration intégrée, ce qui signifie qu’il est aussi simple que la sélection d’une case à cocher dans Visual Studio Team Services.</span><span class="sxs-lookup"><span data-stu-id="85db6-134">If you're using Visual Studio Team Services or Git, CI is built in, which means that it is as simple as selecting a check box in Visual Studio Team Services.</span></span> <span data-ttu-id="85db6-135">Si vous utilisez un contrôle de code source externe (par exemple, GitHub), un *webhook* sera de notifier Visual Studio Team Services de la mise à jour ou de type push vers Git/GitHub.</span><span class="sxs-lookup"><span data-stu-id="85db6-135">If you're using an external SCC (like GitHub), a *webhook* will notify Visual Studio Team Services of the update or push to Git/GitHub.</span></span>

3.  <span data-ttu-id="85db6-136">Visual Studio Team Services extrait du référentiel de contrôle de code source, y compris le fichier DockerFile décrivant l’image, ainsi que le code d’application et de test.</span><span class="sxs-lookup"><span data-stu-id="85db6-136">Visual Studio Team Services pulls the SCC repository, including the DockerFile describing the image as well as the application and test code.</span></span>

4.  <span data-ttu-id="85db6-137">Visual Studio Team Services génère une image Docker et le marque en avec un numéro de build.</span><span class="sxs-lookup"><span data-stu-id="85db6-137">Visual Studio Team Services builds a Docker image and labels it with a build number.</span></span>

5.  <span data-ttu-id="85db6-138">Visual Studio Team Services instancie le conteneur Docker dans l’hôte Docker mis en service et exécute les tests appropriés.</span><span class="sxs-lookup"><span data-stu-id="85db6-138">Visual Studio Team Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6.  <span data-ttu-id="85db6-139">Si les tests réussissent, l’image est tout d’abord un nouveau libellée à un nom explicite afin que vous sachiez il s’agit d’une « build privilégiée » (tels que « / 1.0.0 » ou n’importe quel autre étiquette) et ensuite transmis à votre Registre Docker (Docker Hub, Registre de conteneur Azure, DTR, etc.).</span><span class="sxs-lookup"><span data-stu-id="85db6-139">If the tests are successful, the image is first relabeled to a meaningful name so that you know it is a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-visual-studio-team-services-and-the-docker-extension-for-visual-studio-team-services"></a><span data-ttu-id="85db6-140">Mise en œuvre le pipeline de l’élément de configuration avec Visual Studio Team Services et l’extension Docker pour Visual Studio Team Services</span><span class="sxs-lookup"><span data-stu-id="85db6-140">Implementing the CI pipeline with Visual Studio Team Services and the Docker extension for Visual Studio Team Services</span></span>

<span data-ttu-id="85db6-141">Le [extension Visual Studio Team Services Docker](https://aka.ms/vstsdockerextension) ajoute une tâche à votre pipeline de l’élément de configuration avec laquelle vous pouvez créer des images de Docker, push Docker images dans un Registre Docker authentifié, exécutez Docker images ou exécuter d’autres opérations offertes par le Docker CLI.</span><span class="sxs-lookup"><span data-stu-id="85db6-141">The [Visual Studio Team Services Docker extension](https://aka.ms/vstsdockerextension) adds a task to your CI pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="85db6-142">Il ajoute également une tâche Docker Compose que vous pouvez utiliser pour créer, transmettre et exécuter des applications de Docker multicontainer ou exécuter d’autres opérations offertes par la CLI composer Docker, comme indiqué dans la Figure 5-3.</span><span class="sxs-lookup"><span data-stu-id="85db6-142">It also adds a Docker Compose task that you can use to build, push, and run multicontainer Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![](./media/image3.png)

<span data-ttu-id="85db6-143">Figure 5-3 : le pipeline de l’élément de configuration Docker dans Visual Studio Team Services</span><span class="sxs-lookup"><span data-stu-id="85db6-143">Figure 5-3: The Docker CI pipeline in Visual Studio Team Services</span></span>

<span data-ttu-id="85db6-144">L’extension Docker pouvez utiliser des points de terminaison de service pour les ordinateurs hôtes de Docker et pour que les registres de l’image ou du conteneur.</span><span class="sxs-lookup"><span data-stu-id="85db6-144">The Docker extension can use service endpoints for Docker hosts and for container or image registries.</span></span> <span data-ttu-id="85db6-145">La valeur par défaut de tâches à l’aide d’un hôte Docker local s’il est disponible (cela actuellement requiert un agent de Visual Studio Team Services personnalisé) ; dans le cas contraire, ils nécessitent que vous fournissez une connexion d’hôte Docker.</span><span class="sxs-lookup"><span data-stu-id="85db6-145">The tasks default to using a local Docker host if available (this currently requires a custom Visual Studio Team Services agent); otherwise, they require that you provide a Docker host connection.</span></span> <span data-ttu-id="85db6-146">Les actions qui dépendent d’authentifié avec un Registre Docker, par exemple en exécutant un push d’une image, nécessitent que vous fournissiez une Docker connexion du Registre.</span><span class="sxs-lookup"><span data-stu-id="85db6-146">Actions that depend on being authenticated with a Docker registry, such as pushing an image, require that you provide a Docker registry connection.</span></span>

<span data-ttu-id="85db6-147">L’extension de Visual Studio Team Services Docker installe les composants suivants dans votre compte Visual Studio Team Services :</span><span class="sxs-lookup"><span data-stu-id="85db6-147">The Visual Studio Team Services Docker extension installs the following components in your Visual Studio Team Services account:</span></span>

-   <span data-ttu-id="85db6-148">Un point de terminaison de service pour se connecter à un Registre Docker</span><span class="sxs-lookup"><span data-stu-id="85db6-148">A service endpoint for connecting to a Docker registry</span></span>

-   <span data-ttu-id="85db6-149">Un point de terminaison de service pour se connecter à un hôte de conteneur Docker</span><span class="sxs-lookup"><span data-stu-id="85db6-149">A service endpoint for connecting to a Docker Container Host</span></span>

-   <span data-ttu-id="85db6-150">Une tâche de Docker pour effectuer les opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="85db6-150">A Docker task to do the following:</span></span>

-   <span data-ttu-id="85db6-151">Créer une image</span><span class="sxs-lookup"><span data-stu-id="85db6-151">Build an image</span></span>

-   <span data-ttu-id="85db6-152">Distribuer une image ou un référentiel à un Registre</span><span class="sxs-lookup"><span data-stu-id="85db6-152">Push an image or a repository to a registry</span></span>

-   <span data-ttu-id="85db6-153">Exécuter une image dans un conteneur</span><span class="sxs-lookup"><span data-stu-id="85db6-153">Run an image in a container</span></span>

-   <span data-ttu-id="85db6-154">Exécuter une commande Docker</span><span class="sxs-lookup"><span data-stu-id="85db6-154">Run a Docker command</span></span>

-   <span data-ttu-id="85db6-155">Une tâche Docker Compose pour exécuter une commande Docker Compose</span><span class="sxs-lookup"><span data-stu-id="85db6-155">A Docker Compose task to run a Docker Compose command</span></span>

<span data-ttu-id="85db6-156">Avec ces tâches Visual Studio Team Services, une build Docker de Linux/machine virtuelle d’hôte mis en service dans Azure et votre Registre Docker préféré (Registre de conteneur Azure, Docker Hub, privé Docker DTR ou tout autre registre Docker), vous pouvez assembler votre pipeline de l’élément de configuration de Docker dans un très cohérente.</span><span class="sxs-lookup"><span data-stu-id="85db6-156">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="85db6-157">***Configuration requise :***</span><span class="sxs-lookup"><span data-stu-id="85db6-157">***Requirements:***</span></span>

-   <span data-ttu-id="85db6-158">Visual Studio Team Services, ou pour les installations locales, Team Foundation Server 2015 Update 3 ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="85db6-158">Visual Studio Team Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

-   <span data-ttu-id="85db6-159">Un agent de Visual Studio Team Services contenant les fichiers binaires de Docker.</span><span class="sxs-lookup"><span data-stu-id="85db6-159">A Visual Studio Team Services agent that has the Docker binaries.</span></span>

<span data-ttu-id="85db6-160">Il est un moyen simple de créer un de ces Docker permet d’exécuter un conteneur en fonction de l’image de Docker de l’agent de Visual Studio Team Services.</span><span class="sxs-lookup"><span data-stu-id="85db6-160">An easy way to create one of these is to use Docker to run a container based on the Visual Studio Team Services agent Docker image.</span></span>

<span data-ttu-id="85db6-161">**Plus d’informations** pour en savoir plus sur l’assemblage un Visual Studio Team Services Docker l’élément de configuration de pipeline et que vous pour afficher les procédures pas à pas, visitez les sites suivants :</span><span class="sxs-lookup"><span data-stu-id="85db6-161">**More info** To read more about assembling a Visual Studio Team Services Docker CI pipeline and to view walkthroughs, visit the following sites:</span></span>

<span data-ttu-id="85db6-162">Exécution d’un agent de Visual Studio Team Services comme un conteneur Docker : [https://hub.docker.com/r/ \ vsts/microsoft-agent /](https://hub.docker.com/r/microsoft/vsts-agent/)</span><span class="sxs-lookup"><span data-stu-id="85db6-162">Running a Visual Studio Team Services agent as a Docker container: [https://hub.docker.com/r/\ microsoft/vsts-agent/](https://hub.docker.com/r/microsoft/vsts-agent/)</span></span>

<span data-ttu-id="85db6-163">Extension Docker de VSTS : <https://aka.ms/vstsdockerextension></span><span class="sxs-lookup"><span data-stu-id="85db6-163">VSTS Docker extension: <https://aka.ms/vstsdockerextension></span></span>

<span data-ttu-id="85db6-164">Création d’images de .NET Core Linux Docker avec Visual Studio Team Services : <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span><span class="sxs-lookup"><span data-stu-id="85db6-164">Building .NET Core Linux Docker images with Visual Studio Team Services: <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span></span>

<span data-ttu-id="85db6-165">Création d’un basés sur Linux Service Visual Studio Team build ordinateur avec prise en charge Docker : <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span><span class="sxs-lookup"><span data-stu-id="85db6-165">Building a Linux-based Visual Studio Team Service build machine with Docker support: <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span></span>

### <a name="integrate-test-and-validate-multicontainer-docker-applications"></a><span data-ttu-id="85db6-166">Intégrer, tester et valider des applications de Docker multicontainer</span><span class="sxs-lookup"><span data-stu-id="85db6-166">Integrate, test, and validate multicontainer Docker applications</span></span>

<span data-ttu-id="85db6-167">En règle générale, la plupart des applications de Docker sont composées de plusieurs conteneurs plutôt qu’un seul conteneur.</span><span class="sxs-lookup"><span data-stu-id="85db6-167">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="85db6-168">Un bon exemple est une application microservices pour lequel vous aurait un conteneur par microservice.</span><span class="sxs-lookup"><span data-stu-id="85db6-168">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="85db6-169">Toutefois, même sans en suivant les modèles d’approche microservices, il est très probable que votre application de Docker est composée de plusieurs conteneurs ou les services.</span><span class="sxs-lookup"><span data-stu-id="85db6-169">But, even without strictly following the microservices approach patterns, it is very probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="85db6-170">Par conséquent, après avoir généré les conteneurs d’applications dans le pipeline de l’élément de configuration, vous devez également déployer, intégrer et tester l’application dans son ensemble avec tous ses conteneurs au sein d’un hôte Docker d’intégration ou même dans un cluster de test qui sont vos conteneurs distribué.</span><span class="sxs-lookup"><span data-stu-id="85db6-170">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="85db6-171">Si vous utilisez un seul ordinateur hôte, vous pouvez utiliser les commandes Docker tels que docker-composer pour générer et déployer des conteneurs connexes pour tester et valider l’environnement de Docker dans une seule machine virtuelle.</span><span class="sxs-lookup"><span data-stu-id="85db6-171">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="85db6-172">Toutefois, si vous travaillez avec un cluster orchestrator comme contrôleur de domaine/système d’exploitation, Kubernetes ou Docker Swarm, vous devez déployer vos conteneurs via un mécanisme différent ou un orchestrator, en fonction de votre cluster/planificateur sélectionné.</span><span class="sxs-lookup"><span data-stu-id="85db6-172">But, if you are working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="85db6-173">Voici plusieurs types de tests que vous pouvez exécuter sur des conteneurs Docker :</span><span class="sxs-lookup"><span data-stu-id="85db6-173">Following are several types of tests that you can run against Docker containers:</span></span>

-   <span data-ttu-id="85db6-174">Tests unitaires pour les conteneurs Docker</span><span class="sxs-lookup"><span data-stu-id="85db6-174">Unit tests for Docker containers</span></span>

-   <span data-ttu-id="85db6-175">Test des groupes d’applications reliées entre elles ou microservices</span><span class="sxs-lookup"><span data-stu-id="85db6-175">Testing groups of interrelated applications or microservices</span></span>

-   <span data-ttu-id="85db6-176">Dans les versions de production et « contrôle de validité » de test</span><span class="sxs-lookup"><span data-stu-id="85db6-176">Test in production and "canary" releases</span></span>

<span data-ttu-id="85db6-177">Le point important est que lors de l’exécution d’intégration et les tests fonctionnels, vous devez exécuter ces tests à partir d’en dehors des conteneurs.</span><span class="sxs-lookup"><span data-stu-id="85db6-177">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="85db6-178">Tests ne doivent pas être définis et s’exécutent dans les conteneurs que vous déployez, étant donné que les conteneurs sont basées sur des images statiques doivent être exactement comme ceux que vous comptez déployer en production.</span><span class="sxs-lookup"><span data-stu-id="85db6-178">Tests must not be defined and run within the containers that you are deploying, because the containers are based on static images that should be exactly like those that you will be deploying into production.</span></span>

<span data-ttu-id="85db6-179">Une option très envisageable lorsque vous testez des scénarios plus avancés tels que le test (test de cluster, cluster intermédiaire et le cluster de production) de plusieurs clusters consiste à publier des images à un Registre à tester dans différents clusters.</span><span class="sxs-lookup"><span data-stu-id="85db6-179">A very feasible option when testing more advanced scenarios like testing several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry to test in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="85db6-180">Distribuer l’image de Docker application personnalisée dans votre Registre Docker global</span><span class="sxs-lookup"><span data-stu-id="85db6-180">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="85db6-181">Une fois les images Docker ont été testées et validées, que vous souhaitez marquer et de les publier dans votre Registre Docker.</span><span class="sxs-lookup"><span data-stu-id="85db6-181">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="85db6-182">Le Registre Docker est un élément critique dans le cycle de vie des applications de Docker, car il est l’emplacement central où vous stockez votre test personnalisé (également appelé « images privilégiés ») à être déployé dans les environnements d’assurance qualité et de production.</span><span class="sxs-lookup"><span data-stu-id="85db6-182">The Docker registry is a critical piece in the Docker application life cycle because it is the central place where you store your custom test (aka "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="85db6-183">Similaire à la façon dont le code d’application stocké dans votre référentiel de contrôle de code source (Git, etc.) est « votre source de vérité », le Registre Docker est votre « source de vérité » pour votre application binaire ou les bits pour le déploiement sur les environnements de production ou des questions et réponses.</span><span class="sxs-lookup"><span data-stu-id="85db6-183">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="85db6-184">En règle générale, vous pouvez souhaiter avoir vos référentiels privés pour vos images personnalisées dans un référentiel privé dans le Registre de conteneur Azure ou dans un registre locale comme le Registre de Docker approuvé ou dans un registre public-cloud avec un accès limité (par exemple Hub docker), bien que dans ce dernier cas, si votre code n’est pas open source, vous devez approuver la sécurité du fournisseur.</span><span class="sxs-lookup"><span data-stu-id="85db6-184">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="85db6-185">Dans les deux cas, la méthode par laquelle vous cela est assez similaire et enfin en fonction de la commande docker, comme illustré dans la Figure 5-4.</span><span class="sxs-lookup"><span data-stu-id="85db6-185">Either way, the method by which you do this is pretty similar and ultimately based on the docker push command, as depicted in Figure 5-4.</span></span>

![](./media/image4.png)

<span data-ttu-id="85db6-186">Figure 5-4 : publication d’images personnalisées dans le Registre de Docker</span><span class="sxs-lookup"><span data-stu-id="85db6-186">Figure 5-4: Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="85db6-187">Il existe plusieurs offres des registres de Docker à partir des fournisseurs de cloud comme Azure conteneur de Registre, Registre de conteneur Amazon Web Services, Registre de conteneur de Google, quai Registre et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="85db6-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="85db6-188">À l’aide de l’extension de Visual Studio Team Services Docker, vous pouvez transmettre un ensemble d’images de service défini par un fichier compose.yml de docker, avec plusieurs balises à un Registre Docker authentifié (par exemple, le Registre de conteneur Azure), comme indiqué dans la Figure 5-5.</span><span class="sxs-lookup"><span data-stu-id="85db6-188">Using the Visual Studio Team Services Docker extension, you can push a set of service images defined by a docker-compose.yml file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![](./media/image5.png)

<span data-ttu-id="85db6-189">Figure 5-5 : à l’aide de Visual Studio Team Services pour la publication des images personnalisées à un Registre Docker</span><span class="sxs-lookup"><span data-stu-id="85db6-189">Figure 5-5: Using Visual Studio Team Services to publishing custom images to a Docker Registry</span></span>

<span data-ttu-id="85db6-190">**Plus d’informations** pour en savoir plus sur l’extension Docker pour Visual Studio Team Services, accédez à <https://aka.ms/vstsdockerextension>.</span><span class="sxs-lookup"><span data-stu-id="85db6-190">**More info** To read more about the Docker extension for Visual Studio Team Services, go to <https://aka.ms/vstsdockerextension>.</span></span> <span data-ttu-id="85db6-191">Pour en savoir plus sur le Registre de conteneur Azure, accédez à <https://aka.ms/azurecontainerregistry>.</span><span class="sxs-lookup"><span data-stu-id="85db6-191">To learn more about Azure Container Registry, go to <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="85db6-192">Étape 4 : CD, déployer</span><span class="sxs-lookup"><span data-stu-id="85db6-192">Step 4: CD, Deploy</span></span>

<span data-ttu-id="85db6-193">Immuabilité des images Docker permet de garantir un déploiement reproductible avec ce qui a développé, testé via l’élément de configuration et exécuter en production.</span><span class="sxs-lookup"><span data-stu-id="85db6-193">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="85db6-194">Après avoir configuré les images de Docker application publiées dans votre Registre Docker (privée ou publique), vous pouvez les déployer pour les environnements plusieurs dont vous disposez (production, les questions et réponses, de mise en lots, etc.) à partir de votre pipeline de CD à l’aide de Visual Studio Team Services tâches du pipeline ou Visual Studio Team Services Release Management.</span><span class="sxs-lookup"><span data-stu-id="85db6-194">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Visual Studio Team Services pipeline tasks or Visual Studio Team Services Release Management.</span></span>

<span data-ttu-id="85db6-195">Toutefois, à ce stade il varie selon le type d’application de Docker que vous déployez.</span><span class="sxs-lookup"><span data-stu-id="85db6-195">However, at this point it depends on what kind of Docker application you are deploying.</span></span> <span data-ttu-id="85db6-196">Déploiement simple d’une application (à partir d’un point de vue composition et de déploiement) comme un monolithique application comprenant plusieurs conteneurs ou les services et déployé plusieurs serveurs ou ordinateurs virtuels est très différente de déploiement d’une application plus complexe, comme un applications avec les fonctionnalités démultipliée orientée vers microservices.</span><span class="sxs-lookup"><span data-stu-id="85db6-196">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is very different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="85db6-197">Ces deux scénarios sont expliqués dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="85db6-197">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="85db6-198">Déploiement composé applications Docker dans plusieurs environnements de Docker</span><span class="sxs-lookup"><span data-stu-id="85db6-198">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="85db6-199">Regardons premièrement le scénario moins complexes : déploiement vers les hôtes Docker simples (machines virtuelles ou serveurs) dans un environnement unique ou plusieurs environnements (questions et réponses, intermédiaire et production).</span><span class="sxs-lookup"><span data-stu-id="85db6-199">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="85db6-200">Dans ce scénario, en interne le pipeline de votre CD-ROM peut utiliser docker-composer (à partir de vos tâches de déploiement de Visual Studio Team Services) pour déployer les applications de Docker avec son ensemble des conteneurs ou des services, comme illustré dans la Figure 5-6.</span><span class="sxs-lookup"><span data-stu-id="85db6-200">In this scenario, internally your CD pipeline can use docker-compose (from your Visual Studio Team Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![](./media/image6.png)

<span data-ttu-id="85db6-201">Figure 5-6 : déploiement de conteneurs d’applications dans le Registre des environnements de hôte simple Docker</span><span class="sxs-lookup"><span data-stu-id="85db6-201">Figure 5-6: Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="85db6-202">Figure 5-7 met en évidence la façon dont vous pouvez vous connecter votre élément de configuration de build dans les environnements de test/AQ via Visual Studio Team Services en cliquant sur Docker Compose dans la boîte de dialogue Ajouter une tâche.</span><span class="sxs-lookup"><span data-stu-id="85db6-202">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Visual Studio Team Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="85db6-203">Cependant, lors du déploiement dans les environnements de production ou intermédiaire, vous utilisez généralement les fonctionnalités de gestion des versions gère plusieurs environnements (comme les questions et réponses, intermédiaire et production).</span><span class="sxs-lookup"><span data-stu-id="85db6-203">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="85db6-204">Si vous déployez vers les hôtes Docker uniques, il est à l’aide de Visual Studio Team Services « Docker Compose » la tâche (ce qui revient à appeler la docker-composer commande sous le capot).</span><span class="sxs-lookup"><span data-stu-id="85db6-204">If you're deploying to single Docker hosts, it is using the Visual Studio Team Services "Docker Compose" task (which is invoking the docker-compose up command under the hood).</span></span> <span data-ttu-id="85db6-205">Si vous déployez dans le Service de conteneur Azure, il utilise la tâche de déploiement de Docker, comme expliqué dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="85db6-205">If you're deploying to Azure Container Service, it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![](./media/image7.png)

<span data-ttu-id="85db6-206">Figure 5-7 : ajout d’une tâche Docker Compose dans un pipeline de Visual Studio Team Services</span><span class="sxs-lookup"><span data-stu-id="85db6-206">Figure 5-7: Adding a Docker Compose task in a Visual Studio Team Services pipeline</span></span>

<span data-ttu-id="85db6-207">Lorsque vous créez une version de Visual Studio Team Services, il prend un ensemble d’artefacts d’entrée.</span><span class="sxs-lookup"><span data-stu-id="85db6-207">When you create a release in Visual Studio Team Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="85db6-208">Elles sont destinées à être immuable pendant toute la durée de vie de la version dans différents environnements.</span><span class="sxs-lookup"><span data-stu-id="85db6-208">These are intended to be immutable throughout the lifetime of the release across multiple environments.</span></span> <span data-ttu-id="85db6-209">Lorsque vous introduisez des conteneurs, les artefacts d’entrée identifient des images dans un Registre à déployer.</span><span class="sxs-lookup"><span data-stu-id="85db6-209">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="85db6-210">Selon la façon dont ils ont été identifiés, ils ne sont pas garanties reste la même pendant toute la durée de la version, le cas le plus évident en cours lorsque vous faites référence à « myimage:latest » à partir d’un fichier docker-compose.</span><span class="sxs-lookup"><span data-stu-id="85db6-210">Depending on how these are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference "myimage:latest" from a docker-compose file.</span></span>

<span data-ttu-id="85db6-211">L’extension Docker pour Visual Studio Team Services vous donne la possibilité de générer des artefacts de build qui contient l’image de Registre spécifiques des résumés garantis pour identifier de façon unique la même image binaire.</span><span class="sxs-lookup"><span data-stu-id="85db6-211">The Docker extension for Visual Studio Team Services gives you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="85db6-212">Voici ce que vous souhaitez utiliser comme entrée pour une mise en production.</span><span class="sxs-lookup"><span data-stu-id="85db6-212">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-visual-studio-team-services-release-management"></a><span data-ttu-id="85db6-213">La gestion des versions dans les environnements de Docker à l’aide de Visual Studio Team Services Release Management</span><span class="sxs-lookup"><span data-stu-id="85db6-213">Managing releases to Docker environments by using Visual Studio Team Services Release Management</span></span>

<span data-ttu-id="85db6-214">Via les extensions Visual Studio Team Services, vous pouvez générer une nouvelle image, publier sur un Registre Docker, exécutez-le sur les ordinateurs hôtes Windows ou Linux et utiliser des commandes telles que docker-composer pour déployer plusieurs conteneurs en tant qu’une application entière, à l’aide de l’élément visuel Fonctionnalités de gestion de version Team Services Studio destinées à plusieurs environnements, comme indiqué dans la Figure 5-8.</span><span class="sxs-lookup"><span data-stu-id="85db6-214">Through the Visual Studio Team Services extensions, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as docker-compose to deploy multiple containers as an entire application, all through the Visual Studio Team Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![](./media/image8.png)

<span data-ttu-id="85db6-215">Figure 5 à 8 : configuration de Visual Studio Team Services Docker Compose de tâches à partir de Visual Studio Team Services Release Management</span><span class="sxs-lookup"><span data-stu-id="85db6-215">Figure 5-8: Configuring Visual Studio Team Services Docker Compose tasks from Visual Studio Team Services Release Management</span></span>

<span data-ttu-id="85db6-216">Toutefois, gardez à l’esprit que le scénario illustré dans la Figure 5-6 et implémentée dans la Figure 5-8 est assez basique (qu’il déploie vers les hôtes Docker simples et machines virtuelles, et il y aura un conteneur unique ou une instance par image) et probablement doit être utilisé uniquement pour le développement ou test sc Gestionnaire de scénarios.</span><span class="sxs-lookup"><span data-stu-id="85db6-216">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is pretty basic (it is deploying to simple Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="85db6-217">Dans la plupart des scénarios de production d’entreprise, vous pourriez avoir haute disponibilité (HA) et à gérer l’évolutivité en équilibrant la charge entre plusieurs nœuds, serveurs et les machines virtuelles, ainsi que « basculements intelligents » ainsi que si un serveur ou un nœud tombe en panne, ses services et conteneurs seront déplacés vers un autre serveur hôte ou une machine virtuelle.</span><span class="sxs-lookup"><span data-stu-id="85db6-217">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so that if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="85db6-218">Dans ce cas, vous avez besoin des technologies plus avancées telles que les clusters de conteneur, orchestrators et des planificateurs.</span><span class="sxs-lookup"><span data-stu-id="85db6-218">In that case, you need more advanced technologies like container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="85db6-219">Par conséquent, la méthode de déploiement pour les clusters est précisément via des scénarios avancés expliquées dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="85db6-219">Thus, the way to deploy to those clusters is precisely through the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-complex-docker-applications-to-docker-clusters-dcos-kubernetes-and-docker-swarm"></a><span data-ttu-id="85db6-220">Déploiement d’applications Docker complexes à des clusters Docker (contrôleur de domaine/système d’exploitation, Kubernetes et Docker Swarm)</span><span class="sxs-lookup"><span data-stu-id="85db6-220">Deploying complex Docker applications to Docker clusters (DC/OS, Kubernetes, and Docker Swarm)</span></span>

<span data-ttu-id="85db6-221">La nature des applications distribuées nécessite des ressources de calcul qui sont également distribuées.</span><span class="sxs-lookup"><span data-stu-id="85db6-221">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="85db6-222">Pour que les capacités de production à l’échelle, vous devez disposer de fonctionnalités qui fournissent une haute évolutivité de clustering et haute disponibilité en fonction des ressources regroupées.</span><span class="sxs-lookup"><span data-stu-id="85db6-222">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and HA based on pooled resources.</span></span>

<span data-ttu-id="85db6-223">Vous pouvez déployer des conteneurs manuellement dans ces clusters à partir d’un outil CLI tels que Docker Swarm (comme à l’aide de [de création du service de docker](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) ou une interface utilisateur web tels que [mésosphère Marathon](https://mesosphere.github.io/marathon/docs/marathon-ui.html) pour le contrôleur de domaine/système d’exploitation clusters, mais vous devez réserver qui uniquement pour tester le déploiement de veille ou à des fins de gestion telles que l’évolution horizontale ou à des fins d’analyse.</span><span class="sxs-lookup"><span data-stu-id="85db6-223">You could deploy containers manually to those clusters from a CLI tool such as Docker Swarm (like using [docker service create](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) or a web UI such as [Mesosphere Marathon](https://mesosphere.github.io/marathon/docs/marathon-ui.html) for DC/OS clusters, but you should reserve that only for punctual deployment testing or for management purposes like scaling-out or monitoring purposes.</span></span>

<span data-ttu-id="85db6-224">À partir d’un point de vue de CD et Visual Studio Team Services en particulier, vous pouvez exécuter les tâches de déploiement spécialement faite vos environnements de Visual Studio Team Services Release Management, qui vous allez déployer vos applications en conteneur pour les clusters répartis dans Service de conteneur, comme illustré dans la Figure 5-9.</span><span class="sxs-lookup"><span data-stu-id="85db6-224">From a CD point of view, and Visual Studio Team Services specifically, you can run specially made deployment tasks from your Visual Studio Team Services Release Management environments which will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![](./media/image9.png)

<span data-ttu-id="85db6-225">Figure 5-9 : déploiement d’applications distribuées au Service de conteneur</span><span class="sxs-lookup"><span data-stu-id="85db6-225">Figure 5-9: Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="85db6-226">Au départ, lors du déploiement de clusters ou orchestrators, vous traditionnellement utiliseriez mécanismes par chaque orchestrator (autrement dit, mésosphère contrôleur de domaine/système d’exploitation ou Kubernetes ont des mécanismes de déploiement différents à Docker et Docker et les scripts de déploiement spécifique Swarm) au lieu de la plus simple et facile à utiliser docker-composent des outil basé sur le fichier de définition de compose.yml de docker.</span><span class="sxs-lookup"><span data-stu-id="85db6-226">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Mesosphere DC/OS or Kubernetes have different deployment mechanisms than Docker and Docker Swarm) instead of the simpler and easy-to-use docker-compose tool based on the docker-compose.yml definition file.</span></span> <span data-ttu-id="85db6-227">Toutefois, grâce à la tâche de Microsoft Visual Studio Team Services Docker Deploy montre la Figure 5-10, vous pouvez à présent également déployer au contrôleur de domaine/système d’exploitation en utilisant simplement votre fichier docker-compose.yml familière, car Microsoft effectue cette traduction « » pour vous (à partir de votre fichier compose.yml de docker dans d’autres formats requis par le contrôleur de domaine/OS).</span><span class="sxs-lookup"><span data-stu-id="85db6-227">However, thanks to the Microsoft Visual Studio Team Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to DC/OS by just using your familiar docker-compose.yml file because Microsoft performs that "translation" for you (from your docker-compose.yml file to other formats needed by DC/OS).</span></span>

![](./media/image10.png)

<span data-ttu-id="85db6-228">Figure 5-10 : ajout de la tâche de déploiement de Docker à RM de votre environnement</span><span class="sxs-lookup"><span data-stu-id="85db6-228">Figure 5-10: Adding the Docker Deploy task to your Environment RM</span></span>

<span data-ttu-id="85db6-229">Figure 5-11 montre comment vous pouvez modifier la tâche de déploiement de Docker et spécifier le Type de cible (conteneur Service de contrôleur de domaine/système d’exploitation Azure, dans ce cas), votre fichier de composer Docker et la connexion Docker Registre (par exemple, le Registre de conteneur Azure ou le Hub d’ancrage).</span><span class="sxs-lookup"><span data-stu-id="85db6-229">Figure 5-11 demonstrates how you can edit the Docker Deploy task and specify the Target Type (Azure Container Service DC/OS, in this case), your Docker Compose File, and the Docker Registry connection (like Azure Container Registry or Docker Hub).</span></span> <span data-ttu-id="85db6-230">Il s’agit de la tâche récupère où vos images Docker personnalisées de prêt à l’emploi pour être déployé en tant que conteneurs dans le cluster de contrôleur de domaine/système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="85db6-230">This is where the task will retrieve your ready-to-use custom Docker images to be deployed as containers in the DC/OS cluster.</span></span>

![](./media/image11.png)

<span data-ttu-id="85db6-231">Déploiement de la figure 5-11 : déployer de Docker tâche définition pour le Service de conteneur Azure DC/OS</span><span class="sxs-lookup"><span data-stu-id="85db6-231">Figure 5-11: Docker Deploy task definition deploying to Azure Container Service DC/OS</span></span>

<span data-ttu-id="85db6-232">**Plus d’informations** pour en savoir plus sur le pipeline de CD avec Visual Studio Team Services et Docker, visitez les sites suivants :</span><span class="sxs-lookup"><span data-stu-id="85db6-232">**More info** To read more about the CD pipeline with Visual Studio Team Services and Docker, visit the following sites:</span></span>

<span data-ttu-id="85db6-233">Extension Studio Team Services Visual pour Docker et le Service de conteneur Azure : [https://aka.ms/ \ vstsdockerextension](https://aka.ms/vstsdockerextension)</span><span class="sxs-lookup"><span data-stu-id="85db6-233">Visual Studio Team Services extension for Docker and Azure Container Service: [https://aka.ms/\ vstsdockerextension](https://aka.ms/vstsdockerextension)</span></span>

<span data-ttu-id="85db6-234">Service de conteneur Azure : <https://aka.ms/azurecontainerservice></span><span class="sxs-lookup"><span data-stu-id="85db6-234">Azure Container Service: <https://aka.ms/azurecontainerservice></span></span>

<span data-ttu-id="85db6-235">Contrôleur de domaine mésosphère/OS : <https://mesosphere.com/product/></span><span class="sxs-lookup"><span data-stu-id="85db6-235">Mesosphere DC/OS: <https://mesosphere.com/product/></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="85db6-236">Étape 5 : Exécuter et gérer</span><span class="sxs-lookup"><span data-stu-id="85db6-236">Step 5: Run and manage</span></span>

<span data-ttu-id="85db6-237">En cours d’exécution et la gestion des applications en production de l’entreprise au niveau du est un sujet principal dans de lui-même et en raison du type d’opérations et les personnes travaillant à ce niveau (informatiques), ainsi que l’étendue de grande taille de cette zone, nous avons consacré l’ensemble suivant chapitre expliquant il.</span><span class="sxs-lookup"><span data-stu-id="85db6-237">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, we have devoted the entire next chapter to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="85db6-238">Étape 6 : Analyser et de diagnostic</span><span class="sxs-lookup"><span data-stu-id="85db6-238">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="85db6-239">Cette rubrique également est décrite dans le chapitre suivant dans le cadre des tâches qui effectue des opérations informatiques dans les systèmes de production ; Toutefois, il est important de souligner que les informations obtenues lors de cette étape doivent flux à l’équipe de développement afin que l’application est améliorée en permanence.</span><span class="sxs-lookup"><span data-stu-id="85db6-239">This topic also is covered in the next chapter as part of the tasks that IT operations performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="85db6-240">À partir de ce point de vue, il fait également partie de DevOps, bien que les tâches et les opérations sont généralement effectuées par informatique.</span><span class="sxs-lookup"><span data-stu-id="85db6-240">From that point of view, it is also part of DevOps, although the tasks and operations are usually performed by IT.</span></span>

<span data-ttu-id="85db6-241">Uniquement lors de la surveillance et diagnostic est à 100 % dans le domaine du DevOps sont analytique effectuée par l’équipe de développement par rapport aux environnements de test ou de la version bêta et processus d’analyse.</span><span class="sxs-lookup"><span data-stu-id="85db6-241">Only when monitoring and diagnostics are 100 percent within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="85db6-242">Pour cela, effectuez le test de charge ou simplement en version bêta ou les environnements de questions et réponses, où les testeurs bêta essayez les nouvelles versions d’analyse.</span><span class="sxs-lookup"><span data-stu-id="85db6-242">This is done either by performing load testing or simply by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="85db6-243">[Précédente] (index.md) [suivant] (.. /Run-Manage-Monitor-docker-Environments/index.MD)</span><span class="sxs-lookup"><span data-stu-id="85db6-243">[Previous] (index.md) [Next] (../run-manage-monitor-docker-environments/index.md)</span></span>
