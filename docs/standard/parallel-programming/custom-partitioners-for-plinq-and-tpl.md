---
title: "Partitionneurs personnalisés pour PLINQ et la bibliothèque parallèle de tâches (TPL)"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
caps.latest.revision: "19"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 12d234b86b0067178d54d2fdcb5d37ceaee6109d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/21/2017
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="ee0a2-102">Partitionneurs personnalisés pour PLINQ et la bibliothèque parallèle de tâches (TPL)</span><span class="sxs-lookup"><span data-stu-id="ee0a2-102">Custom Partitioners for PLINQ and TPL</span></span>
<span data-ttu-id="ee0a2-103">Pour paralléliser une opération sur une source de données, l’une des étapes essentielles consiste à *partition* la source en plusieurs sections qui peuvent être accessibles simultanément par plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="ee0a2-104">PLINQ et la bibliothèque parallèle de tâches (TPL) fournissent des partitionneurs par défaut qui fonctionnent de façon transparente lorsque vous écrivez une requête parallèle ou <xref:System.Threading.Tasks.Parallel.ForEach%2A> boucle.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="ee0a2-105">Pour des scénarios plus avancés, vous pouvez incorporer dans votre propre partitionneur.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>  
  
## <a name="kinds-of-partitioning"></a><span data-ttu-id="ee0a2-106">Genres de partitionnement</span><span class="sxs-lookup"><span data-stu-id="ee0a2-106">Kinds of Partitioning</span></span>  
 <span data-ttu-id="ee0a2-107">Il existe de nombreuses façons d’une source de données de partition.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="ee0a2-108">Dans les approches les plus efficaces, plusieurs threads coopèrent pour le processus de la séquence source d’origine, plutôt que de séparer physiquement la source en plusieurs sous-séquences.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="ee0a2-109">Pour des tableaux et d’autres sources indexées telles que <xref:System.Collections.IList> collections où la longueur est connue à l’avance, *partitionnement par plage* est le type le plus simple de partitionnement.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="ee0a2-110">Chaque thread reçoit unique de début et de fin des index, afin qu’il puisse traiter sa plage de la source sans remplacer ou être remplacé par un autre thread.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="ee0a2-111">La seule surcharge impliquées dans le partitionnement par plage est le travail initial de création de plages ; Aucune synchronisation supplémentaire n’est requise par la suite.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="ee0a2-112">Par conséquent, elle peut fournir de bonnes performances tant que la charge de travail est réparti de manière égale.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="ee0a2-113">L’inconvénient de partitionnement par plage est que si un thread se termine plus tôt, il ne peut pas aider les autres threads terminer son travail.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>  
  
 <span data-ttu-id="ee0a2-114">Pour des listes liées ou d’autres collections dont la longueur n’est pas connue, vous pouvez utiliser *le partitionnement*.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="ee0a2-115">Dans le partitionnement, chaque thread ou une tâche dans une boucle parallèle ou une requête consomme un certain nombre d’éléments de la source dans un segment, les traite, puis revient pour extraire des éléments supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="ee0a2-116">Le partitionneur garantit que tous les éléments sont distribués et qu’il n’y a pas de doublons.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="ee0a2-117">Un segment peut être n’importe quelle taille.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-117">A chunk may be any size.</span></span> <span data-ttu-id="ee0a2-118">Par exemple, le partitionneur qui est illustré dans [Comment : implémenter des Partitions dynamiques](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) crée des segments qui contiennent uniquement un élément.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="ee0a2-119">Tant que les segments ne sont pas trop volumineux, ce type de partitionnement est, par nature, l’équilibrage de charge, car l’assignation d’éléments aux threads n’est pas prédéfinie.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="ee0a2-120">Toutefois, le partitionneur subit la surcharge de synchronisation chaque fois que le thread a besoin d’un autre segment.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="ee0a2-121">La quantité de synchronisation effectuée dans ces cas est inversement proportionnelle à la taille des blocs.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>  
  
 <span data-ttu-id="ee0a2-122">En règle générale, partitionnement par plage n’est plus rapide lorsque la durée d’exécution du délégué est faible à modérée et la source a un grand nombre d’éléments, et le total du travail de chaque partition est à peu près équivalent.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="ee0a2-123">Le partitionnement est donc généralement plus rapide dans la plupart des cas.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="ee0a2-124">Sur les sources avec un petit nombre d’éléments ou les durées d’exécution pour le délégué, puis les performances de segment et le partitionnement par plage sont équivalente.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>  
  
 <span data-ttu-id="ee0a2-125">Les partitionneurs prêts à la bibliothèque parallèle de tâches prennent également en charge un nombre dynamique de partitions.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="ee0a2-126">Cela signifie qu’ils peuvent créer des partitions à la volée, par exemple, lorsque le <xref:System.Threading.Tasks.Parallel.ForEach%2A> boucle engendre une nouvelle tâche.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="ee0a2-127">Cette fonctionnalité permet au partitionneur à l’échelle de la boucle elle-même.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="ee0a2-128">Les partitionneurs dynamiques sont également, par nature, l’équilibrage de charge.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="ee0a2-129">Lorsque vous créez un partitionneur personnalisé, vous devez prendre en charge le partitionnement dynamique pour être utilisable à partir d’un <xref:System.Threading.Tasks.Parallel.ForEach%2A> boucle.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>  
  
### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="ee0a2-130">Configuration de partitionneurs pour PLINQ d’équilibrage de charge</span><span class="sxs-lookup"><span data-stu-id="ee0a2-130">Configuring Load Balancing Partitioners for PLINQ</span></span>  
 <span data-ttu-id="ee0a2-131">Certaines surcharges de la <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> méthode vous permettre de créer un partitionneur pour un tableau ou <xref:System.Collections.IList> source et de spécifier s’il doit essayer d’équilibrer la charge de travail entre les threads.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="ee0a2-132">Lorsque le partitionneur est configuré pour l’équilibrage de charge, le partitionnement est utilisé, et les éléments sont remis à chaque partition en petits segments lorsqu’ils sont demandés.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="ee0a2-133">Cette approche garantit que toutes les partitions ont des éléments à traiter jusqu'à ce que la boucle ou que la requête est terminée.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="ee0a2-134">Une surcharge supplémentaire peut être utilisée pour fournir le partitionnement d’équilibrage de charge de n’importe quel <xref:System.Collections.IEnumerable> source.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>  
  
 <span data-ttu-id="ee0a2-135">En général, l’équilibrage de charge requiert que les partitions pour demander des éléments relativement souvent à partir du partitionneur.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="ee0a2-136">En revanche, un partitionneur qui effectue le partitionnement statique peut affecter les éléments à chaque partitionneur tous en même temps à l’aide de la plage ou le partitionnement.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="ee0a2-137">Cela nécessite moins de surcharge que l’équilibrage de charge, mais elle peut prendre plus de temps à s’exécuter si un thread finit avec considérablement plus de travail que les autres.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="ee0a2-138">Par défaut lorsqu’il est passé un IList ou un tableau, PLINQ utilise toujours partitionnement par plage sans équilibrage de charge.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="ee0a2-139">Pour activer l’équilibrage de charge pour PLINQ, utilisez la `Partitioner.Create` méthode, comme indiqué dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
 [!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]  
  
 <span data-ttu-id="ee0a2-140">La meilleure méthode pour déterminer si utiliser charge équilibrage de charge dans un scénario donné est à faire des essais et mesurer la durée d’opérations se terminent sous une charge représentative et les configurations d’ordinateur.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="ee0a2-141">Par exemple, le partitionnement statique peut fournir une accélération significative sur un ordinateur multicœur qui a uniquement quelques cœurs, mais cela peut entraîner des ralentissements sur les ordinateurs qui disposent de nombreux cœurs.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>  
  
 <span data-ttu-id="ee0a2-142">Le tableau suivant répertorie les surcharges disponibles de la <xref:System.Collections.Concurrent.Partitioner.Create%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ee0a2-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="ee0a2-143">Utilisation de ces partitionneurs n’êtes pas limitée à utiliser uniquement avec PLINQ ou <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="ee0a2-144">Ils peuvent également être utilisés avec toute construction parallèle personnalisée.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-144">They can also be used with any custom parallel construct.</span></span>  
  
|<span data-ttu-id="ee0a2-145">Surcharge</span><span class="sxs-lookup"><span data-stu-id="ee0a2-145">Overload</span></span>|<span data-ttu-id="ee0a2-146">Utilise l’équilibrage de charge</span><span class="sxs-lookup"><span data-stu-id="ee0a2-146">Uses load balancing</span></span>|  
|--------------|-------------------------|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="ee0a2-147">Toujours</span><span class="sxs-lookup"><span data-stu-id="ee0a2-147">Always</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="ee0a2-148">Lorsque l’argument Boolean est spécifié comme true</span><span class="sxs-lookup"><span data-stu-id="ee0a2-148">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="ee0a2-149">Lorsque l’argument Boolean est spécifié comme true</span><span class="sxs-lookup"><span data-stu-id="ee0a2-149">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="ee0a2-150">Never</span><span class="sxs-lookup"><span data-stu-id="ee0a2-150">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="ee0a2-151">Never</span><span class="sxs-lookup"><span data-stu-id="ee0a2-151">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="ee0a2-152">Never</span><span class="sxs-lookup"><span data-stu-id="ee0a2-152">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="ee0a2-153">Never</span><span class="sxs-lookup"><span data-stu-id="ee0a2-153">Never</span></span>|  
  
### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="ee0a2-154">Configuration de partitionneurs de plages statiques pour Parallel.ForEach</span><span class="sxs-lookup"><span data-stu-id="ee0a2-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>  
 <span data-ttu-id="ee0a2-155">Dans un <xref:System.Threading.Tasks.Parallel.For%2A> boucle, le corps de la boucle est fourni à la méthode en tant que délégué.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="ee0a2-156">Le coût de l’appel de ce délégué est plus qu’un appel de méthode virtuelle.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="ee0a2-157">Dans certains scénarios, le corps d’une boucle parallèle peut être suffisamment petit pour que le coût de l’appel du délégué sur chaque itération de boucle devient important.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="ee0a2-158">Dans ce cas, vous pouvez utiliser une de le <xref:System.Collections.Concurrent.Partitioner.Create%2A> surcharges pour créer un <xref:System.Collections.Generic.IEnumerable%601> des partitions par plage sur les éléments source.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="ee0a2-159">Ensuite, vous pouvez passer cette collection de plages à un <xref:System.Threading.Tasks.Parallel.ForEach%2A> méthode dont le corps se compose d’une expression régulière `for` boucle.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="ee0a2-160">L’avantage de cette approche est que le coût d’appel de délégué implique qu’une seule fois par plage, plutôt qu’une seule fois par élément.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="ee0a2-161">L’exemple suivant illustre le modèle de base.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-161">The following example demonstrates the basic pattern.</span></span>  
  
 [!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
 [!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]  
  
 <span data-ttu-id="ee0a2-162">Chaque thread dans la boucle reçoit son propre <xref:System.Tuple%602> qui contient le début et fin des valeurs d’index dans la plage spécifiée.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="ee0a2-163">Interne `for` boucle utilise le `fromInclusive` et `toExclusive` pour parcourir le tableau de valeurs ou <xref:System.Collections.IList> directement.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>  
  
 <span data-ttu-id="ee0a2-164">Parmi les <xref:System.Collections.Concurrent.Partitioner.Create%2A> surcharges vous permet de spécifier la taille des partitions et le nombre de partitions.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="ee0a2-165">Cette surcharge peut être utilisée dans les scénarios où le travail par élément est donc faible qu’appel d’une méthode virtuelle par élément a un impact perceptible sur les performances.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>  
  
## <a name="custom-partitioners"></a><span data-ttu-id="ee0a2-166">Partitionneurs personnalisés</span><span class="sxs-lookup"><span data-stu-id="ee0a2-166">Custom Partitioners</span></span>  
 <span data-ttu-id="ee0a2-167">Dans certains scénarios, il peut être utile ou même requise pour implémenter votre propre partitionneur.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="ee0a2-168">Par exemple, vous pouvez avoir une classe de collection personnalisée que vous pouvez partitionner plus efficacement que la valeur par défaut partitionneurs, selon votre connaissance de la structure interne de la classe.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="ee0a2-169">Ou bien, vous voudrez créer des partitions de plage de tailles différentes en fonction de votre connaissance de leur durée d’éléments de processus à différents emplacements dans la collection source.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>  
  
 <span data-ttu-id="ee0a2-170">Pour créer un partitionneur personnalisé de base, dérivez une classe de <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> et substituez les méthodes virtuelles, comme décrit dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="ee0a2-171">Cette méthode est appelée une fois par le thread principal et retourne un IList(IEnumerator(TSource)).</span><span class="sxs-lookup"><span data-stu-id="ee0a2-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="ee0a2-172">Chaque thread de travail dans la boucle ou requête peut appeler `GetEnumerator` sur la liste pour récupérer un <xref:System.Collections.Generic.IEnumerator%601> sur une partition distincte.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="ee0a2-173">Retourner `true` si vous implémentez <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, dans le cas contraire, `false`.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="ee0a2-174">Si <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> est `true`, cette méthode peut éventuellement être appelée à la place de <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="ee0a2-175">Si les résultats doivent être pouvant être triées ou vous avez besoin d’accès indexé dans les éléments, puis dérivent <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> et substituer ses méthodes virtuelles comme décrit dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="ee0a2-176">Cette méthode est appelée une fois par le thread principal et retourne un `IList(IEnumerator(TSource))`.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="ee0a2-177">Chaque thread de travail dans la boucle ou requête peut appeler `GetEnumerator` sur la liste pour récupérer un <xref:System.Collections.Generic.IEnumerator%601> sur une partition distincte.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="ee0a2-178">Retourner `true` si vous implémentez <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; sinon, false.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="ee0a2-179">En règle générale, cela entraîne l’appel <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="ee0a2-180">Si <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> est `true`, cette méthode peut éventuellement être appelée à la place de <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="ee0a2-181">Le tableau suivant fournit des détails supplémentaires sur la façon des trois genres d’équilibrage de charge de mettre en œuvre les partitionneurs prêts à la <xref:System.Collections.Concurrent.OrderablePartitioner%601> classe.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>  
  
|<span data-ttu-id="ee0a2-182">Méthode/propriété</span><span class="sxs-lookup"><span data-stu-id="ee0a2-182">Method/Property</span></span>|<span data-ttu-id="ee0a2-183">IList / tableau sans équilibrage de charge</span><span class="sxs-lookup"><span data-stu-id="ee0a2-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="ee0a2-184">IList / tableau avec équilibrage de charge</span><span class="sxs-lookup"><span data-stu-id="ee0a2-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="ee0a2-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="ee0a2-185">IEnumerable</span></span>|  
|----------------------|-------------------------------------------|----------------------------------------|-----------------|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="ee0a2-186">Utilise le partitionnement par plage</span><span class="sxs-lookup"><span data-stu-id="ee0a2-186">Uses range partitioning</span></span>|<span data-ttu-id="ee0a2-187">Utilise le partitionnement est optimisé pour les listes pour le partitionCount spécifié</span><span class="sxs-lookup"><span data-stu-id="ee0a2-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="ee0a2-188">Utilise le partitionnement en créant un nombre statique de partitions.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="ee0a2-189">Lève une exception non prise en charge (exception)</span><span class="sxs-lookup"><span data-stu-id="ee0a2-189">Throws not-supported exception</span></span>|<span data-ttu-id="ee0a2-190">Utilise le partitionnement est optimisé pour les listes et les partitions dynamiques</span><span class="sxs-lookup"><span data-stu-id="ee0a2-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="ee0a2-191">Utilise le partitionnement en créant un nombre dynamique de partitions.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="ee0a2-192">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-192">Returns `true`</span></span>|<span data-ttu-id="ee0a2-193">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-193">Returns `true`</span></span>|<span data-ttu-id="ee0a2-194">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-194">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="ee0a2-195">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-195">Returns `true`</span></span>|<span data-ttu-id="ee0a2-196">Retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-196">Returns `false`</span></span>|<span data-ttu-id="ee0a2-197">Retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-197">Returns `false`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="ee0a2-198">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-198">Returns `true`</span></span>|<span data-ttu-id="ee0a2-199">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-199">Returns `true`</span></span>|<span data-ttu-id="ee0a2-200">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-200">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="ee0a2-201">Retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-201">Returns `false`</span></span>|<span data-ttu-id="ee0a2-202">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-202">Returns `true`</span></span>|<span data-ttu-id="ee0a2-203">Retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-203">Returns `true`</span></span>|  
  
### <a name="dynamic-partitions"></a><span data-ttu-id="ee0a2-204">Partitions dynamiques</span><span class="sxs-lookup"><span data-stu-id="ee0a2-204">Dynamic Partitions</span></span>  
 <span data-ttu-id="ee0a2-205">Si vous envisagez du partitionneur à utiliser dans un <xref:System.Threading.Tasks.Parallel.ForEach%2A> (méthode), vous devez être en mesure de retourner un nombre dynamique de partitions.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="ee0a2-206">Cela signifie que le partitionneur peut fournir un énumérateur pour une nouvelle partition à la demande à tout moment pendant l’exécution de la boucle.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="ee0a2-207">En fait, chaque fois que la boucle ajoute une nouvelle tâche parallèle, elle demande une nouvelle partition pour cette tâche.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="ee0a2-208">Si vous avez besoin des données à être commandé, puis dérivent <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> afin qu’un index unique est assigné à chaque élément de chaque partition.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>  
  
 <span data-ttu-id="ee0a2-209">Pour plus d’informations et un exemple, consultez [Comment : implémenter des Partitions dynamiques](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ee0a2-209">For more information, and an example, see [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
### <a name="contract-for-partitioners"></a><span data-ttu-id="ee0a2-210">Contrat pour les partitionneurs</span><span class="sxs-lookup"><span data-stu-id="ee0a2-210">Contract for Partitioners</span></span>  
 <span data-ttu-id="ee0a2-211">Lorsque vous implémentez un partitionneur personnalisé, suivez ces instructions pour garantir l’interaction correcte avec PLINQ et <xref:System.Threading.Tasks.Parallel.ForEach%2A> dans la bibliothèque parallèle de tâches :</span><span class="sxs-lookup"><span data-stu-id="ee0a2-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>  
  
-   <span data-ttu-id="ee0a2-212">Si <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> est appelé avec un argument de zéro ou moins pour `partitionsCount`, lever <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="ee0a2-213">Bien que PLINQ et la bibliothèque parallèle de tâches ne passent jamais dans un `partitionCount` égal à 0, nous vous recommandons néanmoins de vous prémunir contre les risques.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>  
  
-   <span data-ttu-id="ee0a2-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>et <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> doit toujours renvoyer `partitionsCount` nombre de partitions.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="ee0a2-215">Si le partitionneur manque de données et ne peut pas créer autant de partitions comme demandé, la méthode doit retourner un énumérateur vide pour chacune des partitions restantes.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="ee0a2-216">Sinon, PLINQ et la bibliothèque parallèle de tâches lèvent une <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="ee0a2-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, et <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> ne doit jamais retourner `null` (`Nothing` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ee0a2-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="ee0a2-218">Dans le cas, PLINQ / TPL lèveront une <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="ee0a2-219">Les méthodes qui retournent des partitions doivent toujours renvoyer des partitions qui peuvent entièrement et de façon unique énumérer la source de données.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="ee0a2-220">Il ne doit y avoir aucune duplication dans la source de données ou les éléments ignorés, sauf si spécifiquement requis par la conception du partitionneur.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="ee0a2-221">Si cette règle n’est pas suivie, l’ordre de sortie peut être brouillé.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-221">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="ee0a2-222">Les accesseurs booléens suivants doivent toujours retourner correctement les valeurs suivantes afin que l’ordre de sortie ne soit pas brouillé :</span><span class="sxs-lookup"><span data-stu-id="ee0a2-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>  
  
    -   <span data-ttu-id="ee0a2-223">`KeysOrderedInEachPartition`: Chaque partition retourne des éléments en augmentant les index clés.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>  
  
    -   <span data-ttu-id="ee0a2-224">`KeysOrderedAcrossPartitions`: Pour toutes les partitions qui sont retournées, les index de clé dans la partition *i* sont plus élevées que les index de clé de partition *i*-1.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>  
  
    -   <span data-ttu-id="ee0a2-225">`KeysNormalized`: Tous les index de clé sont monotone, sans espaces vides, à partir de zéro.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>  
  
-   <span data-ttu-id="ee0a2-226">Tous les index doivent être uniques.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-226">All indices must be unique.</span></span> <span data-ttu-id="ee0a2-227">Il peut être pas d’index en double.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-227">There may not be duplicate indices.</span></span> <span data-ttu-id="ee0a2-228">Si cette règle n’est pas suivie, l’ordre de sortie peut être brouillé.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-228">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="ee0a2-229">Tous les index doivent être non négatifs.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-229">All indices must be nonnegative.</span></span> <span data-ttu-id="ee0a2-230">Si cette règle n’est pas suivie, PLINQ/TPL peut lever des exceptions.</span><span class="sxs-lookup"><span data-stu-id="ee0a2-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ee0a2-231">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="ee0a2-231">See Also</span></span>  
 [<span data-ttu-id="ee0a2-232">Programmation parallèle</span><span class="sxs-lookup"><span data-stu-id="ee0a2-232">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)  
 [<span data-ttu-id="ee0a2-233">Guide pratique pour implémenter des partitions dynamiques</span><span class="sxs-lookup"><span data-stu-id="ee0a2-233">How to: Implement Dynamic Partitions</span></span>](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)  
 [<span data-ttu-id="ee0a2-234">Guide pratique pour implémenter un partitionneur pour un partitionnement statique</span><span class="sxs-lookup"><span data-stu-id="ee0a2-234">How to: Implement a Partitioner for Static Partitioning</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)
