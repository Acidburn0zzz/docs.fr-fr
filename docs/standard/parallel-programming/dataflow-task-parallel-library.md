---
title: "Flux de donn&#233;es (biblioth&#232;que parall&#232;le de t&#226;ches) | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-standard"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "Bibliothèque parallèle de tâches, flux de données"
  - "bibliothèque de flux de données TPL"
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
caps.latest.revision: 22
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 22
---
# Flux de donn&#233;es (biblioth&#232;que parall&#232;le de t&#226;ches)
<a name="top"></a>La bibliothèque parallèle de tâches (TPL) fournit des composants de flux de données pour améliorer la robustesse des applications d’accès concurrentiel. Ces composants de flux de données sont collectivement appelés le *bibliothèque de flux de données TPL*. Ce modèle de flux de données favorise la programmation basée sur les acteurs en fournissant une transmission de messages in-process pour les flux de données à granularité grossière et les tâches de traitement "pipeline". Les composants de flux de données reposent sur les types et l'infrastructure de planification de la bibliothèque parallèle de tâches, et s'intègrent à la prise en charge des langages C#, [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)] et F# de la programmation asynchrone. Ces composants de flux de données sont utiles quand vous avez plusieurs opérations qui doivent communiquer entre elles de façon asynchrone ou quand vous voulez traiter les données à mesure qu'elles deviennent disponibles. Prenons par exemple une application qui traite les données d'image d'une webcam. En utilisant le modèle de flux de données, l'application peut traiter les trames d'images à mesure qu'elles deviennent disponibles. Si l’application améliore les trames d’images, par exemple, en effectuant la lumière de correction ou des yeux rouges, vous pouvez créer un *pipeline* des composants de flux de données. Chaque étape du pipeline peut utiliser plusieurs fonctionnalités de parallélisme à granularité grossière, telles que les fonctionnalités fournies par la bibliothèque TPL qui permettent de transformer les images.  
  
 Ce document fournit une vue d'ensemble de la bibliothèque de flux de données TPL. Il décrit le modèle de programmation et les types de blocs de flux de données prédéfinis, et explique comment configurer des blocs de flux de données pour répondre aux besoins de vos applications.  
  
> [!TIP]
>  La bibliothèque de flux de données TPL (<xref:System.Threading.Tasks.Dataflow?displayProperty=fullName> espace de noms) n’est pas distribuée avec le [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Pour installer le <xref:System.Threading.Tasks.Dataflow> espace de noms, ouvrez votre projet dans [!INCLUDE[vs_dev11_long](../../../includes/vs-dev11-long-md.md)], choisissez **Manage NuGet Packages** à partir du menu projet, puis recherchez en ligne pour le `Microsoft.Tpl.Dataflow` package.  
  
 Ce document contient les sections suivantes :  
  
-   [Modèle de programmation](#model)  
  
-   [Types de blocs de flux de données prédéfinis](#predefined_types)  
  
-   [Comportement des blocs de flux de données de configuration](#behavior)  
  
-   [Blocs de flux de données personnalisé](#custom)  
  
<a name="model"></a>   
## <a name="programming-model"></a>Modèle de programmation  
 La bibliothèque de flux de données TPL constitue une base pour la transmission de messages et la parallélisation des applications nécessitant une utilisation importante du processeur et des E/S, et ayant un débit élevé et une faible latence. Elle permet également de contrôler explicitement la manière dont les données sont mises en mémoire tampon et se déplacent sur le système. Pour mieux comprendre le modèle de programmation de flux de données, imaginez une application qui charge des images à partir du disque de manière asynchrone et crée un composite de ces images. Les modèles de programmation traditionnels requièrent généralement l'utilisation de rappels et d'objets de synchronisation, tels que des verrous, pour coordonner les tâches et accéder aux données partagées. À l'aide du modèle de programmation de flux de données, vous pouvez créer des objets de flux de données qui traitent les images à mesure qu'elles sont lues à partir du disque. Sous le modèle de flux de données, vous déclarez la manière dont sont traitées les données quand elles deviennent disponibles, ainsi que les éventuelles dépendances qui existent entre les données. Le runtime gère les dépendances entre les données, ce qui vous évite d'avoir à synchroniser l'accès aux données partagées. De plus, étant donné que le runtime planifie les tâches en fonction de l'arrivée asynchrone des données, le flux de données peut améliorer la réactivité et le débit grâce à une gestion efficace des threads sous-jacents. Pour obtenir un exemple qui utilise le modèle de programmation de flux de données pour implémenter le traitement d’image dans une application Windows Forms, consultez [procédure pas à pas : utilisation des flux de données dans une Application Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Sources et cibles  
 La bibliothèque de flux de données TPL comprend *blocs de flux de données*, qui sont des données de structures cette mémoire tampon et traiter les données. La bibliothèque parallèle de tâches définit trois types de blocs de flux de données : *blocs sources*, *blocs cibles*, et *blocs propagateurs*. Un bloc source agit comme une source de données et peut donc être lu. Un bloc cible joue le rôle de récepteur de données, il est donc possible d'y écrire. Un bloc propagateur agit à la fois comme un bloc source et un bloc cible, et peut donc faire l'objet d'une lecture et d'une écriture. La bibliothèque parallèle de tâches définit les <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=fullName> interface pour représenter les sources, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=fullName> pour représenter les cibles, et <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=fullName> pour représenter les propagateurs.</TInput, TOutput> <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> hérite à la fois <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, et <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.\</TInput, TOutput>  
  
 La bibliothèque de flux de données TPL fournit plusieurs types de blocs de flux de données prédéfinis qui implémentent la <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>, et <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> interfaces.\</TInput, TOutput> Ces types de blocs de flux de données sont décrites dans ce document dans la section [prédéfinis de Types de blocs de flux de données](#predefined_types).  
  
### <a name="connecting-blocks"></a>Connexion des blocs  
 Vous pouvez connecter des blocs de flux de données pour former *pipelines*, qui sont des séquences linéaires de blocs de flux de données, ou *réseaux*, qui sont des graphiques des blocs de flux de données. Un pipeline est une forme de réseau. Dans un pipeline ou un réseau, les sources propagent des données de manière asynchrone vers les cibles à mesure que les données deviennent disponibles. Le <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=fullName> méthode lie un bloc de flux de données source à un bloc cible. Une source peut être liée à zéro, une ou plusieurs cibles. Une cible peut être liée à zéro, une ou plusieurs sources. Vous pouvez ajouter des blocs de flux de données à un pipeline ou en supprimer de manière simultanée. Les types de blocs de flux de données prédéfinis gèrent tous les aspects liés à la sécurité des threads pour les liaisons et les annulations de liaison.  
  
 Pour obtenir un exemple qui connecte des blocs de flux de données pour former un pipeline de base, consultez [procédure pas à pas : création d’un Pipeline de flux de données](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md). Pour obtenir un exemple qui connecte des blocs de flux de données pour former un réseau plus complexe, consultez [procédure pas à pas : utilisation des flux de données dans une Application Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md). Pour obtenir un exemple qui supprime une cible d’une source après que la cible un message, consultez [Comment : dissocier des blocs de flux de données](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Filtrage  
 Lorsque vous appelez le <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=fullName> méthode pour lier une source vers une cible, vous pouvez fournir un délégué qui détermine si le bloc cible accepte ou rejette un message en fonction de la valeur de ce message. Ce mécanisme de filtrage permet de garantir qu'un bloc de flux de données recevra uniquement certaines valeurs. Pour la plupart des types de blocs de flux de données prédéfinis, si un bloc source est connecté à plusieurs blocs cibles, quand un bloc cible rejette un message, la source envoie le message à la cible suivante. L'ordre dans lequel une source envoie des messages aux cibles est défini par la source et peut varier en fonction du type de la source. La plupart des types de blocs sources arrêtent d'envoyer un message une fois celui-ci accepté par une cible. Une exception à cette règle est la <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> (classe), qui offre de chaque message à toutes les cibles, même si certaines cibles rejettent le message. Pour obtenir un exemple qui utilise le filtrage pour traiter uniquement certains messages, consultez [procédure pas à pas : utilisation des flux de données dans une Application Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
>  Étant donné que chaque type de bloc de flux de données source prédéfini garantit la propagation des messages dans l'ordre où ils sont reçus, tous les messages doivent être lus depuis le bloc source avant que celui-ci ne puisse traiter le message suivant. Par conséquent, quand vous utilisez le filtrage pour connecter plusieurs cibles à une source, assurez-vous que chaque message soit reçu par au moins un bloc cible. Sinon, votre application peut se bloquer.  
  
### <a name="message-passing"></a>Transmission de messages  
 Le modèle de programmation de flux de données est lié au concept de *passage de messages*, où les composants indépendants d’un programme communiquent entre eux en envoyant des messages. Une façon de propager des messages entre les composants d’application consiste à appeler le <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> et <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=fullName> des méthodes pour envoyer des messages POST de blocs de flux de données cible (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> agit de manière synchrone ; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> asynchrone) et le <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, et <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> méthodes pour recevoir des messages à partir de blocs de code source. Vous pouvez combiner ces méthodes à des pipelines ou réseaux de flux de données en envoyant des données d'entrée au nœud principal (bloc cible) et en recevant des données de sortie de la part du nœud terminal du pipeline ou des nœuds terminaux du réseau (un ou plusieurs blocs sources). Vous pouvez également utiliser le <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> pour lire à partir de la première méthode de sources fournies qui contient des données et effectuer des actions sur ces données.  
  
 Blocs sources envoient des données aux blocs cibles en appelant le <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=fullName> (méthode). Le bloc cible peut répondre à un message envoyé de trois manières : il peut accepter le message, le refuser ou le différer. Lorsque la cible accepte le message, le <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> méthode renvoie <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Lorsque la cible refuse le message, le <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> méthode renvoie <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Quand la cible qu’il ne reçoive plus tous les messages à partir de la source, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> retourne <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Les types de blocs sources prédéfinis n'envoient plus de messages aux cibles liées après réception d'une telle valeur et sont automatiquement dissociés de ces cibles.  
  
 Lorsqu’un bloc cible diffère le message pour une utilisation ultérieure, le <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> méthode renvoie <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Un bloc cible qui diffère un message peut appeler ultérieurement la <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=fullName> méthode pour tenter de réserver le message envoyé. À ce stade, soit le message est toujours disponible et peut être utilisé par le bloc cible, soit le message a été utilisé par une autre cible. Lorsque le bloc cible nécessite ultérieurement le message ou n’a plus besoin du message, il appelle le <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=fullName> ou <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> (méthode), respectivement. La réservation de messages est généralement utilisée par les types de blocs de flux de données qui fonctionnent en mode non gourmand. Le mode non gourmand est expliqué plus loin dans ce document. Plutôt que de réserver un message différé, un bloc cible peut également utiliser le <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=fullName> méthode tente d’utiliser directement le message différé.  
  
### <a name="dataflow-block-completion"></a>Achèvement des blocs de flux de données  
 Les blocs de flux de données prennent également en charge le concept de *fin*. Un bloc de flux de données qui est achevé n'effectue plus aucune tâche. Chaque bloc de flux de données est associé à un <xref:System.Threading.Tasks.Task?displayProperty=fullName> objet, appelé un *tâche d’achèvement*, qui représente l’état d’achèvement du bloc. Étant donné que vous pouvez attendre un <xref:System.Threading.Tasks.Task> pour terminer, à l’aide de tâches d’exécution, vous pouvez attendre d’un ou plusieurs nœuds terminaux d’un flux de données réseau à la fin de l’objet. Le <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interface définit les <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> (méthode), qui informe le bloc de flux de données d’une requête pour qu’elle se termine, et le <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> propriété qui retourne la tâche d’achèvement pour le bloc de flux de données. Les deux <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> et <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> héritent la <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interface.  
  
 Il existe deux façons de déterminer si un bloc de flux de données s'est terminé sans erreur, si une ou plusieurs erreurs se sont produites ou s'il a été annulé. La première consiste à appeler le <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName> méthode sur la tâche d’achèvement dans un `try` - `catch` bloc (`Try` - `Catch` en Visual Basic). L’exemple suivant crée un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objet lève une exception <xref:System.ArgumentOutOfRangeException> si sa valeur d’entrée est inférieur à zéro. <xref:System.AggregateException> est levée quand cet exemple appelle <xref:System.Threading.Tasks.Task.Wait%2A> sur la tâche d’achèvement. Le <xref:System.ArgumentOutOfRangeException> est accessible via la <xref:System.AggregateException.InnerExceptions%2A> propriétés de la <xref:System.AggregateException> objet.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 Dans cet exemple, une exception n'est pas gérée dans le délégué d'un bloc de flux de données d'exécution. Nous vous recommandons de gérer les exceptions dans le corps des blocs. Toutefois, si vous ne parvenez pas à le faire, le bloc se comportera comme s'il avait été annulé et ne traitera pas les messages entrants.  
  
 Lorsqu’un bloc de flux de données est annulé de manière explicite, le <xref:System.AggregateException> objet contient <xref:System.OperationCanceledException> dans les <xref:System.AggregateException.InnerExceptions%2A> propriété. Pour plus d'informations sur l'annulation de flux de données, consultez la section "Permettre les annulations" plus loin dans ce document.  
  
 La deuxième méthode permettant de déterminer l'état d'achèvement d'un bloc de flux de données est d'utiliser une continuation de la tâche d'achèvement, ou d'utiliser les fonctionnalités de langage asynchrones de C# et de Visual Basic pour attendre la tâche d'achèvement de manière asynchrone. Le délégué que vous fournissez à la <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=fullName> méthode prend un <xref:System.Threading.Tasks.Task> objet qui représente la tâche précédente. Dans le cas de la <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> propriété, le délégué de la continuation prend la tâche d’achèvement. L’exemple suivant ressemble au précédent, sauf qu’elle utilise également la <xref:System.Threading.Tasks.Task.ContinueWith%2A> pour créer une tâche d’achèvement qui imprime l’état de l’opération de flux de données globale.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 Vous pouvez également utiliser des propriétés telles que <xref:System.Threading.Tasks.Task.IsCanceled%2A> dans le corps de la tâche de continuation pour déterminer des informations supplémentaires sur l’état d’achèvement d’un bloc de flux de données. Pour plus d’informations sur les tâches de continuation et leur interaction pour l’annulation et la gestion des erreurs, consultez la page [chaînage des tâches à l’aide de tâches de Continuation](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md), [l’annulation de tâche](../../../docs/standard/parallel-programming/task-cancellation.md), [la gestion des exceptions](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md), et [NIB : Comment : gérer les Exceptions levées par des tâches](http://msdn.microsoft.com/fr-fr/d6c47ec8-9de9-4880-beb3-ff19ae51565d).  
  
 [[go to top](#top)]  
  
<a name="predefined_types"></a>   
## <a name="predefined-dataflow-block-types"></a>Types de blocs de flux de données prédéfinis  
 La bibliothèque de flux de données TPL fournit plusieurs types de blocs de flux de données prédéfinis. Ces types sont divisés en trois catégories : *blocs de mise en mémoire tampon*, *blocs d’exécution*, et *blocs de regroupement*. Les sections suivantes décrivent les types de blocs qui composent ces catégories.  
  
### <a name="buffering-blocks"></a>Blocs de mise en mémoire tampon  
 Les blocs de mise en mémoire tampon contiennent des données destinées aux consommateurs de données. La bibliothèque de flux de données TPL fournit trois types de blocs de mise en mémoire tampon : <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=fullName>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=fullName>, et <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=fullName>.  
  
#### <a name="bufferblockt"></a>BufferBlock(T)  
 Le <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> classe représente une structure de messagerie asynchrone à usage général. Cette classe stocke une file d'attente de messages de type premier entré, premier sorti (FIFO). Plusieurs cibles peuvent lire ces messages et plusieurs sources peuvent y écrire. Quand une cible reçoit un message d’un <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> de l’objet, ce message est supprimé de la file d’attente. Par conséquent, bien qu’un <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> objet peut avoir plusieurs cibles, qu’une seule cible reçoit chaque message. Le <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> classe est utile lorsque vous voulez passer plusieurs messages à un autre composant, et que le composant doit recevoir chaque message.  
  
 L’exemple de base suivant publie plusieurs <xref:System.Int32> valeurs à un <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> de l’objet, puis le lit ces valeurs à partir de cet objet.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Pour un exemple complet qui montre comment écrire et lire des messages d’un <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> , consultez [Comment : écrire et lire des Messages à partir d’un Dataflow Block](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  
 Le <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> classe est utile lorsque vous devez transmettre plusieurs messages à un autre composant, mais que ce composant nécessite uniquement la valeur la plus récente. Cette classe est également utile quand vous voulez diffuser un message vers plusieurs composants.  
  
 Les publications de l’exemple de base suivant un <xref:System.Double> valeur un <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> objet puis lue à partir de cet objet plusieurs fois. Étant donné que les valeurs ne sont pas supprimés de <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> objets après leur lecture, la même valeur est disponible à chaque fois.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Pour un exemple complet qui montre comment utiliser <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> pour diffuser un message à plusieurs blocs cibles, consultez [Comment : spécifier un planificateur de tâches dans un Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  
 Le <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> ressemble à la <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> de classe, à ceci près qu’un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objet peut être écrites dans une seule fois. Vous pouvez considérer <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> est similaire à celle de C# [readonly](../Topic/readonly%20\(C%23%20Reference\).md) ([ReadOnly](../Topic/ReadOnly%20\(Visual%20Basic\).md) dans [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)]) (mot clé), à ceci près qu’un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objet est immuable après avoir reçu une valeur au moment de construction. Comme le <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> (classe), lorsqu’une cible reçoit un message d’un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> de l’objet, ce message n’est pas supprimé de cet objet. Par conséquent, plusieurs cibles reçoivent une copie du message. Le <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> classe est utile lorsque vous voulez propager uniquement la première de plusieurs messages.  
  
 L’exemple de base suivant publie plusieurs <xref:System.String> valeurs à un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objet, puis lit la valeur de retour de cet objet. Car un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objet peut être écrites dans une seule fois, une fois qu’un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objet reçoit un message, il rejette les messages suivants.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Pour un exemple complet qui montre comment utiliser <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> pour recevoir la valeur de la première opération se termine, consultez [Comment : dissocier des blocs de flux de données](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Blocs d'exécution  
 Les blocs d'exécution appellent un délégué fourni par l'utilisateur pour chaque donnée reçue. La bibliothèque de flux de données TPL fournit trois types de blocs d’exécution : <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=fullName>, et <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=fullName>.\</TInput, TOutput> \</TInput, TOutput>  
  
#### <a name="actionblockt"></a>ActionBlock(T)  
 Le <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> classe est un bloc cible qui appelle un délégué lorsqu’il reçoit des données. Considérez un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objet sous la forme d’un délégué qui s’exécute de façon asynchrone lorsque les données deviennent disponibles. Le délégué que vous fournissez à un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objet peut être de type <xref:System.Action> ou `System.Func\<TInput, Task>`. Lorsque vous utilisez un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> avec l’objet <xref:System.Action>, le traitement de chaque élément d’entrée est considéré comme terminé quand le délégué est retourné. Lorsque vous utilisez un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> avec l’objet `System.Func\<TInput, Task>`, traitement de chaque élément d’entrée est considéré comme terminé que quand retourné <xref:System.Threading.Tasks.Task> objet est terminé. À l’aide de ces deux mécanismes, vous pouvez utiliser <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> pour le traitement synchrone et asynchrone de chaque élément d’entrée.  
  
 L’exemple de base suivant publie plusieurs <xref:System.Int32> valeurs à un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objet. Le <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objet imprime ces valeurs dans la console. Cet exemple attribue ensuite au bloc l'état achevé, puis attend que toutes les tâches de flux de données soient terminées.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Pour obtenir des exemples complets qui montrent comment utiliser des délégués avec les <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> de classe, consultez la page [Comment : effectuer Action lorsqu’un flux de données bloc reçoit des données](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  
 Le <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> ressemble à la <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> classe, sauf qu’il fait à la fois en tant que source et cible.\</TInput, TOutput> Le délégué que vous passez à un <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> objet renvoie une valeur de type `TOutput`.</TInput, TOutput> Le délégué que vous fournissez à un <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> objet peut être de type `System.Func<TInput, TOutput>` ou `System.Func<TInput, Task>`.\</TInput, TOutput> Lorsque vous utilisez un <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> avec l’objet `System.Func\<TInput, TOutput>`, le traitement de chaque élément d’entrée est considéré comme terminé lorsque le délégué retourne.</TInput, TOutput> Lorsque vous utilisez un <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> objet utilisé avec `System.Func<TInput, Task<TOutput>>`, traitement de chaque élément d’entrée est considéré comme terminé que quand retourné <xref:System.Threading.Tasks.Task> objet terminé.\</TInput, TOutput> Comme avec <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, à l’aide de ces deux mécanismes, vous pouvez utiliser <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> pour le traitement synchrone et asynchrone de chaque élément d’entrée.\</TInput, TOutput>  
  
 L’exemple de base suivant crée un <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> objet qui calcule la racine carrée de son entrée.</TInput, TOutput> Le <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> prend de l’objet <xref:System.Int32> valeurs comme entrée et produit <xref:System.Double> valeurs en tant que sortie.\</TInput, TOutput>  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Pour obtenir des exemples complets qui utilise <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> dans un réseau de blocs de flux de données qui effectue le traitement de l’image dans une application Windows Forms, consultez [procédure pas à pas : utilisation des flux de données dans une Application Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).\</TInput, TOutput>  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  
 Le <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> ressemble à la <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> de classe, à ceci près que <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> produit zéro ou plusieurs valeurs de sortie pour chaque valeur d’entrée, et non uniquement une valeur de sortie pour chaque valeur d’entrée.</TInput, TOutput> </TInput, TOutput> </TInput, TOutput> Le délégué que vous fournissez à un <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objet peut être de type `System.Func<TInput, IEnumerable<TOutput>>` ou `type System.Func<TInput, Task<IEnumerable<TOutput>>>`.\</TInput, TOutput> Lorsque vous utilisez un <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> avec l’objet `System.Func<TInput, IEnumerable<TOutput>>`, le traitement de chaque élément d’entrée est considéré comme terminé lorsque le délégué retourne.</TInput, TOutput> Lorsque vous utilisez un <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> avec l’objet `System.Func<TInput, Task<IEnumerable<TOutput>>>`, traitement de chaque élément d’entrée est considéré comme terminé uniquement lorsque retourné `System.Threading.Tasks.Task<IEnumerable<TOutput>>` objet est terminé.\</TInput, TOutput>  
  
 L’exemple de base suivant crée un <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objet qui fractionne les chaînes en leurs séquences de caractères individuels.</TInput, TOutput> Le <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> prend de l’objet <xref:System.String> valeurs comme entrée et produit <xref:System.Char> valeurs en tant que sortie.\</TInput, TOutput>  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Pour obtenir des exemples complets qui utilisent <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> pour produire des sorties multiples indépendantes pour chaque entrée dans un pipeline de flux de données, consultez [procédure pas à pas : création d’un Pipeline de flux de données](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md).\</TInput, TOutput>  
  
#### <a name="degree-of-parallelism"></a>Degré de parallélisme  
 Chaque <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, et <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> tampons de l’objet des messages entrants jusqu'à ce que le bloc soit prêt à les traiter.</TInput, TOutput> </TInput, TOutput> Par défaut, ces classes de traitent les messages un par un, dans l'ordre dans lequel ils sont reçus. Vous pouvez également spécifier le degré de parallélisme pour activer <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> et <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objets à traiter plusieurs messages simultanément.\</TInput, TOutput> \</TInput, TOutput> Pour plus d'informations sur l'exécution simultanée, consultez la section "Spécification du degré de parallélisme" plus loin dans ce document. Pour obtenir un exemple qui définit le degré de parallélisme pour permettre à un bloc de flux de données d’exécution traiter plusieurs messages à la fois, consultez [Comment : spécifier le degré de parallélisme dans un Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Récapitulation des types délégués  
 Le tableau suivant récapitule les types délégués que vous pouvez fournir aux <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, et <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objets.\</TInput, TOutput> \</TInput, TOutput> Le tableau indique également si le type délégué fonctionne de façon synchrone ou asynchrone.  
  
|Type|Type délégué synchrone|Type délégué asynchrone|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func\<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602></TInput, TOutput>|`System.Func\<TInput, TOutput>`2`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602></TInput, TOutput>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 Vous pouvez également utiliser des expressions lambda quand vous utilisez des types de blocs d'exécution. Pour obtenir un exemple qui montre comment utiliser une expression lambda avec un bloc d’exécution, consultez [Comment : effectuer Action lorsqu’un flux de données bloc reçoit des données](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Blocs de regroupement  
 Les blocs de regroupement combinent les données d'une ou plusieurs sources, sous diverses contraintes. La bibliothèque de flux de données TPL fournit trois types de blocs de jointure : <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, et <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.\</T1, T2> \</T1, T2>  
  
#### <a name="batchblockt"></a>BatchBlock(T)  
 Le <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> classe combine des jeux de données d’entrée, qui sont appelées des lots, dans les tableaux de données de sortie. Vous spécifiez la taille de chaque lot lorsque vous créez un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objet. Lors de la <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objet reçoit le nombre spécifié d’éléments d’entrée, il propage de manière asynchrone un tableau qui contient ces éléments. Si un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objet est défini sur l’état terminé mais ne contient-elle pas suffisamment d’éléments pour former un lot, il propage un tableau final contenant les éléments d’entrée restants.  
  
 Le <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> classe s’exécute en mode *gourmand* ou *non gourmand* mode. En mode gourmand, qui est la valeur par défaut, un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objet accepte tous les messages qu’il est proposé et propage un tableau après avoir reçu le nombre spécifié d’éléments. En mode non gourmand, un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objet diffère tous les messages entrants jusqu'à ce que suffisamment sources ont offert des messages vers le bloc pour former un lot. Le mode gourmand est généralement plus performant que le mode non gourmand, car il nécessite une charge de traitement moindre. Toutefois, vous pouvez utiliser le mode non gourmand quand vous devez coordonner la consommation de plusieurs sources de façon atomique. Spécifiez le mode non gourmand en définissant <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> à `False` dans les `dataflowBlockOptions` paramètre dans le <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> constructeur.  
  
 L’exemple de base suivant publie plusieurs <xref:System.Int32> valeurs à un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objet qui contient les dix éléments dans un lot. Pour garantir que toutes les valeurs sont propagées de la <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, cet exemple appelle la <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> (méthode). Le <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> méthode définit les <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objet à l’état terminé et par conséquent, le <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objet propage les éléments restants dans un dernier lot.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Pour un exemple complet qui utilise <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> pour améliorer l’efficacité des opérations d’insertion de base de données, consultez [procédure pas à pas : utilisation de BatchBlock et de BatchedJoinBlock pour améliorer l’efficacité](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>JoinBlock(T1, T2,...)  
 Le <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> et <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classes collectent des éléments d’entrée et propagent les <xref:System.Tuple%602?displayProperty=fullName> ou <xref:System.Tuple%603?displayProperty=fullName> objets qui contiennent ces éléments.\</T1, T2, T3> \</T1, T2> \</T1, T2, T3> \</T1, T2> Le <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> et <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classes n’héritent pas de <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</T1, T2, T3> </T1, T2> Au lieu de cela, elles fournissent les propriétés <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, et <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, qui implémentent <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Comme <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> et <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> fonctionner en mode gourmand ou non gourmand.</T1, T2, T3> </T1, T2> En mode gourmand, qui est la valeur par défaut, un <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> ou <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> objet accepte tous les messages qu’il est proposé et propage un tuple après chacune de ses cibles reçoit au moins un message.</T1, T2, T3> </T1, T2> En mode non gourmand, un <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> ou <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> objet diffère tous les messages entrants jusqu'à ce que toutes les cibles ont été proposés les données requises pour créer un tuple.\</T1, T2, T3> \</T1, T2> À ce stade, le bloc s'engage dans un protocole de validation en deux phases pour récupérer atomiquement tous les éléments requis à partir des sources. Ce report permet à une autre entité de consommer les données pendant ce temps, pour que l'ensemble du système puisse progresser.  
  
 L’exemple de base suivant montre un cas dans lequel un <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> objet nécessite plusieurs données pour calculer une valeur.</T1, T2, T3> Cet exemple crée un <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> objet nécessite deux <xref:System.Int32> valeurs et un <xref:System.Char> valeur pour effectuer une opération arithmétique.\</T1, T2, T3>  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Pour un exemple complet qui utilise <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> en mode non gourmand en coopération partager une ressource, consultez [Comment : utiliser JoinBlock pour lire des données à partir de plusieurs Sources](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).\</T1, T2>  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock(T1, T2, ...)  
 Le <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> et <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> classes collectent des lots d’éléments d’entrée et propagent les `System.Tuple(IList(T1), IList(T2))` ou `System.Tuple(IList(T1), IList(T2), IList(T3))` les objets qui contiennent ces éléments.\</T1, T2, T3> \</T1, T2> Pensez à <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> comme une combinaison de <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> et <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>.</T1, T2> </T1, T2> Spécifiez la taille de chaque lot lorsque vous créez un <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> objet.\</T1, T2> <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> fournit également les propriétés <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> et <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, qui implémentent <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.\</T1, T2> Lorsque le nombre spécifié d’éléments d’entrée sont reçus à partir de sur toutes les cibles, les <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> objet propage de manière asynchrone une `System.Tuple(IList(T1), IList(T2))` objet qui contient ces éléments.\</T1, T2>  
  
 L’exemple de base suivant crée un <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> objet qui conserve des résultats, <xref:System.Int32> les valeurs et les erreurs qui sont <xref:System.Exception> objets.</T1, T2> Cet exemple effectue plusieurs opérations et écrit les résultats de la <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> propriété et les erreurs dans le <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> propriété, de la <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> objet.\</T1, T2> Étant donné que le nombre d’opérations réussies et échouées est inconnu à l’avance, le <xref:System.Collections.Generic.IList%601> objets permettent à chaque cible de recevoir des valeurs zéro ou plus.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Pour un exemple complet qui utilise <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> pour capturer les résultats et les exceptions qui se produisent lorsque le programme lit à partir d’une base de données, consultez [procédure pas à pas : utilisation de BatchBlock et de BatchedJoinBlock pour améliorer l’efficacité](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).\</T1, T2>  
  
 [[go to top](#top)]  
  
<a name="behavior"></a>   
## <a name="configuring-dataflow--block-behavior"></a>Configuration du comportement des blocs de flux de données  
 Vous pouvez activer des options supplémentaires en fournissant un <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=fullName> objet au constructeur de types de blocs de flux de données. Ces options permettent de contrôler le comportement, comme celui du planificateur qui gère la tâche sous-jacente et le degré de parallélisme. Le <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> également a types dérivés qui spécifient le comportement spécifique à certains types de blocs de flux de données. Le tableau suivant récapitule les types d'options qui sont associés à chaque type de bloc de flux de données.  
  
|Type de bloc de flux de données|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> type|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>\</TInput, TOutput>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>\</TInput, TOutput>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>\</T1, T2>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>\</T1, T2>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 Les sections suivantes fournissent des informations supplémentaires sur les types de flux de données importants d’options de bloc qui sont disponibles via la <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=fullName>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=fullName>, et <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=fullName> classes.  
  
### <a name="specifying-the-task-scheduler"></a>Spécification du planificateur de tâches  
 Chaque bloc de flux de données prédéfini utilise le mécanisme de planification des tâches TPL pour effectuer des activités, telles que la propagation de données vers une cible, la réception de données à partir d'une source et l'exécution de délégués définis par l'utilisateur quand des données deviennent disponibles. <xref:System.Threading.Tasks.TaskScheduler> est une classe abstraite qui représente un planificateur de tâches en file d’attente de tâches sur des threads. Le Planificateur de tâches par défaut, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, utilise le <xref:System.Threading.ThreadPool> classe à la file d’attente et les exécuter. Vous pouvez remplacer le Planificateur de tâches par défaut en définissant le <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> propriété lorsque vous construisez un objet de bloc de flux de données.  
  
 Quand un même planificateur de tâches gère plusieurs blocs de flux de données, il peut appliquer les mêmes stratégies à chacune d'elles. Par exemple, si plusieurs blocs de flux de données sont toutes configurées pour cibler le planificateur exclusif du même <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> de l’objet, tout le travail qu’exécutées dans ces blocs sont sérialisées. De même, si ces blocs sont configurés pour cibler le planificateur simultané du même <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> objet et que le planificateur est configuré pour avoir un niveau d’accès concurrentiel maximal, tout le travail à partir de ces blocs est limité au nombre d’opérations simultanées. Pour obtenir un exemple qui utilise le <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> classe pour permettre les opérations de lecture se produisent en parallèle, mais écrire des opérations de se produire exclusivement de toutes les autres opérations, consultez [Comment : spécifier un planificateur de tâches dans un Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Pour plus d’informations sur les planificateurs de tâches dans la bibliothèque parallèle de tâches, consultez la <xref:System.Threading.Tasks.TaskScheduler> rubrique de la classe.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Spécification du degré de parallélisme  
 Par défaut, les types de blocs de trois exécution par la bibliothèque de flux de données TPL, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, et <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, traiter un message à la fois.\</TInput, TOutput> \</TInput, TOutput> Ces types de blocs de flux de données traitent également les messages dans l'ordre dans lequel ils sont reçus. Pour activer ces blocs de flux de données traiter simultanément les messages, définissez les <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=fullName> propriété lorsque vous construisez l’objet de bloc de flux de données.  
  
 La valeur par défaut <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> est 1, ce qui garantit que le bloc de flux de données traite un message à la fois. En définissant cette propriété sur une valeur supérieure à 1, vous permettez au bloc de flux de données de traiter plusieurs messages simultanément. Si cette propriété <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=fullName> permet au planificateur de tâches sous-jacente gérer le degré maximal de concurrence.  
  
> [!IMPORTANT]
>  Quand vous spécifiez un degré maximal de parallélisme supérieur à 1, plusieurs messages sont traités simultanément. Il se peut donc que les messages ne soient pas traités dans l'ordre dans lequel ils sont reçus. Toutefois, l'ordre dans lequel les messages sont générés à partir du bloc reste le même.  
  
 Étant donné que la <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> propriété représente le degré maximal de parallélisme, le bloc de flux de données peut s’exécuter avec un degré de parallélisme moindre que vous spécifiez. Le bloc de flux de données peut utiliser un degré de parallélisme moindre pour satisfaire ses exigences fonctionnelles ou en cas de manque de ressources système disponibles. Un bloc de flux de données n'utilisera jamais un niveau de parallélisme supérieur à celui que vous spécifiez.  
  
 La valeur de la <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> propriété est exclusive à chaque objet de bloc de flux de données. Par exemple, si chacun des quatre objets de blocs de flux de données spécifie la valeur 1 comme degré maximal de parallélisme, les quatre objets de bloc de flux de données peuvent être exécutés en parallèle.  
  
 Pour obtenir un exemple qui définit le degré maximal de parallélisme pour activer les opérations de longue durée se produisent en parallèle, consultez [Comment : spécifier le degré de parallélisme dans un Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Spécification du nombre de messages par tâche  
 Les types de blocs de flux de données prédéfinis utilisent des tâches pour traiter plusieurs éléments d'entrée. Cela aide à réduire le nombre d'objets de tâches requis pour traiter les données, ce qui permet aux applications de s'exécuter plus efficacement. Toutefois, quand les tâches d'un ensemble de blocs de flux de données traitent des données, il est possible que les tâches des autres blocs de flux de données doivent attendre d'être traitées et placer leurs messages dans la file d'attente. Pour permettre une meilleure justesse parmi les tâches de flux de données, définissez la <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> propriété. Lors de la <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> a <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=fullName>, qui est la valeur par défaut, la tâche utilisée par un bloc de flux de données traite tous les messages sont disponibles. Lors de la <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> est définie sur une valeur autre que <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, le bloc de flux de données traite au maximum le nombre de messages par <xref:System.Threading.Tasks.Task> objet. Bien que la configuration du <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> propriété peut augmenter équité entre des tâches, il peut entraîner le système créer des tâches plus que nécessaire, ce qui peut réduire les performances.  
  
### <a name="enabling-cancellation"></a>Permettre les annulations  
 La bibliothèque parallèle de tâches (TPL) fournit un mécanisme qui permet aux tâches de coordonner l'annulation de manière coopérative. Pour activer des blocs de flux de données de participer à ce mécanisme d’annulation, définissez la <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> propriété. Lorsque cela <xref:System.Threading.CancellationToken> objet est défini à l’état annulé, tous les blocs de flux de données qui contrôlent ce jeton terminent l’exécution de l’élément actuel, mais ne démarrent pas le traitement des éléments suivants. De plus, ces blocs de flux de données effacent les messages mis en mémoire tampon, libèrent les connexions aux blocs sources et cibles, et passent à l'état annulé. Lors du passage à l’état annulé, la <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> propriété a le <xref:System.Threading.Tasks.Task.Status%2A> propriété <xref:System.Threading.Tasks.TaskStatus>, sauf si une exception s’est produite lors du traitement. Dans ce cas, <xref:System.Threading.Tasks.Task.Status%2A> a <xref:System.Threading.Tasks.TaskStatus>.  
  
 Pour obtenir un exemple qui montre comment utiliser l’annulation dans une application Windows Forms, consultez [Comment : annuler une Dataflow Block](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md). Pour plus d’informations sur l’annulation dans la bibliothèque parallèle de tâches, consultez la page [l’annulation de tâche](../../../docs/standard/parallel-programming/task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Spécification des comportements gourmand et non gourmand  
 Plusieurs types de blocs de flux de données de regroupement peuvent fonctionner en mode *gourmand* ou *non gourmand* mode. Par défaut, les types de blocs de flux de données prédéfinis fonctionnent en mode gourmand.  
  
 À la jointure de bloquer des types tels que <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, le mode gourmand signifie que le bloc accepte immédiatement les données même si les données correspondantes avec laquelle joindre ne sont pas encore disponibles.</T1, T2> Le mode non gourmand signifie que le bloc diffère tous les messages entrants jusqu'à ce que chacune de ses cibles ait reçu un message, permettant ainsi le regroupement. Si l'un des messages différés n'est plus disponible, le bloc de regroupement libère tous les messages différés et redémarre le processus. Pour le <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> classe gourmand et non gourmand est similaire, à ceci près qu’en mode non gourmand, un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objet diffère tous les messages entrants jusqu'à ce que suffisamment sont disponibles à partir de sources distinctes pour former un lot.  
  
 Pour spécifier le mode non gourmand pour un bloc de flux de données, définissez <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> à `False`. Pour obtenir un exemple qui montre comment utiliser le mode non gourmand pour permettre à plusieurs blocs de partager une source de données plus efficacement, consultez [Comment : utiliser JoinBlock pour lire des données à partir de plusieurs Sources](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
 [[go to top](#top)]  
  
<a name="custom"></a>   
## <a name="custom-dataflow-blocks"></a>Blocs de flux de données personnalisés  
 Même si la bibliothèque de flux de données TPL fournit de nombreux types de blocs prédéfinis, vous pouvez créer d'autres types de blocs ayant un comportement personnalisé. Implémentez la <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> ou <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interagit directement ou utiliser les <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> méthode pour créer un bloc complex qui encapsule le comportement des types de blocs existants.\</TInput, TOutput> Pour obtenir des exemples qui montrent comment implémenter la fonctionnalité de bloc de flux de données personnalisé, consultez [procédure pas à pas : création d’un Type de bloc de flux de données personnalisé](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md).  
  
 [[go to top](#top)]  
  
## <a name="related-topics"></a>Rubriques connexes  
  
|Titre|Description|  
|-----------|-----------------|  
|[Comment : écrire et lire des Messages à partir d’un bloc de flux de données](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Montre comment écrire et lire des messages d’un <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> objet.|  
|[Comment : implémenter un modèle de flux de données producteur-consommateur](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)|Explique comment utiliser le modèle de flux de données pour implémenter un modèle producteur-consommateur, où le producteur envoie des messages à un bloc de flux de données et le consommateur lit les messages de ce bloc.|  
|[Comment : exécuter des actions lorsqu’un bloc de flux de données reçoit des données](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)|Décrit comment fournir des délégués pour les types de blocs de flux de données d’exécution, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, et <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.\</TInput, TOutput> \</TInput, TOutput>|  
|[Procédure pas à pas : Création d’un Pipeline de flux de données](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)|Explique comment créer un pipeline de flux de données qui télécharge du texte à partir du web et effectue des opérations sur ce texte.|  
|[Comment : dissocier des blocs de flux de données](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)|Montre comment utiliser le <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> méthode pour dissocier un bloc cible à partir de sa source une fois la source envoie un message à la cible.|  
|[Procédure pas à pas : Utilisation de flux de données dans une Application Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)|Montre comment créer un réseau de blocs de flux de données qui effectuent un traitement des images dans une application Windows Forms.|  
|[Comment : annuler un bloc de flux de données](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)|Montre comment utiliser l'annulation dans une application Windows Forms.|  
|[Comment : utiliser JoinBlock pour lire les données provenant de plusieurs Sources](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Explique comment utiliser le <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> classe pour effectuer une opération lorsque les données sont disponibles à partir de plusieurs sources et comment utiliser le mode non gourmand pour permettre à plusieurs blocs de partager une source de données plus efficacement.\</T1, T2>|  
|[Comment : spécifier le degré de parallélisme dans un bloc de flux de données](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Décrit comment définir le <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> propriété pour activer un bloc de flux de données d’exécution traiter plusieurs messages à la fois.|  
|[Comment : spécifier un planificateur de tâches dans un bloc de flux de données](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Montre comment associer un planificateur de tâches spécifique quand vous utilisez un flux de données dans votre application.|  
|[Procédure pas à pas : Utilisation de BatchBlock et BatchedJoinBlock pour améliorer l’efficacité](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Décrit comment utiliser le <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> classe afin d’améliorer l’efficacité de la base de données insérer des opérations et comment utiliser le <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> classe afin de capturer les résultats et les exceptions qui se produisent lorsque le programme lit à partir d’une base de données.\</T1, T2>|  
|[Procédure pas à pas : Création d’un Type de bloc de flux de données personnalisé](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)|Montre deux façons de créer un type de bloc de flux de données qui implémente un comportement personnalisé.|  
|[Bibliothèque parallèle de tâches (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)|Présente la bibliothèque parallèle de tâches (TPL), qui simplifie la programmation parallèle et simultanée dans les applications [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)].|