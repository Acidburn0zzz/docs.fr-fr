---
title: "Structures de données pour la programmation parallèle"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords: data structures, multi-threading
ms.assetid: bdc82f2f-4754-45a1-a81e-fe2e9c30cef9
caps.latest.revision: "15"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: f35c5382455021f0a001604367e59204ce4ad93c
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/21/2017
---
# <a name="data-structures-for-parallel-programming"></a><span data-ttu-id="663b8-102">Structures de données pour la programmation parallèle</span><span class="sxs-lookup"><span data-stu-id="663b8-102">Data Structures for Parallel Programming</span></span>
<span data-ttu-id="663b8-103">Le .NET Framework version 4 introduit plusieurs nouveaux types qui sont utiles dans la programmation parallèle, y compris un ensemble de classes de collection simultanée, les primitives de synchronisation légers et les types pour l’initialisation tardive.</span><span class="sxs-lookup"><span data-stu-id="663b8-103">The .NET Framework version 4 introduces several new types that are useful in parallel programming, including a set of concurrent collection classes, lightweight synchronization primitives, and types for lazy initialization.</span></span> <span data-ttu-id="663b8-104">Vous pouvez utiliser ces types avec n’importe quel code d’application multithread, y compris la bibliothèque parallèle de tâches et PLINQ.</span><span class="sxs-lookup"><span data-stu-id="663b8-104">You can use these types with any multithreaded application code, including the Task Parallel Library and PLINQ.</span></span>  
  
## <a name="concurrent-collection-classes"></a><span data-ttu-id="663b8-105">Classes de Collection simultanée</span><span class="sxs-lookup"><span data-stu-id="663b8-105">Concurrent Collection Classes</span></span>  
 <span data-ttu-id="663b8-106">Classes de la collection dans le <xref:System.Collections.Concurrent?displayProperty=nameWithType> espace de noms fournissent thread-safe ajouter et supprimer les opérations qui éviter autant que possible les verrous et utiliser le verrouillage de granularité fine là où les verrous sont nécessaires.</span><span class="sxs-lookup"><span data-stu-id="663b8-106">The collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace provide thread-safe add and remove operations that avoid locks wherever possible and use fine-grained locking where locks are necessary.</span></span> <span data-ttu-id="663b8-107">Contrairement aux regroupements qui ont été introduites dans les versions 1.0 et 2.0 du .NET Framework, une classe de collection simultanée ne nécessite pas de code utilisateur acquière des verrous lorsqu’il accède à des éléments.</span><span class="sxs-lookup"><span data-stu-id="663b8-107">Unlike collections that were introduced in the .NET Framework versions 1.0 and 2.0, a concurrent collection class does not require user code to take any locks when it accesses items.</span></span> <span data-ttu-id="663b8-108">Les classes de collection simultanée peuvent améliorer considérablement les performances des types tels que <xref:System.Collections.ArrayList?displayProperty=nameWithType> et <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (avec le verrouillage implémenté par l’utilisateur) dans les scénarios où plusieurs threads ajoutent et suppriment des éléments d’une collection.</span><span class="sxs-lookup"><span data-stu-id="663b8-108">The concurrent collection classes can significantly improve performance over types such as <xref:System.Collections.ArrayList?displayProperty=nameWithType> and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (with user-implemented locking) in scenarios where multiple threads add and remove items from a collection.</span></span>  
  
 <span data-ttu-id="663b8-109">Le tableau suivant répertorie les nouvelles classes de collection simultanée :</span><span class="sxs-lookup"><span data-stu-id="663b8-109">The following table lists the new concurrent collection classes:</span></span>  
  
|<span data-ttu-id="663b8-110">Type</span><span class="sxs-lookup"><span data-stu-id="663b8-110">Type</span></span>|<span data-ttu-id="663b8-111">Description</span><span class="sxs-lookup"><span data-stu-id="663b8-111">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType>|<span data-ttu-id="663b8-112">Fournit des fonctions bloquantes et englobantes pour les collections thread-safe qui implémentent <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="663b8-112">Provides blocking and bounding capabilities for thread-safe collections that implement <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="663b8-113">Threads producteurs se bloquent si aucun emplacement n’est disponible ou si la collection est complète.</span><span class="sxs-lookup"><span data-stu-id="663b8-113">Producer threads block if no slots are available or if the collection is full.</span></span> <span data-ttu-id="663b8-114">Threads de consommateur se bloquer si la collection est vide.</span><span class="sxs-lookup"><span data-stu-id="663b8-114">Consumer threads block if the collection is empty.</span></span> <span data-ttu-id="663b8-115">Ce type prend également en charge les accès non bloquant par les producteurs et consommateurs.</span><span class="sxs-lookup"><span data-stu-id="663b8-115">This type also supports non-blocking access by consumers and producers.</span></span> <span data-ttu-id="663b8-116"><xref:System.Collections.Concurrent.BlockingCollection%601>peut être utilisé comme classe de base ou magasin de stockage pour fournir bloquantes et englobantes pour les classes de collection qui prend en charge <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="663b8-116"><xref:System.Collections.Concurrent.BlockingCollection%601> can be used as a base class or backing store to provide blocking and bounding for any collection class that supports <xref:System.Collections.Generic.IEnumerable%601>.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>|<span data-ttu-id="663b8-117">Une implémentation de conteneur thread-safe qui fournit évolutive ajouter et obtenir des opérations.</span><span class="sxs-lookup"><span data-stu-id="663b8-117">A thread-safe bag implementation that provides scalable add and get operations.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType>|<span data-ttu-id="663b8-118">Un type de dictionnaire simultané et évolutif.</span><span class="sxs-lookup"><span data-stu-id="663b8-118">A concurrent and scalable dictionary type.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType>|<span data-ttu-id="663b8-119">Une file d’attente de FIFO simultanée et évolutive.</span><span class="sxs-lookup"><span data-stu-id="663b8-119">A concurrent and scalable FIFO queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType>|<span data-ttu-id="663b8-120">Pile LIFO simultanée et évolutive.</span><span class="sxs-lookup"><span data-stu-id="663b8-120">A concurrent and scalable LIFO stack.</span></span>|  
  
 <span data-ttu-id="663b8-121">Pour plus d’informations, consultez [Collections thread-safe](../../../docs/standard/collections/thread-safe/index.md).</span><span class="sxs-lookup"><span data-stu-id="663b8-121">For more information, see [Thread-Safe Collections](../../../docs/standard/collections/thread-safe/index.md).</span></span>  
  
## <a name="synchronization-primitives"></a><span data-ttu-id="663b8-122">Primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="663b8-122">Synchronization Primitives</span></span>  
 <span data-ttu-id="663b8-123">Les nouvelles primitives de synchronisation dans le <xref:System.Threading?displayProperty=nameWithType> espace de noms permettent affinée simultanéité et améliorer les performances en évitant les mécanismes de verrouillage coûteux trouvés dans le code multithread hérité.</span><span class="sxs-lookup"><span data-stu-id="663b8-123">The new synchronization primitives in the <xref:System.Threading?displayProperty=nameWithType> namespace enable fine-grained concurrency and faster performance by avoiding expensive locking mechanisms found in legacy multithreading code.</span></span> <span data-ttu-id="663b8-124">Certains des nouveaux types, tels que <xref:System.Threading.Barrier?displayProperty=nameWithType> et <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> ont pas d’équivalents dans les versions antérieures du .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="663b8-124">Some of the new types, such as <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> have no counterparts in earlier releases of the .NET Framework.</span></span>  
  
 <span data-ttu-id="663b8-125">Le tableau suivant répertorie les nouveaux types de synchronisation :</span><span class="sxs-lookup"><span data-stu-id="663b8-125">The following table lists the new synchronization types:</span></span>  
  
|<span data-ttu-id="663b8-126">Type</span><span class="sxs-lookup"><span data-stu-id="663b8-126">Type</span></span>|<span data-ttu-id="663b8-127">Description</span><span class="sxs-lookup"><span data-stu-id="663b8-127">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Threading.Barrier?displayProperty=nameWithType>|<span data-ttu-id="663b8-128">Permet à plusieurs threads fonctionner en parallèle sur un algorithme en fournissant un point auquel chaque tâche peut signaler son arrivée et bloquer ensuite jusqu'à ce que certaines ou toutes les tâches sont arrivés.</span><span class="sxs-lookup"><span data-stu-id="663b8-128">Enables multiple threads to work on an algorithm in parallel by providing a point at which each task can signal its arrival and then block until some or all tasks have arrived.</span></span> <span data-ttu-id="663b8-129">Pour plus d’informations, voir [Cloisonnement](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="663b8-129">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>|  
|<xref:System.Threading.CountdownEvent?displayProperty=nameWithType>|<span data-ttu-id="663b8-130">Simplifie les scénarios de bifurcation et de jointure en fournissant un mécanisme de rendez-vous facile.</span><span class="sxs-lookup"><span data-stu-id="663b8-130">Simplifies fork and join scenarios by providing an easy rendezvous mechanism.</span></span> <span data-ttu-id="663b8-131">Pour plus d’informations, consultez [CountdownEvent](../../../docs/standard/threading/countdownevent.md).</span><span class="sxs-lookup"><span data-stu-id="663b8-131">For more information, see [CountdownEvent](../../../docs/standard/threading/countdownevent.md).</span></span>|  
|<xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>|<span data-ttu-id="663b8-132">Une primitive de synchronisation similaire à <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="663b8-132">A synchronization primitive similar to <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span> <span data-ttu-id="663b8-133"><xref:System.Threading.ManualResetEventSlim>est léger mais peut être utilisé uniquement pour la communication intra-PROCEDE.</span><span class="sxs-lookup"><span data-stu-id="663b8-133"><xref:System.Threading.ManualResetEventSlim> is lighter-weight but can only be used for intra-process communication.</span></span> <span data-ttu-id="663b8-134">Pour plus d’informations, consultez [ManualResetEvent et ManualResetEventSlim](../../../docs/standard/threading/manualresetevent-and-manualreseteventslim.md).</span><span class="sxs-lookup"><span data-stu-id="663b8-134">For more information, see [ManualResetEvent and ManualResetEventSlim](../../../docs/standard/threading/manualresetevent-and-manualreseteventslim.md).</span></span>|  
|<xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>|<span data-ttu-id="663b8-135">Primitive de synchronisation qui limite le nombre de threads qui peuvent accéder simultanément à une ressource ou un pool de ressources.</span><span class="sxs-lookup"><span data-stu-id="663b8-135">A synchronization primitive that limits the number of threads that can concurrently access a resource or a pool of resources.</span></span> <span data-ttu-id="663b8-136">Pour plus d’informations, consultez [Semaphore et SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="663b8-136">For more information, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>|  
|<xref:System.Threading.SpinLock?displayProperty=nameWithType>|<span data-ttu-id="663b8-137">Une primitive de verrou d’exclusion mutuelle qui oblige le thread qui essaie d’acquérir le verrou peut attendre dans une boucle, ou *spin*, pour une période de temps avant de transmettre son quantum.</span><span class="sxs-lookup"><span data-stu-id="663b8-137">A mutual exclusion lock primitive that causes the thread that is trying to acquire the lock to wait in a loop, or *spin*, for a period of time before yielding its quantum.</span></span> <span data-ttu-id="663b8-138">Dans les scénarios où l’attente du verrou est censée être courte, <xref:System.Threading.SpinLock> offre de meilleures performances que les autres types de verrouillage.</span><span class="sxs-lookup"><span data-stu-id="663b8-138">In scenarios where the wait for the lock is expected to be short, <xref:System.Threading.SpinLock> offers better performance than other forms of locking.</span></span> <span data-ttu-id="663b8-139">Pour plus d’informations, consultez [SpinLock](../../../docs/standard/threading/spinlock.md).</span><span class="sxs-lookup"><span data-stu-id="663b8-139">For more information, see [SpinLock](../../../docs/standard/threading/spinlock.md).</span></span>|  
|<xref:System.Threading.SpinWait?displayProperty=nameWithType>|<span data-ttu-id="663b8-140">Un type petit et léger qui sera tourner pendant une période donnée et éventuellement mettre le thread dans un état d’attente si le nombre de sélection numérique est dépassé.</span><span class="sxs-lookup"><span data-stu-id="663b8-140">A small, lightweight type that will spin for a specified time and eventually put the thread into a wait state if the spin count is exceeded.</span></span>  <span data-ttu-id="663b8-141">Pour plus d’informations, consultez [SpinWait](../../../docs/standard/threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="663b8-141">For more information, see [SpinWait](../../../docs/standard/threading/spinwait.md).</span></span>|  
  
 <span data-ttu-id="663b8-142">Pour plus d'informations, voir :</span><span class="sxs-lookup"><span data-stu-id="663b8-142">For more information, see:</span></span>  
  
-   [<span data-ttu-id="663b8-143">Guide pratique pour utiliser le verrouillage SpinLock pour une synchronisation de bas niveau</span><span class="sxs-lookup"><span data-stu-id="663b8-143">How to: Use SpinLock for Low-Level Synchronization</span></span>](../../../docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)  
  
-   <span data-ttu-id="663b8-144">[Comment : synchroniser des opérations simultanées avec un objet Barrier](../../../docs/standard/threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).</span><span class="sxs-lookup"><span data-stu-id="663b8-144">[How to: Synchronize Concurrent Operations with a Barrier](../../../docs/standard/threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).</span></span>  
  
## <a name="lazy-initialization-classes"></a><span data-ttu-id="663b8-145">Classes d’initialisation tardive</span><span class="sxs-lookup"><span data-stu-id="663b8-145">Lazy Initialization Classes</span></span>  
 <span data-ttu-id="663b8-146">Avec l’initialisation tardive, la mémoire pour un objet n’est pas allouée jusqu'à ce qu’il est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="663b8-146">With lazy initialization, the memory for an object is not allocated until it is needed.</span></span> <span data-ttu-id="663b8-147">L’initialisation tardive peut améliorer les performances en répartissant les allocations d’objets uniformément sur la durée de vie d’un programme.</span><span class="sxs-lookup"><span data-stu-id="663b8-147">Lazy initialization can improve performance by spreading object allocations evenly across the lifetime of a program.</span></span> <span data-ttu-id="663b8-148">Vous pouvez activer l’initialisation tardive pour tout type personnalisé en encapsulant le type <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="663b8-148">You can enable lazy initialization for any custom type by wrapping the type <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="663b8-149">Le tableau suivant répertorie les types de l’initialisation tardive :</span><span class="sxs-lookup"><span data-stu-id="663b8-149">The following table lists the lazy initialization types:</span></span>  
  
|<span data-ttu-id="663b8-150">Type</span><span class="sxs-lookup"><span data-stu-id="663b8-150">Type</span></span>|<span data-ttu-id="663b8-151">Description</span><span class="sxs-lookup"><span data-stu-id="663b8-151">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601?displayProperty=nameWithType>|<span data-ttu-id="663b8-152">Fournit un léger, thread-safe à l’initialisation tardive.</span><span class="sxs-lookup"><span data-stu-id="663b8-152">Provides lightweight, thread-safe lazy-initialization.</span></span>|  
|<xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>|<span data-ttu-id="663b8-153">Fournit une valeur initialisée tardivement sur une base par thread, avec chaque thread appelant de façon tardive la fonction d’initialisation.</span><span class="sxs-lookup"><span data-stu-id="663b8-153">Provides a lazily-initialized value on a per-thread basis, with each thread lazily-invoking the initialization function.</span></span>|  
|<xref:System.Threading.LazyInitializer?displayProperty=nameWithType>|<span data-ttu-id="663b8-154">Fournit des méthodes statiques qui vous éviter d’avoir à allouer une instance dédiée de l’initialisation tardive.</span><span class="sxs-lookup"><span data-stu-id="663b8-154">Provides static methods that avoid the need to allocate a dedicated, lazy-initialization instance.</span></span> <span data-ttu-id="663b8-155">Au lieu de cela, ils permet de références pour vérifier cibles ont été initialisées lors de leur accès.</span><span class="sxs-lookup"><span data-stu-id="663b8-155">Instead, they use references to ensure targets have been initialized as they are accessed.</span></span>|  
  
 <span data-ttu-id="663b8-156">Pour plus d’informations, consultez [Initialisation tardive](../../../docs/framework/performance/lazy-initialization.md).</span><span class="sxs-lookup"><span data-stu-id="663b8-156">For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="aggregate-exceptions"></a><span data-ttu-id="663b8-157">Agréger des Exceptions</span><span class="sxs-lookup"><span data-stu-id="663b8-157">Aggregate Exceptions</span></span>  
 <span data-ttu-id="663b8-158">Le <xref:System.AggregateException?displayProperty=nameWithType> type peut être utilisé pour capturer plusieurs exceptions qui sont levées simultanément sur des threads séparés et les retournent au thread joint comme une exception.</span><span class="sxs-lookup"><span data-stu-id="663b8-158">The <xref:System.AggregateException?displayProperty=nameWithType> type can be used to capture multiple exceptions that are thrown concurrently on separate threads, and return them to the joining thread as a single exception.</span></span> <span data-ttu-id="663b8-159">Le <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> et <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> types et PLINQ utilisent <xref:System.AggregateException> largement à cet effet.</span><span class="sxs-lookup"><span data-stu-id="663b8-159">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> types and PLINQ use <xref:System.AggregateException> extensively for this purpose.</span></span> <span data-ttu-id="663b8-160">Pour plus d’informations, consultez [NIB : Comment : Handle Exceptions Thrown by Tasks](http://msdn.microsoft.com/en-us/d6c47ec8-9de9-4880-beb3-ff19ae51565d) et [Comment : gérer des Exceptions dans une requête PLINQ](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).</span><span class="sxs-lookup"><span data-stu-id="663b8-160">For more information, see [NIB: How to: Handle Exceptions Thrown by Tasks](http://msdn.microsoft.com/en-us/d6c47ec8-9de9-4880-beb3-ff19ae51565d) and [How to: Handle Exceptions in a PLINQ Query](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="663b8-161">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="663b8-161">See Also</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>  
 <xref:System.Threading?displayProperty=nameWithType>  
 [<span data-ttu-id="663b8-162">Programmation parallèle</span><span class="sxs-lookup"><span data-stu-id="663b8-162">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
