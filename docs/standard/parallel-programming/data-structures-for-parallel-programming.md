---
title: Structures de données pour la programmation parallèle
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- data structures, multi-threading
ms.assetid: bdc82f2f-4754-45a1-a81e-fe2e9c30cef9
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 6453e9983086dcb5b97ec134db9d74160d7a47cf
ms.sourcegitcommit: fb78d8abbdb87144a3872cf154930157090dd933
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/27/2018
ms.locfileid: "47399922"
---
# <a name="data-structures-for-parallel-programming"></a><span data-ttu-id="0e479-102">Structures de données pour la programmation parallèle</span><span class="sxs-lookup"><span data-stu-id="0e479-102">Data Structures for Parallel Programming</span></span>
<span data-ttu-id="0e479-103">La version 4 de .NET Framework introduit de nouveaux types très utiles pour la programmation parallèle, notamment un ensemble de classes de collections simultanées, des primitives de synchronisation légères et des types pour l’initialisation tardive.</span><span class="sxs-lookup"><span data-stu-id="0e479-103">The .NET Framework version 4 introduces several new types that are useful in parallel programming, including a set of concurrent collection classes, lightweight synchronization primitives, and types for lazy initialization.</span></span> <span data-ttu-id="0e479-104">Vous pouvez utiliser ces types avec n’importe quel code d’application multithread, y compris la bibliothèque parallèle de tâches et PLINQ.</span><span class="sxs-lookup"><span data-stu-id="0e479-104">You can use these types with any multithreaded application code, including the Task Parallel Library and PLINQ.</span></span>  
  
## <a name="concurrent-collection-classes"></a><span data-ttu-id="0e479-105">Classes de collections simultanées</span><span class="sxs-lookup"><span data-stu-id="0e479-105">Concurrent Collection Classes</span></span>  
 <span data-ttu-id="0e479-106">Les classes de collections de l’espace de noms <xref:System.Collections.Concurrent?displayProperty=nameWithType> fournissent des opérations d’ajout et de suppression thread-safe qui évitent autant que possible les verrous et, là où ils se révèlent nécessaires, utilisent un verrouillage de granularité fine.</span><span class="sxs-lookup"><span data-stu-id="0e479-106">The collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace provide thread-safe add and remove operations that avoid locks wherever possible and use fine-grained locking where locks are necessary.</span></span> <span data-ttu-id="0e479-107">Avec une classe de collections simultanées, contrairement aux collections introduites dans les versions 1.0 et 2.0 de .NET Framework, il n’est pas nécessaire que le code utilisateur prenne des verrous pour accéder aux éléments.</span><span class="sxs-lookup"><span data-stu-id="0e479-107">Unlike collections that were introduced in the .NET Framework versions 1.0 and 2.0, a concurrent collection class does not require user code to take any locks when it accesses items.</span></span> <span data-ttu-id="0e479-108">Les classes de collections simultanées peuvent améliorer considérablement les performances des types comme <xref:System.Collections.ArrayList?displayProperty=nameWithType> et <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (avec verrouillage implémenté par l’utilisateur) dans le cas où plusieurs threads ajoutent et suppriment des éléments d’une collection.</span><span class="sxs-lookup"><span data-stu-id="0e479-108">The concurrent collection classes can significantly improve performance over types such as <xref:System.Collections.ArrayList?displayProperty=nameWithType> and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (with user-implemented locking) in scenarios where multiple threads add and remove items from a collection.</span></span>  
  
 <span data-ttu-id="0e479-109">Le tableau suivant liste les classes de collections simultanées :</span><span class="sxs-lookup"><span data-stu-id="0e479-109">The following table lists the new concurrent collection classes:</span></span>  
  
|<span data-ttu-id="0e479-110">Type</span><span class="sxs-lookup"><span data-stu-id="0e479-110">Type</span></span>|<span data-ttu-id="0e479-111">Description</span><span class="sxs-lookup"><span data-stu-id="0e479-111">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType>|<span data-ttu-id="0e479-112">Fournit des fonctions bloquantes et englobantes pour les collections thread-safe qui implémentent <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0e479-112">Provides blocking and bounding capabilities for thread-safe collections that implement <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0e479-113">Les threads producteurs se bloquent si aucun emplacement n’est disponible ou que la collection est pleine.</span><span class="sxs-lookup"><span data-stu-id="0e479-113">Producer threads block if no slots are available or if the collection is full.</span></span> <span data-ttu-id="0e479-114">Les threads consommateurs se bloquent si la collection est vide.</span><span class="sxs-lookup"><span data-stu-id="0e479-114">Consumer threads block if the collection is empty.</span></span> <span data-ttu-id="0e479-115">Ce type prend également en charge l’accès non bloquant par les producteurs et les consommateurs.</span><span class="sxs-lookup"><span data-stu-id="0e479-115">This type also supports non-blocking access by consumers and producers.</span></span> <span data-ttu-id="0e479-116"><xref:System.Collections.Concurrent.BlockingCollection%601> peut être utilisé comme classe de base ou comme magasin de stockage pour assurer le blocage et la liaison des classes de collection qui prennent en charge <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="0e479-116"><xref:System.Collections.Concurrent.BlockingCollection%601> can be used as a base class or backing store to provide blocking and bounding for any collection class that supports <xref:System.Collections.Generic.IEnumerable%601>.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>|<span data-ttu-id="0e479-117">Implémentation de conteneur thread-safe qui effectue des opérations Add et Get évolutives.</span><span class="sxs-lookup"><span data-stu-id="0e479-117">A thread-safe bag implementation that provides scalable add and get operations.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType>|<span data-ttu-id="0e479-118">Type dictionnaire simultané et évolutif.</span><span class="sxs-lookup"><span data-stu-id="0e479-118">A concurrent and scalable dictionary type.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType>|<span data-ttu-id="0e479-119">File d’attente FIFO simultanée et évolutive.</span><span class="sxs-lookup"><span data-stu-id="0e479-119">A concurrent and scalable FIFO queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType>|<span data-ttu-id="0e479-120">Pile LIFO simultanée et évolutive.</span><span class="sxs-lookup"><span data-stu-id="0e479-120">A concurrent and scalable LIFO stack.</span></span>|  
  
 <span data-ttu-id="0e479-121">Pour plus d’informations, consultez [Collections thread-safe](../../../docs/standard/collections/thread-safe/index.md).</span><span class="sxs-lookup"><span data-stu-id="0e479-121">For more information, see [Thread-Safe Collections](../../../docs/standard/collections/thread-safe/index.md).</span></span>  
  
## <a name="synchronization-primitives"></a><span data-ttu-id="0e479-122">Primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="0e479-122">Synchronization Primitives</span></span>  
 <span data-ttu-id="0e479-123">Les nouvelles primitives de synchronisation de l’espace de noms <xref:System.Threading?displayProperty=nameWithType> affinent la concurrence et améliorent les performances en évitant les coûteux mécanismes de verrouillage du code multithread hérité.</span><span class="sxs-lookup"><span data-stu-id="0e479-123">The new synchronization primitives in the <xref:System.Threading?displayProperty=nameWithType> namespace enable fine-grained concurrency and faster performance by avoiding expensive locking mechanisms found in legacy multithreading code.</span></span> <span data-ttu-id="0e479-124">Certains des nouveaux types, par exemple, <xref:System.Threading.Barrier?displayProperty=nameWithType> et <xref:System.Threading.CountdownEvent?displayProperty=nameWithType>, ont pas d’équivalents dans les versions antérieures de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="0e479-124">Some of the new types, such as <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> have no counterparts in earlier releases of the .NET Framework.</span></span>  
  
 <span data-ttu-id="0e479-125">Le tableau suivant liste les nouveaux types de synchronisation :</span><span class="sxs-lookup"><span data-stu-id="0e479-125">The following table lists the new synchronization types:</span></span>  
  
|<span data-ttu-id="0e479-126">Type</span><span class="sxs-lookup"><span data-stu-id="0e479-126">Type</span></span>|<span data-ttu-id="0e479-127">Description</span><span class="sxs-lookup"><span data-stu-id="0e479-127">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Threading.Barrier?displayProperty=nameWithType>|<span data-ttu-id="0e479-128">Permet à plusieurs threads de fonctionner en parallèle sur un algorithme en fournissant un point auquel chaque tâche peut signaler son arrivée, puis se bloquer jusqu'à ce qu’une partie ou la totalité des tâches soient arrivées.</span><span class="sxs-lookup"><span data-stu-id="0e479-128">Enables multiple threads to work on an algorithm in parallel by providing a point at which each task can signal its arrival and then block until some or all tasks have arrived.</span></span> <span data-ttu-id="0e479-129">Pour plus d’informations, voir [Cloisonnement](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="0e479-129">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>|  
|<xref:System.Threading.CountdownEvent?displayProperty=nameWithType>|<span data-ttu-id="0e479-130">Simplifie les scénarios de duplication et de jointure en fournissant un mécanisme facile de réunion.</span><span class="sxs-lookup"><span data-stu-id="0e479-130">Simplifies fork and join scenarios by providing an easy rendezvous mechanism.</span></span> <span data-ttu-id="0e479-131">Pour plus d'informations, consultez la page [CountdownEvent](../../../docs/standard/threading/countdownevent.md).</span><span class="sxs-lookup"><span data-stu-id="0e479-131">For more information, see [CountdownEvent](../../../docs/standard/threading/countdownevent.md).</span></span>|  
|<xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>|<span data-ttu-id="0e479-132">Primitive de synchronisation similaire à <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0e479-132">A synchronization primitive similar to <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0e479-133"><xref:System.Threading.ManualResetEventSlim> est léger mais n’est utilisable que pour la communication intraprocessus.</span><span class="sxs-lookup"><span data-stu-id="0e479-133"><xref:System.Threading.ManualResetEventSlim> is lighter-weight but can only be used for intra-process communication.</span></span> <span data-ttu-id="0e479-134">Pour plus d’informations, consultez la page [ManualResetEvent et ManualResetEventSlim](../../../docs/standard/threading/manualresetevent-and-manualreseteventslim.md).</span><span class="sxs-lookup"><span data-stu-id="0e479-134">For more information, see [ManualResetEvent and ManualResetEventSlim](../../../docs/standard/threading/manualresetevent-and-manualreseteventslim.md).</span></span>|  
|<xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>|<span data-ttu-id="0e479-135">Primitive de synchronisation qui limite le nombre de threads pouvant accéder simultanément à une ressource ou à un pool de ressources.</span><span class="sxs-lookup"><span data-stu-id="0e479-135">A synchronization primitive that limits the number of threads that can concurrently access a resource or a pool of resources.</span></span> <span data-ttu-id="0e479-136">Pour plus d’informations, consultez la page [Semaphore et SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="0e479-136">For more information, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>|  
|<xref:System.Threading.SpinLock?displayProperty=nameWithType>|<span data-ttu-id="0e479-137">Primitive de verrou mutex obligeant le thread qui essaie d’acquérir le verrou à attendre dans une boucle ou à rester en *attente active* pendant un certain temps avant de transmettre son quantum.</span><span class="sxs-lookup"><span data-stu-id="0e479-137">A mutual exclusion lock primitive that causes the thread that is trying to acquire the lock to wait in a loop, or *spin*, for a period of time before yielding its quantum.</span></span> <span data-ttu-id="0e479-138">Dans les scénarios où l’attente du verrou est censée être courte, <xref:System.Threading.SpinLock> offre de meilleures performances que les autres types de verrouillage.</span><span class="sxs-lookup"><span data-stu-id="0e479-138">In scenarios where the wait for the lock is expected to be short, <xref:System.Threading.SpinLock> offers better performance than other forms of locking.</span></span> <span data-ttu-id="0e479-139">Pour plus d'informations, consultez la page [SpinLock](../../../docs/standard/threading/spinlock.md).</span><span class="sxs-lookup"><span data-stu-id="0e479-139">For more information, see [SpinLock](../../../docs/standard/threading/spinlock.md).</span></span>|  
|<xref:System.Threading.SpinWait?displayProperty=nameWithType>|<span data-ttu-id="0e479-140">Type petit et léger qui restera en attente active pendant un certain temps et mettra le thread dans un état d’attente si le nombre est dépassé.</span><span class="sxs-lookup"><span data-stu-id="0e479-140">A small, lightweight type that will spin for a specified time and eventually put the thread into a wait state if the spin count is exceeded.</span></span>  <span data-ttu-id="0e479-141">Pour plus d'informations, consultez la page [SpinWait](../../../docs/standard/threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="0e479-141">For more information, see [SpinWait](../../../docs/standard/threading/spinwait.md).</span></span>|  
  
 <span data-ttu-id="0e479-142">Pour plus d'informations, voir :</span><span class="sxs-lookup"><span data-stu-id="0e479-142">For more information, see:</span></span>  
  
-   [<span data-ttu-id="0e479-143">Guide pratique pour utiliser le verrouillage SpinLock pour une synchronisation de bas niveau</span><span class="sxs-lookup"><span data-stu-id="0e479-143">How to: Use SpinLock for Low-Level Synchronization</span></span>](../../../docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)  
  
-   <span data-ttu-id="0e479-144">[Guide pratique : Synchroniser des opérations simultanées avec un objet Barrier](../../../docs/standard/threading/how-to-synchronize-concurrent-operations-with-a-barrier.md)</span><span class="sxs-lookup"><span data-stu-id="0e479-144">[How to: Synchronize Concurrent Operations with a Barrier](../../../docs/standard/threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).</span></span>  
  
## <a name="lazy-initialization-classes"></a><span data-ttu-id="0e479-145">Classes d’initialisation tardive</span><span class="sxs-lookup"><span data-stu-id="0e479-145">Lazy Initialization Classes</span></span>  
 <span data-ttu-id="0e479-146">Avec l’initialisation tardive, la mémoire d’un objet n’est pas allouée tant qu’elle n’est pas nécessaire.</span><span class="sxs-lookup"><span data-stu-id="0e479-146">With lazy initialization, the memory for an object is not allocated until it is needed.</span></span> <span data-ttu-id="0e479-147">L’initialisation tardive peut améliorer les performances en répartissant uniformément les allocations d’objets sur toute la durée de vie d’un programme.</span><span class="sxs-lookup"><span data-stu-id="0e479-147">Lazy initialization can improve performance by spreading object allocations evenly across the lifetime of a program.</span></span> <span data-ttu-id="0e479-148">Vous pouvez l’activer sur n’importe quel type personnalisé en incluant le type <xref:System.Lazy%601> dans un wrapper.</span><span class="sxs-lookup"><span data-stu-id="0e479-148">You can enable lazy initialization for any custom type by wrapping the type <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="0e479-149">Le tableau suivant liste les nouveaux types d’initialisation tardive :</span><span class="sxs-lookup"><span data-stu-id="0e479-149">The following table lists the lazy initialization types:</span></span>  
  
|<span data-ttu-id="0e479-150">Type</span><span class="sxs-lookup"><span data-stu-id="0e479-150">Type</span></span>|<span data-ttu-id="0e479-151">Description</span><span class="sxs-lookup"><span data-stu-id="0e479-151">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601?displayProperty=nameWithType>|<span data-ttu-id="0e479-152">Assure une initialisation tardive légère et thread-safe.</span><span class="sxs-lookup"><span data-stu-id="0e479-152">Provides lightweight, thread-safe lazy-initialization.</span></span>|  
|<xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>|<span data-ttu-id="0e479-153">Fournit une valeur initialisée tardivement thread par thread, chacun appelant de façon tardive la fonction d’initialisation.</span><span class="sxs-lookup"><span data-stu-id="0e479-153">Provides a lazily-initialized value on a per-thread basis, with each thread lazily-invoking the initialization function.</span></span>|  
|<xref:System.Threading.LazyInitializer?displayProperty=nameWithType>|<span data-ttu-id="0e479-154">Fournit des méthodes statiques qui évitent d’avoir à allouer une instance dédiée d’initialisation tardive.</span><span class="sxs-lookup"><span data-stu-id="0e479-154">Provides static methods that avoid the need to allocate a dedicated, lazy-initialization instance.</span></span> <span data-ttu-id="0e479-155">Utilise plutôt des références pour vérifier que les cibles ont été initialisées lorsqu’elles sont consultées.</span><span class="sxs-lookup"><span data-stu-id="0e479-155">Instead, they use references to ensure targets have been initialized as they are accessed.</span></span>|  
  
 <span data-ttu-id="0e479-156">Pour plus d’informations, consultez [Initialisation tardive](../../../docs/framework/performance/lazy-initialization.md).</span><span class="sxs-lookup"><span data-stu-id="0e479-156">For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="aggregate-exceptions"></a><span data-ttu-id="0e479-157">Agréger des exceptions</span><span class="sxs-lookup"><span data-stu-id="0e479-157">Aggregate Exceptions</span></span>  
 <span data-ttu-id="0e479-158">Le type <xref:System.AggregateException?displayProperty=nameWithType> permet de capturer plusieurs exceptions levées simultanément sur des threads distincts, et de les retourner au thread de jonction comme une seule exception.</span><span class="sxs-lookup"><span data-stu-id="0e479-158">The <xref:System.AggregateException?displayProperty=nameWithType> type can be used to capture multiple exceptions that are thrown concurrently on separate threads, and return them to the joining thread as a single exception.</span></span> <span data-ttu-id="0e479-159">Les types <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> et <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> ainsi que PLINQ utilisent beaucoup <xref:System.AggregateException> pour cela.</span><span class="sxs-lookup"><span data-stu-id="0e479-159">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> types and PLINQ use <xref:System.AggregateException> extensively for this purpose.</span></span> <span data-ttu-id="0e479-160">Pour plus d’informations, consultez [Gestion des exceptions](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md) et [Comment gérer des exceptions dans une requête PLINQ](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).</span><span class="sxs-lookup"><span data-stu-id="0e479-160">For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md) and [How to: Handle Exceptions in a PLINQ Query](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0e479-161">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="0e479-161">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>  
- <xref:System.Threading?displayProperty=nameWithType>  
- [<span data-ttu-id="0e479-162">Programmation parallèle</span><span class="sxs-lookup"><span data-stu-id="0e479-162">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
