---
title: "Compatibilit&#233; d&#39;applications dans le .NET Framework&#160;4.5 | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-clr"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "Compatibilité des applications, .NET Framework"
  - "modifications avec rupture (.NET Framework)"
ms.assetid: 5c50747c-806c-44a9-ac58-5bbe12a284fa
caps.latest.revision: 76
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 76
---
# Compatibilit&#233; d&#39;applications dans le .NET Framework&#160;4.5
Cette rubrique décrit les problèmes de compatibilité des applications entre .NET Framework 4 et 4.5, y compris les correctifs et les modifications apportés en fonction des commentaires client. La plupart de ces modifications ne requièrent aucun changement dans la programmation de vos applications. Dans les cas où des changements s'avèrent nécessaires, consultez la colonne Impact des tableaux.  
  
> [!IMPORTANT]
>  Notez que [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] n'est pas pris en charge sur [!INCLUDE[winxp](../../../includes/winxp-md.md)].  
  
 Pour les problèmes de compatibilité entre .NET Framework 4.5 et 4.5.1, consultez [Compatibilité des applications dans la version 4.5.1](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5-1.md).  
  
 Cette rubrique décrit des modifications importantes dans les domaines suivants :  
  
-   [Principal](#core)  
  
-   [Données](#sql)  
  
-   [Réseau](#network)  
  
-   [Sérialisation](#serialize)  
  
-   [Impression](#Printing)  
  
-   [Outils et ressources](#tools)  
  
-   [ASP.NET](#asp)  
  
-   [ClickOnce](#ClickOnce)  
  
-   [Managed Extensibility Framework \(MEF\)](#mef)  
  
-   [Applications Web](#web)  
  
-   [Windows Communication Foundation \(WCF\)](#wcf)  
  
-   [Windows Forms](#winForms)  
  
-   [Windows Presentation Foundation \(WPF\)](#wpf)  
  
-   [Windows Workflow Foundation (WF)](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5.md#wwf)  
  
-   [XML, XSLT](#xml)  
  
 Cette rubrique ne traite pas des types et des membres qui ont été déclarés obsolètes dans [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Pour obtenir la liste de ces éléments, consultez [Éléments obsolètes dans la bibliothèque de classes](../../../docs/framework/whats-new/whats-obsolete.md). Pour plus d’informations sur les nouvelles fonctionnalités, consultez [Nouveautés](../../../docs/framework/whats-new/index.md).  
  
<a name="core"></a>   
## Principal  
 Outre les problèmes de compatibilité des applications ci\-après, consultez la section [Sérialisation](#serialize) pour connaître les problèmes liés à la sérialisation.  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|Méthodes [BlockingCollection\<T\>.TryTakeFromAny\(BlockingCollection\<T\>\<xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%28System.Collections.Concurrent.BlockingCollection%7B%600%7D%5B%5D%2C%600%40%29?displayProperty=fullName> et <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A?displayProperty=fullName>|La méthode [BlockingCollection\<T\>.TryTakeFromAny\(BlockingCollection\<T\>\<xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%28System.Collections.Concurrent.BlockingCollection%7B%600%7D%5B%5D%2C%600%40%29?displayProperty=fullName> ne retourne plus la valeur \-1 ou ne lève plus d'exception. La méthode <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A?displayProperty=fullName> ne lève plus d'exception si l'une des collections est marquée comme terminée.|Cette modification permet d'utiliser des collections lorsque l'une est vide ou terminée, alors que l'autre comporte toujours des éléments pouvant être récupérés.|  
|<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=fullName>|Si un assembly d'expressions régulières compilées est généré avec le [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] mais qu'il cible le [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], toute tentative d'utiliser l'une des expressions régulières dans cet assembly, sur un système sur lequel le [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] est installé, lève une exception.|Pour contourner ce problème, vous pouvez procéder de l'une des manières suivantes :<br /><br /> Générez l'assembly qui contient les expressions régulières avec le [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)].<br /><br /> Utilisez une expression régulière interprétée.|  
|Suppression de <xref:System.Threading.Tasks.Task?displayProperty=fullName>|À l'exception de `Task.IAsyncResult.AsyncWaitHandle`, les méthodes <xref:System.Threading.Tasks.Task?displayProperty=fullName> ne lèvent plus d'exception <xref:System.ObjectDisposedException> après la suppression de l'objet.|Cette modification prend en charge l'utilisation des tâches mises en cache. Par exemple, une méthode peut retourner une tâche mise en cache pour représenter une opération déjà terminée au lieu d'allouer une nouvelle tâche. Cette opération était impossible dans les versions précédentes du .NET Framework, car tout consommateur de la tâche pouvait la supprimer, ce qui la rendait inutilisable.|  
|Exceptions non prises en charge dans les opérations <xref:System.Threading.Tasks.Task?displayProperty=fullName>|Comme la classe <xref:System.Threading.Tasks.Task?displayProperty=fullName> représente une opération asynchrone, elle intercepte toutes les exceptions sans gravité qui se produisent pendant le traitement asynchrone. Dans [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], si une exception n'est pas prise en charge et si votre code n'attend jamais la tâche, l'exception ne se propagera plus sur le thread finaliseur et arrêtera le processus pendant l'opération garbage collection.|Cette modification améliore la fiabilité des applications qui utilisent la classe <xref:System.Threading.Tasks.Task> pour exécuter le traitement asynchrone non pris en charge. Le comportement précédent peut être restauré en fournissant un gestionnaire approprié pour l'événement <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=fullName>.|  
|Méthodes <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> avec des arguments de délai d'attente|Dans [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], ces méthodes se comportaient de manière incohérente. Lorsque le délai d'attente expirait, si une ou plusieurs tâches étaient terminées ou annulées avant l'appel de la méthode, la méthode levait une exception <xref:System.AggregateException>. Lorsque le délai d'attente expirait, si aucune tâche n'était terminée ou annulée avant l'appel de la méthode alors qu'une ou plusieurs tâches adoptaient ces états après l'appel de la méthode, la méthode retournait `false`.<br /><br /> Dans le [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], ces surcharges de méthode retournent désormais `false` si des tâches sont toujours en cours d'exécution quand l'intervalle de délai d'attente expire, et elles ne lèvent une exception <xref:System.AggregateException> que si une tâche d'entrée a été annulée \(que cette annulation soit intervenue avant ou après l'appel de méthode\) et qu'une autre tâche n'est en cours d'exécution.|Cette modification rend cohérent le comportement de la méthode. Toutefois, il est possible \(mais peu probable\) que le code d'application dépende des surcharges <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> soumises à un délai pour lever une exception lorsqu'au moins une tâche a déjà généré une erreur ou a été annulée avant l'expiration du délai. Dans ce cas, la propriété <xref:System.Threading.Tasks.Task.IsCanceled%2A?displayProperty=fullName> peut être utilisée à cet effet.|  
|Prise en charge du transfert de type lors du multiciblage|Une nouvelle fonctionnalité CodeDOM permet à un compilateur d'effectuer une compilation à l'aide de la version ciblée de mscorlib.dll au lieu de la version [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] de mscorlib.dll.|Cette modification empêche les avertissements du compilateur \(et l'échec de la compilation lorsque les avertissements sont traités comme des erreurs\) lorsque CodeDOM trouve deux définitions pour des types qui ont été transférés. Cette modification peut avoir des effets secondaires inattendus seulement si différentes versions des assemblys de référence sont combinées dans un emplacement unique.|  
|<xref:System.Collections.Generic.List%601.ForEach%2A?displayProperty=fullName>|L'énumérateur lève une exception <xref:System.InvalidOperationException> si un élément de la collection est modifié.|Cette modification s'applique uniquement aux applications qui ciblent [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] et ne doit pas avoir d'impact négatif. Elle sauvegarde l'intégrité des données et rend l'identification des conditions de concurrence plus probable.|  
|<xref:System.Uri?displayProperty=fullName>|Deux modifications apportées à l'analyse IRI \(Identifiant de ressource internationalisée\) affectent les URI dans les applications qui ciblent [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] :<br /><br /> L'élément [\<iriParsing\>](../../../docs/framework/configure-apps/file-schema/network/iriparsing-element-uri-settings.md) est activé par défaut et ne peut pas être désactivé. Auparavant, il était désactivé par défaut.<br /><br /> Le formulaire de normalisation Unicode C \(NFC\) ne sera plus appliqué aux parties non\-hôtes des URI. Auparavant, le formulaire NFC était appliqué sur l'ensemble de l'URI lorsque `<iriParsing>` était activé.|Les URI qui contiennent des noms de fichiers normalisés non NFC \(formulaire de normalisation C\) ne seront pas normalisés au moyen du formulaire C. L'application peut échouer si l'analyse IRI utilise des chaînes non normalisées pour accéder à des fichiers dotés de noms de fichiers normalisés. Cela affecte uniquement les applications qui ciblent [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|  
|<xref:System.Uri?displayProperty=fullName>|Une URL `mailto:` non valide lève une exception dans le constructeur de classe <xref:System.Uri>.|Cela affecte uniquement les applications qui sont recompilées et qui ciblent [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|  
|<xref:System.Uri?displayProperty=fullName>|Dans les applications qui ciblent [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], les points situés à la fin d'un segment de chemin d'accès dans une chaîne URI d'origine \(par exemple, `http://www.proseware.com/LLC./About.aspx`\) sont conservés. \(Notez que les segments de chemin d'accès qui se composent exactement d'un ou de deux points, tels que `http://www.proseware.com/..` ou `http://www.proseware.com/./default.htm`, sont supprimés, alors que les segments de chemin d'accès incluant plus de deux points consécutifs \(tels que `http://localhost/dir1/.../dir2`\) sont conservés.\)|Cette modification affecte uniquement les applications qui ciblent [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Les applications qui comptent sur la suppression des points de fin peuvent éventuellement échouer.|  
|<xref:System.Uri?displayProperty=fullName>|Dans les applications qui ciblent le [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], les requêtes incluses dans un URI `file://` sont autorisées ; le caractère ? n'est pas une séquence d'échappement car il est interprété comme faisant partie du chemin d'accès.|Cette modification affecte uniquement les applications qui ciblent [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Les applications qui comptent sur l'échappement du caractère ? peuvent éventuellement échouer.|  
|<xref:System.Uri?displayProperty=fullName>|Dans les applications qui ciblent [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], les caractères de contrôle Unicode de U\+0080 à U\+009F sont encodés de façon incorrecte.|Normalement, les caractères de contrôle Unicode ne sont pas utilisés dans les URI.|  
|<xref:System.Uri.EscapeDataString%2A?displayProperty=fullName>, <xref:System.Uri.EscapeUriString%2A?displayProperty=fullName> et <xref:System.Uri.UnescapeDataString%2A?displayProperty=fullName>|La liste des caractères réservés et non réservés prend désormais en charge la norme [RFC 3986](http://tools.ietf.org/html/rfc3986).|Modifications spécifiques :<br /><br /> <xref:System.Uri.EscapeDataString%2A> représente une séquence d'échappement pour les caractères réservés basés sur la norme RFC 3986.<br /><br /> <xref:System.Uri.EscapeUriString%2A> ne représente pas une séquence d'échappement pour les caractères réservés.<br /><br /> <xref:System.Uri.UnescapeDataString%2A> ne lève pas d'exception s'il rencontre une séquence d'échappement non valide.<br /><br /> Les caractères d'échappement non réservés sont sans séquence d'échappement.|  
|<xref:System.Uri.IsWellFormedUriString%2A?displayProperty=fullName>|À compter du .NET Framework 4.5, les chaînes sont toujours considérées comme correctement formées conformément à la [RFC 3986](http://tools.ietf.org/html/rfc3986) et à la [RFC 3987](http://tools.ietf.org/html/rfc3987). Dans les versions antérieures du .NET Framework, une chaîne est considérée comme correctement formée conformément à la RFC 3986 et à la RFC 3987 uniquement si l’analyse d’URI et l’analyse d’IDN sont activées.|Pour les applications qui ciblent le .NET Framework 4.5 ou versions ultérieures, cette méthode retourne `false` pour certains URI qui sont considérés comme correctement formés par les applications qui ciblent des versions antérieures du .NET Framework. Par exemple, un URI relatif comprenant un signe deux\-points dans son premier segment \(tel que « 2013.05.29\_14:33:41 »\) n’est plus considéré comme correctement formé.<br /><br /> Notez que cette modification affecte uniquement les applications qui ciblent le .NET Framework 4.5 ou versions ultérieures.|  
|<xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=fullName>|<xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=fullName> peut désormais accéder à la propriété <xref:System.IAsyncResult.CompletedSynchronously%2A?displayProperty=fullName>. Si <xref:System.IAsyncResult.CompletedSynchronously%2A?displayProperty=fullName> n’est pas correctement implémenté, les appels de méthode <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=fullName> peuvent présenter un comportement non défini.|La tâche résultante ne sera pas effectuée si l’implémentation de la propriété <xref:System.IAsyncResult.CompletedSynchronously%2A?displayProperty=fullName> retourne `true` de manière incorrecte.|  
  
<a name="sql"></a>   
## Données  
  
### SQLClient  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|Possibilité de se connecter à une base de données SQL Server à partir du code managé qui s'exécute sous [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|Le chemin d'accès de code API synchrone existant a été modifié pour ajouter la prise en charge asynchrone.|La présence de fournisseurs de service de base Microsoft Winsock BSP \(Base Service Provider\) ou de fournisseurs de service en couche non\-IFS peut interférer avec la capacité à se connecter à SQL Server. Pour plus d’informations, consultez l’article [L’API SetFileCompletionNotificationModes provoque le dysfonctionnement d’un port de terminaison E\/S avec une installation de fournisseur LSP non\-IFS](http://go.microsoft.com/fwlink/p/?LinkId=256032) sur le site web du support technique Microsoft.|  
|Type <xref:System.Data.SqlClient.SqlConnection?displayProperty=fullName>|Les connexions aux bases de données SQL Server 1997 ne sont plus prises en charge.|Les applications exécutées sous [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] ne peuvent pas se connecter aux bases de données SQL Server 1997.|  
|Type <xref:System.Data.SqlClient.SqlConnection?displayProperty=fullName>|Les connexions aux bases de données SQL Server à l'aide du protocole VIA \(Virtual Interface Adapter\) ne sont plus prises en charge.|Les applications exécutées sous [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] ne peuvent pas se connecter aux bases de données SQL Server à l'aide du protocole VIA.|  
|Type <xref:System.Data.SqlClient.SqlBulkCopy?displayProperty=fullName>|Lors de l'insertion de données dans une colonne, <xref:System.Data.SqlClient.SqlBulkCopy> utilise l'encodage de la colonne de destination plutôt que l'encodage par défaut pour les types `VARCHAR` et `CHAR`.|Cette modification élimine la possibilité d'altération de données provoquée par l'utilisation de l'encodage par défaut lorsque la colonne de destination n'utilise pas l'encodage par défaut. Dans de rares cas, une application existante peut lever une exception <xref:System.Data.SqlClient.SqlException> si la modification de l'encodage produit des données qui sont trop volumineuses pour s'insérer dans la colonne de destination.|  
|Séquence de classement <xref:System.Data.SqlClient?displayProperty=fullName>|Les données `sql_variant` utilisent le classement `sql_variant` plutôt que le classement de la base de données.|Cette modification permet de répondre à une éventuelle altération de données si le classement de la base de données est différent du classement `sql_variant`. Les applications qui s'appuient sur les données endommagées peuvent éventuellement échouer.|  
  
### Entity Framework  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|Fichiers journaux créés par la méthode <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A?displayProperty=fullName>|Lorsque la méthode <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> est appelée directement ou en utilisant Code First avec le fournisseur SqlClient et une valeur `AttachDBFilename` dans la chaîne de connexion, elle crée un fichier journal nommé *nom\_fichier*\_log.ldf au lieu de *nom\_fichier*.ldf \(où *nom\_fichier* est le nom du fichier spécifié par la valeur `AttachDBFilename`\).|Cette modification améliore le débogage en fournissant un fichier journal dont le nom répond aux spécifications SQL Server. Elle ne devrait pas avoir d'effets secondaires inattendus.|  
|API DDL \(Data Definition Language\)|Le comportement des API DDL lorsque `AttachDBFilename` est spécifié a été modifié comme suit :<br /><br /> Les chaînes de connexion n'ont pas besoin de spécifier de valeur `Initial Catalog`. Auparavant, les valeurs `AttatchDBFilename` et `Initial Catalog` étaient requises.<br /><br /> Si `AttatchDBFilename` et `Initial Catalog` sont spécifiés et si le fichier MDF donné existe, la méthode <xref:System.Data.Objects.ObjectContext.DatabaseExists%2A?displayProperty=fullName> retourne `true`. Auparavant, elle retournait `false`.<br /><br /> Si `AttatchDBFilename` et `Initial Catalog` sont spécifiés et si le fichier MDF donné existe, un appel à la méthode <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> supprime les fichiers.<br /><br /> Si la méthode <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> est appelée lorsque la chaîne de connexion spécifie une valeur `AttachDBFilename` avec un MDF et une valeur `Initial Catalog` qui n'existent pas, la méthode lève une exception <xref:System.InvalidOperationException>. Auparavant, elle levait une exception <xref:System.Data.SqlClient.SqlException>.|Ces modifications facilitent la création d'outils et d'applications qui utilisent les API DDL. Elles peuvent avoir une incidence sur la compatibilité des applications dans les scénarios suivants :<br /><br /> L'utilisateur rédige du code qui exécute une commande `DROP DATABASE` directement au lieu d'appeler <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> si <xref:System.Data.Objects.ObjectContext.DatabaseExists%2A?displayProperty=fullName> retourne `true`. Ce comportement altère le code existant si la base de données n'est pas liée mais que le fichier MDF existe.<br /><br /> L'utilisateur rédige du code qui attend de la méthode <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> qu'elle lève une exception <xref:System.Data.SqlClient.SqlException> plutôt qu'une exception <xref:System.InvalidOperationException> lorsque la valeur `Initial Catalog` et le fichier MDF n'existent pas.|  
|Méthodes <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A?displayProperty=fullName> et <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A?displayProperty=fullName>|Si la création des objets de base de données échoue après qu'une base de données vide a été créée, la méthode tente d'annuler la création de la base de données et propage l'exception <xref:System.Data.SqlClient.SqlException> d'origine. Si la tentative d'annulation de la base de données échoue, la méthode lève une exception <xref:System.InvalidOperationException>.|Cette modification empêche la création d'une base de données vide et inutilisable. La gestion des exceptions peut changer en partie, car la suppression réussie de la base de données propage désormais l'exception <xref:System.Data.SqlClient.SqlException> d'origine.|  
|Méthodes <xref:System.Data.Objects.ObjectContext.Translate%2A?displayProperty=fullName> et <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A?displayProperty=fullName>|Si `T` est un type d'énumération, la méthode retourne correctement les données de la base de données.  Auparavant, les types d'énumération n'étaient pas pris en charge, si bien que le résultat était toujours casté vers zéro ou converti vers le type d'énumération. Les types sous\-jacents qui ne sont pas pris en charge par Entity Framework, tels que <xref:System.UInt16>, <xref:System.UInt32> et <xref:System.UInt64>, retournent encore zéro ou sont convertis vers le type d'énumération avec une valeur sous\-jacente égale à zéro.|La prise en charge des énumérations est une nouveauté d'Entity Framework dans [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Toutefois, si le code du développeur dépend du fait que le résultat soit égal à zéro, cela peut entraîner une erreur d'application, en fonction du code spécifique.|  
  
### LINQ  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|Méthode <xref:System.Linq.Enumerable.Empty%2A?displayProperty=fullName>|La méthode retourne une instance interne mise en cache au lieu de retourner un nouveau type <xref:System.Collections.Generic.IEnumerable%601>.|Cette modification entraîne une amélioration des performances. Toutefois, le code qui dépend de l'obtention de deux types vides uniques à partir de plusieurs appels à <xref:System.Linq.Enumerable.Empty%2A?displayProperty=fullName> échoue.|  
  
<a name="network"></a>   
## Réseau  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|Types et membres de l'espace de noms <xref:System.Net.PeerToPeer.Collaboration?displayProperty=fullName>|Les types et les membres ne sont pas pris en charge sur [!INCLUDE[win8](../../../includes/win8-md.md)]. Tenter de les appeler lève une exception <xref:System.PlatformNotSupportedException>.|Les applications ne peuvent plus utiliser ces types et membres sur [!INCLUDE[win8](../../../includes/win8-md.md)].|  
|Sérialisation et désérialisation des objets <xref:System.Net.Mail.MailMessage>.|Dans le .NET Framework 4.5, les e\-mails peuvent inclure des caractères non\-ASCII. Dans le .NET Framework 4, seuls les caractères ASCII sont pris en charge.|Les objets <xref:System.Net.Mail.MailMessage> qui contiennent des caractères non\-ASCII et qui sont sérialisés sous le .NET Framework 4.5 ne peuvent pas être désérialisés sous le .NET Framework 4.|  
  
<a name="Printing"></a>   
## Impression  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|<xref:System.Printing.PrintSystemJobInfo.JobStream%2A?displayProperty=fullName>|Cette propriété expose le flux d’une tâche d’impression et autorise l’utilisateur à envoyer des données brutes aux composants d’impression du système d’exploitation sous\-jacent en écrivant dans ce flux.<br /><br /> À compter de .NET Framework 4.5 sur Windows 8 et les versions ultérieures du système d’exploitation Windows, les données écrites dans ce flux doivent être au format XPS en tant que flux de package.|Pour sortir le contenu d’impression, vous pouvez procéder de l’une des manières suivantes :<br /><br /> Utilisez la classe <xref:System.Windows.Xps.XpsDocumentWriter> pour sortir le contenu d’impression. Il s’agit de l’alternative recommandée.<br /><br /> Vérifiez que les données envoyées au flux retourné par la propriété <xref:System.Printing.PrintSystemJobInfo.JobStream%2A?displayProperty=fullName> sont au format XPS en tant que flux de package.|  
  
<a name="serialize"></a>   
## Sérialisation  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|Sérialisation avec la classe <xref:System.Xml.Serialization.XmlSerializer>|Dans WCF 4.5, la classe <xref:System.Xml.Serialization.XmlSerializer> a été optimisée pour supprimer sa dépendance vis\-à\-vis du compilateur C\#. Ce changement offre des gains de performances significatifs pour les scénarios de démarrage à froid.|Il peut engendrer des problèmes dans le code de sérialisation XML qui a été compilé dans WCF 4 mais qui s’exécute par rapport à WCF 4.5. Si vous rencontrez des problèmes d’exécution de votre code de sérialisation XML existant dans WCF 4.5, utilisez l’élément de configuration suivant pour rétablir le comportement de XmlSerializer dans WCF 4 :<br /><br /> `<configuration>    <system.xml.serialization>    <xmlSerializer useLegacySerializerGeneration="true"/>    </system.xml.serialization> </configuration>`|  
|Sérialisation et désérialisation avec la classe <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter?displayProperty=fullName>|La sérialisation à l'aide de <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> peut encoder l'état interne d'un objet, qui n'est pas nécessairement le même entre différentes versions du .NET Framework.  En cas de divergence, la désérialisation d'un contenu sérialisé dans une version du .NET Framework peut échouer sur d'autres.|La classe <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> ne garantit pas la compatibilité entre les versions. Utilisez les classes <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter?displayProperty=fullName> et <xref:System.Runtime.Serialization.NetDataContractSerializer?displayProperty=fullName> à la place.|  
  
<a name="tools"></a>   
## Outils et ressources  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|MSBuild|Si vous exécutez MSBuild à partir d'une invite de commandes, celui\-ci respectera les fichiers de configuration de solution qui désactivent les builds de projets particuliers.|MSBuild se comporte de manière identique lorsqu'il est appelé par Visual Studio et lorsqu'il est exécuté à partir d'une invite de commandes. Vous n'avez pas besoin de créer de solutions distinctes ni de supprimer des projets d'une solution pour générer un sous\-ensemble de projets dans une solution.|  
|MSBuild|La propriété `TreatAsLocalProperty` dans les fichiers projet MSBuild empêche des propriétés spécifiques, y compris la propriété `OutDir`, d'être substituées à un niveau global.|Les substitutions de la propriété `OutDir` peuvent provoquer un arrêt potentiel si `OutDir` est une propriété globale qui est remplacée une fois le fichier MS.Common.Targets importé.|  
|Rapport d'erreurs Windows : compartiments Watson|Les incidents gérés sont regroupés en catégories en fonction d'un certain nombre de critères, dont la version d'assembly. Dans [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], la version de fichier est utilisée à la place de la version d'assembly.|Dans la mesure où la version d'assembly change uniquement entre les versions principales, le recours à la version du fichier au lieu de la version d'assembly comme catégorie permet de déterminer la version spécifique d'un assembly impliqué dans un incident géré.|  
|MSBuild|Les données des projets compris dans la collection <xref:Microsoft.Build.Evaluation.ProjectCollection?displayProperty=fullName> ne sont pas automatiquement récupérées par le garbage collector.|Si vous chargez explicitement des projets dans la collection <xref:Microsoft.Build.Evaluation.ProjectCollection>, vous devez appeler la méthode <xref:Microsoft.Build.Evaluation.ProjectCollection.UnloadProject%28Microsoft.Build.Evaluation.Project%29> pour chaque membre de la collection.|  
  
<a name="asp"></a>   
## ASP.NET  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|Outil d'inscription IIS ASP.NET \(aspnet\_regiis.exe\)|Dans [!INCLUDE[win8](../../../includes/win8-md.md)], les options `–i` et `–u` pour installer et désinstaller ASP.NET ne sont pas prises en charge.|Pour installer ou désinstaller ASP.NET 4.5 avec IIS 8, utilisez la boîte de dialogue **Activer ou désactiver des fonctionnalités Windows**, l'outil de gestion des serveurs ou l'outil en ligne de commande `dism.exe`.|  
|Contrôle <xref:System.Web.UI.WebControls.EntityDataSource?displayProperty=fullName>|L'événement <xref:System.Web.UI.Page.LoadComplete?displayProperty=fullName> ne force plus le contrôle <xref:System.Web.UI.WebControls.EntityDataSource?displayProperty=fullName> à appeler une liaison de données pour les modifications dans le but de créer\/mettre à jour\/supprimer des paramètres.|Cette modification supprime un aller\-retour superflu vers la base de données, empêche la réinitialisation des valeurs des contrôles et produit un comportement cohérent avec les autres contrôles de données, tels que <xref:System.Web.UI.WebControls.SqlDataSource> et <xref:System.Web.UI.WebControls.ObjectDataSource>. Elle produit un comportement différent dans le cas peu probable où les applications dépendraient de l'appel de la liaison de données dans l'événement <xref:System.Web.UI.Page.LoadComplete?displayProperty=fullName>.|  
|Méthodes <xref:System.Net.WebUtility.HtmlDecode%2A?displayProperty=fullName>, <xref:System.Net.WebUtility.UrlDecode%2A?displayProperty=fullName> et [System.Web.Helpers.Json.Decode](https://msdn.microsoft.com/library/system.web.helpers.json.decode.aspx)|Par défaut, les méthodes de décodage ne décodent plus une séquence d'entrée non valide en une chaîne UTF\-16 non valide. Au lieu de cela, elles retournent l'entrée d'origine.|Le changement lié à la sortie du décodeur doit importer uniquement si vous stockez des données binaires à la place de données UTF\-16 dans les chaînes. Pour contrôler explicitement ce comportement, affectez à l'attribut `aspnet:AllowRelaxedUnicodeDecoding` de l'élément [\<appSettings\>](http://msdn.microsoft.com/fr-fr/0d65a3f1-c522-423d-89b6-44921b6daebb) la valeur `true` pour activer le comportement hérité ou la valeur `false` pour activer le comportement actuel.|  
|Méthode <xref:System.Net.WebUtility.HtmlEncode%2A?displayProperty=fullName>|Pour les applications qui ciblent [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], les caractères extérieurs au plan BMP \(Basic Multilingual Plane\) effectuent un aller\-retour correct lorsqu'ils sont transmis à la méthode <xref:System.Net.WebUtility.HtmlDecode%2A?displayProperty=fullName>.|Cette modification ne doit avoir aucun effet sur les applications actuelles. Pour rétablir le comportement d’origine, affectez à l’attribut `targetFramework` de l’élément [\<httpRuntime\>](http://msdn.microsoft.com/library/e1f13641\(v=vs.100\).aspx) la valeur d’une chaîne autre que « 4.5 ». Vous pouvez également définir les attributs `unicodeEncodingConformance` et `unicodeDecodingConformance` de l'élément de configuration `<webUtility>` pour contrôler ce comportement indépendamment de la version ciblée du .NET Framework.|  
|Propriété <xref:System.Web.HttpRequest.ContentEncoding%2A?displayProperty=fullName>|L'encodage UTF\-7 est interdit.|Les données des applications qui dépendent des données UTF\-7 entrantes ne seront pas décodées correctement dans certains cas. Cela doit être rare, mais vous pouvez restaurer le comportement hérité en utilisant l'attribut `aspnet:AllowUtf7RequestContentEncoding` de l'élément [\<appSettings\>](http://msdn.microsoft.com/fr-fr/0d65a3f1-c522-423d-89b6-44921b6daebb).|  
|<xref:System.Web.HttpUtility.JavaScriptStringEncode%2A?displayProperty=fullName>|Depuis le [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], la méthode place le caractère & \(et commercial\) dans une séquence d'échappement.|Si votre application dépend du comportement précédent de cette méthode, vous pouvez ajouter un paramètre `aspnet:JavaScriptDoNotEncodeAmpersand` à l'[élément appSettings ASP.NET](http://msdn.microsoft.com/fr-fr/bb60e711-0669-4118-a54d-8dd71e009a00) dans votre fichier de configuration.|  
|Méthodes <xref:System.Web.Security.MachineKey.Encode%2A?displayProperty=fullName> et <xref:System.Web.Security.MachineKey.Decode%2A?displayProperty=fullName>|Ces méthodes sont désormais obsolètes.|La compilation du code qui appelle ces méthodes génère un avertissement du compilateur. Les alternatives recommandées sont <xref:System.Web.Security.MachineKey.Protect%2A?displayProperty=fullName> et <xref:System.Web.Security.MachineKey.Unprotect%2A?displayProperty=fullName>.|  
  
<a name="ClickOnce"></a>   
## ClickOnce  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|Applications publiées avec ClickOnce, et qui utilisent un certificat de signature de code SHA\-256.|L'exécutable est signé avec SHA256. Auparavant, il était signé avec SHA1, que le certificat de signature du code ait été SHA\-1 ou SHA\-256. Cela s'applique à :<br /><br /> toutes les applications générées avec Visual Studio 2012 ou une version ultérieure ;<br /><br /> toutes les applications générées avec Visual Studio 2010 \(ou version antérieure\) en présence de .NET Framework 4.5.<br /><br /> En outre, si .NET Framework 4.5 \(ou une version ultérieure\) est présent, le manifeste ClickOnce est également signé avec SHA\-256 pour les certificats SHA\-256, quelle que soit la version du .NET Framework sur laquelle il a été compilé.|Le changement de signature de l’exécutable ClickOnce affecte uniquement les systèmes Windows Server 2003. Le correctif logiciel [KB 938397](http://support.microsoft.com/kb/938397) doit être installé.<br /><br /> Le changement de signature du manifeste avec l’algorithme SHA\-256 même quand une application cible le .NET Framework 4 ou des versions antérieures présente une dépendance de runtime envers le .NET Framework 4.5 ou version ultérieure. Ce problème est résolu dans Visual Studio 2013 Update 3 et dans [!INCLUDE[net_v46](../../../includes/net-v46-md.md)]. Pour la résolution de [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], consultez [Modifications du runtime](../../../docs/framework/migration-guide/runtime-changes-in-the-net-framework-4-6.md).|  
  
<a name="mef"></a>   
## Managed Extensibility Framework \(MEF\)  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|<xref:System.ComponentModel.Composition.Primitives.ComposablePartCatalog?displayProperty=fullName> et ses classes dérivées|Depuis [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], les catalogues MEF implémentent <xref:System.Collections.IEnumerable> et ne peuvent donc plus être utilisés pour créer un sérialiseur \(objet <xref:System.Xml.Serialization.XmlSerializer>\).|La tentative de sérialisation d'un catalogue MEF lève une exception.|  
  
<a name="web"></a>   
## Applications Web  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|Contrôles d'hébergement du navigateur géré depuis .NET Framework 1.1 et 2.0|L'hébergement de ces contrôles est bloqué dans Internet Explorer.|Internet Explorer ne démarrera pas les applications qui utilisent des contrôles d'hébergement de navigateur géré. Le comportement précédent peut être restauré en affectant 1 à la valeur EnableIEHosting de la sous\-clé de Registre HKLM\/SOFTWARE\/MICROSOFT\/.NETFramework pour les systèmes x86 et pour les processus 32 bits sur les systèmes x64, et en affectant 1 à la valeur EnableIEHosting de la sous\-clé de Registre HKLM\/SOFTWARE\/Wow6432Node\/Microsoft\/.NETFramework pour les processus 64 bits sur les systèmes x64.|  
  
<a name="wcf"></a>   
## Windows Communication Foundation \(WCF\)  
 Outre les problèmes de compatibilité des applications ci\-après, consultez la section [Sérialisation](#serialize) pour connaître les problèmes liés à la sérialisation.  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|Messages dans les services web WCF hébergés dans les services Internet \(IIS\) ou sur le serveur de développement ASP.NET qui dépassent `maxRequestLength` \(dans ASP.NET\) ou `maxReceivedMessageSize` \(dans WCF\)|Le code d'état HTTP est passé de 400 \(Demande incorrecte\) à 413 \(Entité de demande trop grande\), et les messages qui dépassent le paramètre `maxRequestLength` ou `maxReceivedMessageSize` lèvent une exception <xref:System.ServiceModel.ProtocolException>. Cela inclut les cas dans lesquels le mode de transfert est <xref:System.ServiceModel.TransferMode>.|Cette modification facilite le débogage dans les cas où la longueur du message dépasse les limites autorisées par ASP.NET ou WCF.<br /><br /> Vous devez modifier tout code qui effectue un traitement en fonction d'un code d'état HTTP 400.|  
|`Replace` dans les URL OData|La méthode `Replace` dans les URL OData est désactivée par défaut.|Si OData `Replace` est désactivé \(désormais par défaut\), la demande de l'utilisateur lèvera une exception et échouera.|  
|<xref:System.ServiceModel.Web.WebServiceHost?displayProperty=fullName>|L'objet <xref:System.ServiceModel.Web.WebServiceHost?displayProperty=fullName> n'ajoute plus de point de terminaison par défaut si un point de terminaison explicite a été ajouté par le code de l'application.|Si une application cliente tente de se connecter à un point de terminaison qui n'est plus ajouté par défaut, une erreur HTTP est générée.|  
  
<a name="winForms"></a>   
## Windows Forms  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|System.Drawing.dll|La propriété `CheckForOverflowUnderflow` de l'assembly a la valeur `true`.|Auparavant, en cas de dépassement de capacité, le résultat était tronqué automatiquement. Désormais, une exception <xref:System.OverflowException> est levée.|  
|Constructeur <xref:System.Drawing.Imaging.EncoderParameter.%23ctor%28System.Drawing.Imaging.Encoder%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName>|Le constructeur a été déconseillé.|Le constructeur ne fonctionne pas sur les systèmes 64 bits. Utilisez le constructeur <xref:System.Drawing.Imaging.EncoderParameter.%23ctor%28System.Drawing.Imaging.Encoder%2CSystem.Int32%2CSystem.Drawing.Imaging.EncoderParameterValueType%2CSystem.IntPtr%29?displayProperty=fullName> à la place.|  
  
<a name="wpf"></a>   
## Windows Presentation Foundation \(WPF\)  
 Outre les problèmes de compatibilité des applications ci\-après, consultez la section [Sérialisation](#serialize) pour connaître les problèmes liés à la sérialisation.  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|Propriété <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A?displayProperty=fullName>|La limite par défaut du nombre maximal d'opérations d'annulation pour les classes <xref:System.Windows.Controls.TextBox> et <xref:System.Windows.Controls.RichTextBox> est passée de \-1 \(aucune limite\) à 100.|Cette modification ne doit pas avoir d'impact négatif. Toutefois, vous pouvez définir explicitement la propriété <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A> après avoir instancié le contrôle.|  
|Énumération <xref:System.Windows.Controls.PageRangeSelection?displayProperty=fullName>|Les membres <xref:System.Windows.Controls.PageRangeSelection> et <xref:System.Windows.Controls.PageRangeSelection> ont été ajoutés à l'énumération.|Cette modification ne doit pas avoir d'impact sur les applications existantes. La valeur par défaut est <xref:System.Windows.Controls.PageRangeSelection?displayProperty=fullName> pour les membres existants qui utilisent cette énumération.|  
|éléments <xref:System.Windows.DataTemplate> ;|Les éléments <xref:System.Windows.DataTemplate> apparaissent désormais dans l'affichage de contrôle de l'arborescence UI Automation \(UIA\).|Cette modification améliore l'accessibilité. Toutefois, elle affecte les outils de test qui s'appuient sur la structure précédente de l'arborescence UIA pour localiser les éléments voisins.|  
|Synchronisation de la propriété <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=fullName> et de la propriété à laquelle elle est associée|Dans certains cas, la propriété <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=fullName> reflète une valeur précédente de la propriété liée aux données si cette propriété est modifiée au cours d'une opération d'écriture de liaison de données.|Cela ne doit pas avoir d'impact négatif. Vous pouvez, cependant, restaurer le comportement précédent en affectant à la propriété <xref:System.Windows.FrameworkCompatibilityPreferences.KeepTextBoxDisplaySynchronizedWithTextProperty%2A?displayProperty=fullName> la valeur `false`.|  
|Propriété <xref:System.Windows.Controls.TextBox?displayProperty=fullName>|Lorsqu'un contrôle <xref:System.Windows.Controls.TextBox?displayProperty=fullName> est inactif, le texte sélectionné dans la zone s'affiche dans une couleur différente de celle utilisée lorsque la zone de texte est active.|Vous pouvez restaurer le comportement précédent en affectant à la propriété <xref:System.Windows.FrameworkCompatibilityPreferences.AreInactiveSelectionHighlightBrushKeysSupported%2A?displayProperty=fullName> la valeur `false`.|  
|<xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>|Si un contrôle dérivé <xref:System.Windows.Controls.Primitives.MultiSelector> dont la propriété <xref:System.Windows.Controls.Primitives.MultiSelector.CanSelectMultipleItems%2A> a la valeur `true` a des doublons dans sa collection <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>, les éléments dupliqués apparaissent plusieurs fois. La suppression de ces éléments de la source de données \(par exemple en appelant `Items.Clear`\) n’entraîne pas leur suppression de la collection <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>. Seule la première instance est supprimée.<br /><br /> L’utilisation ultérieure de la collection <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>, tel qu’un appel à `SelectedItems.Clear`,  peut rencontrer des problèmes \(par exemple une exception <xref:System.ArgumentException>\), car la collection <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName> contient des éléments qui ne sont plus dans la source de données.|Ce problème a été résolu dans le [!INCLUDE[net_v462](../../../includes/net-v462-md.md)]. Si une collection <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName> comporte des éléments en double, que vous les supprimez de la source de données et que vous souhaitez continuer à travailler avec la collection <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>, effectuez une mise à niveau vers le [!INCLUDE[net_v462](../../../includes/net-v462-md.md)].|  
|<xref:System.Windows.Threading.DispatcherSynchronizationContext.CreateCopy%2A?displayProperty=fullName>|Dans [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], la méthode retourne une référence à l'instance actuelle. Dans [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], elle retourne une nouvelle instance.|Le code qui suppose que des références égales indiquent que le thread d'exécution est dans le contexte approprié s'exécutera désormais correctement. Toutefois, en raison de la modification, le code qui appelle la méthode <xref:System.Windows.Threading.DispatcherSynchronizationContext.CreateCopy%2A?displayProperty=fullName> doit être testé.|  
|Analyse des messages `WM_POWERBROADCAST` en utilisant un gestionnaire ajouté par l'appel de la méthode <xref:System.Windows.Interop.HwndSource.AddHook%2A?displayProperty=fullName>.|Une fenêtre doit s’inscrire explicitement aux notifications `WM_POWERBROADCAST` en passant son handle à la fonction [RegisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373196.aspx). Via le [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], WPF l'a fait automatiquement pour toutes les fenêtres. Depuis le [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], WPF inscrit automatiquement une fenêtre particulière, mais n'inscrit pas automatiquement la plupart des fenêtres d'application.|Le code qui gère les notifications `WM_POWERBROADCAST` ne s'exécute pas.<br /><br /> Pour continuer à recevoir des notifications `WM_POWERBROADCAST`, appelez la fonction [RegisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373196.aspx) pour inscrire une fenêtre WPF \(en général, la fenêtre d’application principale\) aux notifications `WM_POWERBROADCAST`. Dans les applications WPF que vous développez avec C\#, cela requiert également que vous cochiez la case **Autoriser du code unsafe** sous l'onglet **Générer** des propriétés du projet.<br /><br /> De plus, si vous inscrivez une fenêtre qui n’est pas persistante jusqu’à l’arrêt de l’application, vous devez annuler son inscription en appelant la fonction [UnregisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373237.aspx) et en lui passant le handle `HPOWERNOTIFY` retourné par l’appel à la fonction [RegisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373196.aspx).|  
  
<a name="wwf"></a>   
## Windows Workflow Foundation \(WF\)  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|Sécurité System.Activities.dll|L’assembly est marqué avec l’attribut <xref:System.Security.AllowPartiallyTrustedCallersAttribute>.|Les classes dérivées ne peuvent pas être marquées avec l'objet <xref:System.Security.SecurityCriticalAttribute>. Auparavant, les types dérivés devaient être marqués avec l'objet <xref:System.Security.SecurityCriticalAttribute>. Toutefois, cette modification ne doit pas avoir d'impact réel.|  
|Types et membres WF 3.0|Les types et les membres de WF 3.0 sont désormais marqués comme obsolètes.|Une tentative de compilation d'un code source qui utilise des membres ou des types WF 3.0 génère une erreur du compilateur. Vous devez utiliser les types et membres WF 4 dans les espaces de noms <xref:System.Activities>.|  
|Classe <xref:System.Activities.Presentation.DragDropHelper?displayProperty=fullName>|La classe <xref:System.Activities.Presentation.DragDropHelper> inclut de nouvelles méthodes qui prennent en charge les opérations glisser\-déplacer avec plusieurs objets. Les méthodes glisser\-déplacer existantes qui prennent en charge le déplacement d'un seul objet sont obsolètes. \(Pour plus d'informations, consultez [Éléments obsolètes dans la bibliothèque de classes](../../../docs/framework/whats-new/whats-obsolete.md).\)|Bien que les anciennes méthodes aient été déconseillées, elles continuent d'être prises en charge par le compilateur et le Common Langage Runtime. Toutefois, les nouvelles méthodes offrent des fonctionnalités supérieures. Les méthodes recommandées pour remplacer certaines méthodes existantes sont les suivantes :<br /><br /> Utilisez <xref:System.Activities.Presentation.DragDropHelper.DoDragMove%28System.Activities.Presentation.WorkflowViewElement%2CSystem.Windows.Point%29?displayProperty=fullName> à la place de <xref:System.Activities.Presentation.DragDropHelper.DoDragMove%28System.Activities.Presentation.WorkflowViewElement%2CSystem.Windows.Point%29?displayProperty=fullName>.<br /><br /> Utilisez <xref:System.Activities.Presentation.DragDropHelper.GetCompositeView%28System.Activities.Presentation.WorkflowViewElement%29> à la place de <xref:System.Activities.Presentation.DragDropHelper.GetCompositeView%28System.Windows.DragEventArgs%29>.<br /><br /> Utilisez <xref:System.Activities.Presentation.DragDropHelper.GetDraggedModelItems%28System.Windows.DragEventArgs%29> à la place de <xref:System.Activities.Presentation.DragDropHelper.GetDraggedModelItem%28System.Windows.DragEventArgs%29>.<br /><br /> Utilisez <xref:System.Activities.Presentation.DragDropHelper.GetDroppedObjects%28System.Windows.DependencyObject%2CSystem.Windows.DragEventArgs%2CSystem.Activities.Presentation.EditingContext%29> à la place de <xref:System.Activities.Presentation.DragDropHelper.GetDroppedObject%28System.Windows.DependencyObject%2CSystem.Windows.DragEventArgs%2CSystem.Activities.Presentation.EditingContext%29>.|  
|Résolution de surcharge des appels à la méthode <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName>|[!INCLUDE[net_v45](../../../includes/net-v45-md.md)] ajoute de nouvelles surcharges qui incluent un paramètre de type <xref:System.Action?displayProperty=fullName>. Lorsque le code existant est recompilé, les compilateurs peuvent résoudre les appels aux méthodes <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName> dotées d'un paramètre <xref:System.Delegate> comme des appels aux méthodes <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName> avec un paramètre <xref:System.Action?displayProperty=fullName>.|Si un appel à une surcharge <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName> avec un paramètre <xref:System.Delegate> est résolu comme un appel à une surcharge <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName> avec un paramètre <xref:System.Action?displayProperty=fullName>, les différences de comportement suivantes peuvent survenir :<br /><br /> Si une exception se produit, les événements <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter?displayProperty=fullName> et <xref:System.Windows.Threading.Dispatcher.UnhandledException?displayProperty=fullName> ne sont pas déclenchés. À la place, les exceptions sont gérées par l'événement <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException>.<br /><br /> Les appels à certains membres, tels que <xref:System.Windows.Threading.DispatcherOperation.Result%2A?displayProperty=fullName>, sont bloqués jusqu'à ce que l'opération soit terminée.|  
|Classe <xref:System.Activities.Expressions.Literal%601?displayProperty=fullName>|L'objet <xref:System.Windows.Markup.ValueSerializer> associé convertira un objet <xref:System.DateTime> ou <xref:System.DateTimeOffset> dont les composants `Second` et `Millisecond` ne sont pas nuls et \(pour une valeur <xref:System.DateTime>\) dont la propriété <xref:System.DateTime.Kind%2A?displayProperty=fullName> n'est pas <xref:System.DateTimeKind> en une syntaxe d'élément de propriété au lieu d'une chaîne.|Cette modification permet aux valeurs <xref:System.DateTime> et <xref:System.DateTimeOffset> de faire l'objet d'un aller\-retour. Les analyseurs XAML personnalisés qui supposent que l'entrée XAML figure dans la syntaxe d'attribut ne fonctionnent pas correctement.|  
  
<a name="xml"></a>   
## XML, XSLT  
  
|Fonctionnalité|Modification|Impact|  
|--------------------|------------------|------------|  
|Méthode `XDocument.Validate`|Si la valeur <xref:System.Xml.Linq.LoadOptions?displayProperty=fullName> est passée à la méthode <xref:System.Xml.Linq.XDocument.Load%2A> et qu'une erreur de validation se produit, les propriétés <xref:System.Xml.Schema.XmlSchemaException.LineNumber%2A?displayProperty=fullName> et <xref:System.Xml.Schema.XmlSchemaException.LinePosition%2A?displayProperty=fullName> contiennent désormais les informations de ligne.|Le code de gestion des exceptions qui dépend des valeurs des propriétés <xref:System.Xml.Schema.XmlSchemaException.LineNumber%2A?displayProperty=fullName> et <xref:System.Xml.Schema.XmlSchemaException.LinePosition%2A?displayProperty=fullName> ne fonctionnera plus.|  
|Chargement des fichiers XML avec <xref:System.Xml.XmlTextReader?displayProperty=fullName>|L'extension d'entité DTD est limitée à 10 000 000 caractères.|Le chargement des fichiers XML sans extension d'entité DTD ou avec une extension d'entité DTD limitée reste inchangé. Les fichiers avec des entités DTD qui s'étendent à plus de 10 000 000 caractères ne se chargent pas et lèvent désormais une exception.|  
|Mode de compatibilité ascendante pour la classe <xref:System.Xml.Xsl.XslCompiledTransform?displayProperty=fullName>|Dans [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], la compatibilité ascendante XSLT 1.0 présentait les problèmes suivants :<br /><br /> Le chargement d'une feuille de style échouait si sa version avait la valeur 2.0 et si l'analyseur rencontrait une construction XSLT 1.0 non reconnue.<br /><br /> La construction `xsl:sort` ne pouvait pas trier les données si la version de la feuille de style était définie sur 1.1.<br /><br /> Dans [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], ces problèmes ont été résolus et le mode de compatibilité ascendante XSLT 1.0 fonctionne correctement.|Le mode de compatibilité ascendante XSLT 1.0 fonctionne désormais comme auparavant.|  
|Messages d'exception lorsqu'un fichier XSLT est trop complexe|Dans [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], lorsqu'un fichier XSLT est trop complexe, le texte du message d'erreur est le suivant : « La feuille de style est trop complexe. ». Dans les versions antérieures, le message d'erreur était « Erreur de compilation XSLT. ».|Le code d'application qui dépend du texte du message d'erreur ne fonctionne plus. Toutefois, comme les types d'exception restent les mêmes, cette modification ne doit pas avoir d'impact réel.|  
|Validation de schéma XML pour xsd:anyURI|Dans [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], la validation de schéma XML est plus stricte. Si vous utilisez xsd:anyURI pour valider un URI tel qu'un protocole mailto, la validation échoue si l'URI contient des espaces. Dans les versions antérieures du .NET Framework, la validation réussissait.|La modification affecte uniquement les applications qui ciblent [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|  
  
## Voir aussi  
 [Éléments obsolètes dans la bibliothèque de classes](../../../docs/framework/whats-new/whats-obsolete.md)   
 [Nouveautés](../../../docs/framework/whats-new/index.md)   
 [Compatibilité des applications](../../../docs/framework/migration-guide/application-compatibility.md)   
 [Compatibilité des applications dans la version 4.5.1](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5-1.md)   
 [Compatibilité des applications dans la version 4.5.2](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5-2.md)