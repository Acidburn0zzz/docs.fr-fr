---
title: "Arborescences dans WPF | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-wpf"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "arborescence des éléments"
  - "arborescence logique"
  - "arborescence d'éléments visuels"
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
caps.latest.revision: 20
author: "dotnet-bot"
ms.author: "dotnetcontent"
manager: "wpickett"
caps.handback.revision: 19
---
# Arborescences dans WPF
Dans plusieurs technologies, les éléments et les composants sont organisés en arborescence dans laquelle les développeurs manipulent directement les nœuds d'objet dans l'arborescence pour modifier le rendu ou le  comportement d'une application.  [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] utilise également plusieurs métaphores d'arborescence pour définir des relations entre les éléments d'un programme.  Dans la plupart des cas, les développeurs WPF peuvent créer une application dans le code ou définir des parties de l'application en XAML en pensant conceptuellement à la métaphore de l'arborescence d'objets, mais en appelant l'API spécifique ou en utilisant un balisage spécifique pour ce faire, plutôt que des API de manipulation d'arborescence d'objets générales comme vous pouvez en utiliser en DOM XML.  WPF expose deux classes de programme d'assistance qui fournissent une vue métaphorique de l'arborescence, <xref:System.Windows.LogicalTreeHelper> et <xref:System.Windows.Media.VisualTreeHelper>.  Les termes arborescence des éléments visuels et arborescence logique sont également utilisés dans la documentation WPF parce qu'ils sont utiles pour comprendre le fonctionnement de certaines fonctionnalités WPF clés.  Cette rubrique définit ce que l'arborescence d'éléments visuels et l'arborescence logique représentent, explique la relation de ces arborescences avec le concept général d'arborescence d'objets et présente <xref:System.Windows.LogicalTreeHelper> et <xref:System.Windows.Media.VisualTreeHelper>.  
  
   
  
<a name="element_tree"></a>   
## Arborescences dans WPF  
 L'arborescence la plus complète de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] est l'arborescence d'objets.  Si vous définissez une page d'application en [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], puis chargez le [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], l'arborescence est créée sur la base des relations d'imbrication des éléments dans les balises.  Si vous définissez une application ou une portion d'application dans le code, l'arborescence est créée en fonction de la manière dont vous affectez les valeurs de propriété aux propriétés qui implémentent le modèle de contenu d'un objet donné.  Dans [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], l'arborescence d'objets complète est conceptualisée et peut être rapportée à son API publique de deux manières : en tant qu'arborescence logique et en tant qu'arborescence d'éléments visuels.  Les distinctions entre arborescence logique et arborescence visuelle ne sont pas toujours nécessairement importantes, mais elles peuvent générer parfois des problèmes avec certains sous\-systèmes [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] et affecter vos choix en terme de balisage ou de code.  
  
 Bien que vous ne manipuliez pas toujours directement l'arborescence logique ou l'arborescence d'éléments visuels, la compréhension des concepts d'interaction des arborescences permet de comprendre le fonctionnement de WPF en tant que technologie.  Considérer WPF sous l'angle d'une métaphore d'arborescence est également crucial pour comprendre le fonctionnement de l'héritage des propriétés et du routage des événements dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
> [!NOTE]
>  L'arborescence d'objets étant plus un concept qu'une API réelle, une autre manière d'appréhender le concept consiste à la considérer comme un graphique d'objet.  En pratique, il existe des relations entre les objets au moment de l'exécution au niveau desquelles la métaphore de l'arborescence ne sera pas appropriée.  Néanmoins, en particulier avec une interface utilisateur définie en XAML, la métaphore de l'arborescence est suffisamment pertinente pour que la plupart de la documentation WPF utilise le terme d'arborescence d'objets pour faire référence à ce concept général.  
  
<a name="logical_tree"></a>   
## L'arborescence logique  
 Dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], vous ajoutez le contenu aux éléments d'interface en définissant les propriétés des objets qui stockent ces éléments.  Par exemple, vous ajoutez des éléments à un contrôle <xref:System.Windows.Controls.ListBox> en manipulant sa propriété <xref:System.Windows.Controls.ItemsControl.Items%2A>.  Ainsi, vous placez des éléments dans la <xref:System.Windows.Controls.ItemCollection> qui est la valeur de la propriété <xref:System.Windows.Controls.ItemsControl.Items%2A>.  De la même façon, pour ajouter des objets à un <xref:System.Windows.Controls.Panel.Children%2A>, vous manipulez sa valeur de propriété <xref:System.Windows.Controls.DockPanel>.  Ici, vous ajoutez des objets à la <xref:System.Windows.Controls.UIElementCollection>.  Pour obtenir un exemple de code, consultez [Add an Element Dynamically](http://msdn.microsoft.com/fr-fr/d00f258a-7973-4de7-bc54-a3fc1f638419).  
  
 En [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], lorsque vous placez des éléments de liste dans une <xref:System.Windows.Controls.ListBox>, ou encore des contrôles ou d'autres éléments d'interface dans un <xref:System.Windows.Controls.DockPanel>, vous utilisez également les propriétés <xref:System.Windows.Controls.ItemsControl.Items%2A> et <xref:System.Windows.Controls.Panel.Children%2A>, soit explicitement soit implicitement, comme dans l'exemple suivant.  
  
 [!code-xml[TreeOvwsSupport#AllCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Si vous aviez voulu traiter ce XAML en tant que XML dans le cadre d'un modèle d'objet de document, et si vous aviez inclus les balises commentées comme étant implicites \(ce qui aurait été légal\), l'arborescence DOM XML obtenue aurait inclus les éléments de `<ListBox.Items>` et les autres éléments implicites.  Or, XAML ne traite pas de cette manière lorsque vous lisez les balises et écrivez dans les objets, et le graphique d'objet obtenu n'inclut pas littéralement `ListBox.Items`.  Il comporte en revanche une propriété <xref:System.Windows.Controls.ListBox> nommée `Items` qui contient une <xref:System.Windows.Controls.ItemCollection>, et cette <xref:System.Windows.Controls.ItemCollection> est initialisée mais vide lorsque le XAML <xref:System.Windows.Controls.ListBox> est traité.  Ensuite, chaque élément d'objet enfant qui existe comme contenu pour la <xref:System.Windows.Controls.ListBox> est ajouté à la <xref:System.Windows.Controls.ItemCollection> par les appels de l'analyseur à `ItemCollection.Add`.  Cet exemple du traitement de XAML dans une arborescence d'objets constitue un exemple dans lequel l'arborescence d'objets créée correspond en principe à l'arborescence logique.  
  
 Toutefois, l'arborescence logique n'est pas le graphique d'objet complet qui existe pour votre interface utilisateur d'application au moment de l'exécution, même si les éléments de syntaxe XAML explicite sont factorisés.   Ceci est principalement dû aux visuels et aux modèles.  Intéressons\-nous par exemple au <xref:System.Windows.Controls.Button>.  L'arborescence logique signale l'objet <xref:System.Windows.Controls.Button> et également sa chaîne `Content`.  Toutefois, l'arborescence d'objets au moment de l'exécution contient d'autres éléments pour ce bouton.  Plus particulièrement, le bouton s'affiche à l'écran de cette manière parce qu'un modèle de contrôle <xref:System.Windows.Controls.Button> spécifique a été appliqué.  Les visuels issus d'un modèle appliqué \(tels que la <xref:System.Windows.Controls.Border> gris sombre définie par le modèle autour du bouton visuel\) ne sont pas signalés dans l'arborescence logique, même si vous regardez l'arborescence logique au moment de l'exécution \(notamment la gestion d'un événement d'entrée de l'interface utilisateur visible suivie de la lecture de l'arborescence logique\).  Pour rechercher les visuels du modèle, vous devez à la place examiner l'arborescence d'éléments visuels.  
  
 Pour plus d'informations sur la correspondance entre la syntaxe [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] et le graphique d'objets créé et sur la syntaxe implicite en XAML, consultez [Syntaxe XAML en détail](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) ou [Vue d'ensemble du langage XAML \(WPF\)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>   
### Fonction de l'arborescence logique  
 L'arborescence logique permet aux modèles de contenu d'itérer aisément au sein de leurs objets enfants possibles et de rendre les modèles de contenu extensibles.  En outre, l'arborescence logique fournit une infrastructure pour certaines notifications, notamment dans le cas où tous les objets de l'arborescence logique sont chargés.  Fondamentalement, l'arborescence logique est une approximation d'un graphique d'objets au moment de l'exécution au niveau de l'infrastructure qui exclut les visuels, mais convient pour bon nombre d'opérations d'interrogation sur la composition de votre propre application d'exécution.  
  
 De plus, les références à des ressources statiques et dynamiques sont résolues en recherchant les collections <xref:System.Windows.FrameworkElement.Resources%2A> en amont dans l'arborescence logique sur l'objet demandeur initial, puis en parcourant l'arborescence logique et en examinant chaque <xref:System.Windows.FrameworkElement> \(ou <xref:System.Windows.FrameworkContentElement>\) à la recherche d'une autre valeur `Resources` contenant un <xref:System.Windows.ResourceDictionary>, et contenant éventuellement cette clé.  L'arborescence logique est utilisée pour rechercher des ressources lorsque l'arborescence logique et l'arborescence visuelle sont présentes.  Pour plus d'informations sur les dictionnaires de ressources et la recherche, consultez [Ressources XAML](../../../../docs/framework/wpf/advanced/xaml-resources.md).  
  
<a name="composition"></a>   
### Composition de l'arborescence logique  
 L'arborescence logique est défini au [niveau de l'infrastructure WPF](GTMT), ce qui signifie que l'élément de base WPF le plus pertinent pour les opérations d'arborescence logique est soit <xref:System.Windows.FrameworkElement>, soit <xref:System.Windows.FrameworkContentElement>.  Toutefois, comme vous pouvez le voir si vous utilisez réellement l'API de <xref:System.Windows.LogicalTreeHelper>, l'arborescence logique contient parfois des nœuds qui ne sont ni <xref:System.Windows.FrameworkElement>, ni <xref:System.Windows.FrameworkContentElement>.  Par exemple, l'arborescence logique signale la valeur <xref:System.Windows.Controls.TextBlock.Text%2A> d'un <xref:System.Windows.Controls.TextBlock>, qui est une chaîne.  
  
<a name="override_logical_tree"></a>   
### Remplacement de l'arborescence logique  
 Les auteurs de contrôle avancés peuvent remplacer l'arborescence logique en remplaçant plusieurs [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] qui définissent la manière dont un objet général ou un modèle de contenu ajoute ou supprime des objets dans l'arborescence logique.  Pour un exemple de remplacement de l'arborescence logique, consultez [Remplacer l'arborescence logique](../../../../docs/framework/wpf/advanced/how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>   
### Héritage de la valeur de propriété  
 L'héritage de valeur de propriété fonctionne à travers une arborescence hybride.  Les métadonnées qui contiennent la propriété <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> qui active l'héritage de propriété sont la classe[au niveau d'infrastructure WPF T:System.Windows.FrameworkPropertyMetadata](GTMT).  Par conséquent, le parent qui contient la valeur d'origine et l'objet enfant qui hérite de cette valeur doivent correspondre tous les deux à un <xref:System.Windows.FrameworkElement> ou un <xref:System.Windows.FrameworkContentElement>, et ces deux éléments doivent faire partie d'une arborescence logique.  Toutefois, pour les propriétés WPF existantes qui prennent en charge l'héritage des propriétés, l'héritage des valeurs de propriété peut avoir lieu par le biais d'un objet intervenant ne figurant pas dans l'arborescence logique.  Principalement, cela est pertinent pour que les éléments de modèle utilisent des valeurs de propriété héritées définies soit sur l'instance utilisée comme modèle, soit à des niveaux supérieurs de la composition de niveau page situés par conséquent plus haut dans l'arborescence logique.  Pour que l'héritage de valeurs de propriété s'effectue de manière cohérente malgré cette limite, la propriété d'héritage doit être enregistrée en tant que propriété jointe et vous devez suivre ce modèle si vous envisagez de définir une propriété de dépendance personnalisée avec un comportement d'héritage de propriétés.  L'arborescence exacte utilisée pour l'héritage de propriété ne peut pas être entièrement anticipée par une méthode d'utilitaire de classe d'assistance, même au moment de l'exécution.  Pour plus d'informations, consultez [Héritage de la valeur de propriété](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).  
  
<a name="two_trees"></a>   
## L'arborescence visuelle  
 Outre le concept de l'arborescence logique, il existe le concept d'[arborescence visuelle](GTMT) dans [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  L'arborescence d'éléments visuels décrit la structure des objets visuels, tels qu'ils sont représentés par la classe de base <xref:System.Windows.Media.Visual>.  Lorsque vous écrivez un modèle pour un contrôle, vous définissez ou redéfinissez l'arborescence visuelle qui s'applique à ce contrôle.  L'arborescence visuelle offre également un intérêt pour les développeurs qui veulent disposer d'un contrôle de niveau inférieur pour améliorer les performances et garantir l'optimisation.  Un problème lié à l'arborescence d'éléments visuels dans le cadre de la programmation d'application [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classique réside dans le fait que les routes d'un [événement](GTMT) passent principalement par l'arborescence d'éléments visuels et non pas par l'arborescence logique.  Cette subtilité de comportement d'événement routé peut ne pas être immédiatement évidente si vous n'êtes pas auteur de contrôle.  Le routage des événements via l'arborescence d'éléments visuels permet aux contrôles qui implémentent la composition au niveau visuel de gérer les événements ou de créer des méthodes setter d'événement.  
  
<a name="trees_content"></a>   
## Arborescences, éléments de contenu et hôtes de contenu  
 Les éléments de contenu \(classes qui dérivent de <xref:System.Windows.ContentElement>\) ne font pas partie de l'arborescence visuelle ; ils n'héritent pas de <xref:System.Windows.Media.Visual> et n'ont pas de représentation visuelle.  Pour apparaître dans une interface utilisateur, un <xref:System.Windows.ContentElement> doit être hébergé dans un hôte de contenu qui est à la fois un <xref:System.Windows.Media.Visual> et un élément d'arborescence logique.  Habituellement, un tel objet est un <xref:System.Windows.FrameworkElement>.  Vous pouvez considérer que l'hôte de contenu ressemble à "navigateur" pour le contenu et choisit le mode d'affichage du contenu dans la zone d'écran que l'hôte contrôle.  Lorsque le contenu est hébergé, il peut devenir un participant dans les certains processus d'arborescence associés normalement à l'arborescence visuelle.  En général, la classe hôte <xref:System.Windows.FrameworkElement> inclut le code d'implémentation qui ajoute tout <xref:System.Windows.ContentElement> hébergé à la route d'événement via des sous\-nœuds de l'arborescence logique de contenu bien que le contenu hébergé ne fasse pas partie de l'arborescence visuelle logique réelle.  Vous devez procéder ainsi pour qu'une <xref:System.Windows.ContentElement> puisse fournir la source d'un événement routé qui route vers tout autre élément que lui\-même.  
  
<a name="tree_traversal"></a>   
## Parcours d'une arborescence  
 La classe <xref:System.Windows.LogicalTreeHelper> fournit les méthodes <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A> et <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> pour parcourir l'arborescence logique.  Dans la plupart des cas, vous n'avez pas à parcourir l'arborescence logique des contrôles existants, parce que ces contrôles exposent presque toujours leurs éléments enfants logiques sous la forme d'une propriété de collection dédiée qui prend en charge l'accès à la collection, notamment `Add`, un indexeur, etc.  Le parcours d'arborescence est principalement un scénario utilisé par les auteurs de contrôle qui choisissent de ne pas dériver depuis des modèles de contrôle prévus, tels que <xref:System.Windows.Controls.ItemsControl> ou <xref:System.Windows.Controls.Panel> où les propriétés de collection sont déjà définies, et qui veulent fournir leur propre support de propriété de collection.  
  
 L'arborescence visuelle prend en charge également une classe d'assistance pour le parcours d'arborescence visuelle, <xref:System.Windows.Media.VisualTreeHelper>.  L'arborescence visuelle n'est pas exposée aussi aisément via des propriétés de contrôle. Par conséquent, la classe <xref:System.Windows.Media.VisualTreeHelper> est la méthode recommandée pour parcourir l'arborescence visuelle si cela est nécessaire dans votre scénario de programmation.  Pour plus d'informations, consultez [Vue d'ensemble du rendu graphique de WPF](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
>  Parfois, il est nécessaire d'examiner l'arborescence d'éléments visuels d'un modèle appliqué.  Vous devez être prudent lors de l'utilisation de cette technique.  Même si vous parcourez une arborescence d'éléments visuels d'un contrôle dans laquelle vous définissez le modèle, les utilisateurs de votre contrôle peuvent toujours modifier le modèle en définissant la propriété <xref:System.Windows.Controls.Control.Template%2A> sur les instances, et même l'utilisateur final peut influencer le modèle appliqué en modifiant le thème du système.  
  
<a name="routes"></a>   
## Routes des événements routés sous la forme d'une "arborescence"  
 Comme mentionné précédemment, l'itinéraire de tout événement routé passe par le chemin unique et prédéterminé d'une arborescence hybride composée des représentations de l'arborescence d'éléments visuels et de l'arborescence logique.  Le parcours de l'événement peut s'effectuer vers le haut ou vers le bas dans l'arborescence, selon qu'il s'agit d'un événement routé de tunneling ou de propagation.  Le concept de routage d'événement ne dispose pas d'une classe d'assistance directe qui pourrait être utilisée pour "parcourir" l'itinéraire d'événement indépendant du déclenchement d'un événement qui assure lui\-même le routage.  Il existe une classe qui représente la route, <xref:System.Windows.EventRoute>, mais les méthodes de cette classe sont destinées généralement à une utilisation interne uniquement.  
  
<a name="resourcesandtrees"></a>   
## Dictionnaires de ressources et arborescences  
 La recherche dans le dictionnaire des ressources de toutes les `Resources` définies dans une page se fait généralement via l'arborescence logique.  Les objets qui ne se trouvent pas dans l'arborescence logique peuvent faire référence à des ressources de clé, mais la séquence de recherche de ressources commence au niveau du point à partir duquel l'objet est connecté à l'arborescence logique.  Dans WPF, seuls les nœuds d'arborescence logique peuvent avoir une propriété `Resources` qui contient un <xref:System.Windows.ResourceDictionary> ; par conséquent, parcourir l'arborescence d'éléments visuels pour rechercher des ressources de clé d'un <xref:System.Windows.ResourceDictionary> n'offre aucun avantage.  
  
 Toutefois, la recherche de ressources peut également s'étendre au delà de l'arborescence logique immédiate.  Pour le balisage d'application, la recherche de ressources peut continuer ensuite vers l'avant dans les dictionnaires de ressources au niveau de l'application, puis dans les valeurs de prise en charge de thème et système référencées en tant que clés ou propriétés statiques.  Les thèmes eux\-mêmes peuvent également fait référence à des valeurs système en dehors de l'arborescence logique des thèmes si les références de ressources sont dynamiques.  Pour plus d'informations sur les dictionnaires de ressources et la logique de recherche, consultez [Ressources XAML](../../../../docs/framework/wpf/advanced/xaml-resources.md).  
  
## Voir aussi  
 [Vue d'ensemble des entrées](../../../../docs/framework/wpf/advanced/input-overview.md)   
 [Vue d'ensemble du rendu graphique de WPF](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md)   
 [Vue d'ensemble des événements routés](../../../../docs/framework/wpf/advanced/routed-events-overview.md)   
 [Initialisation d'éléments objet ne figurant pas dans une arborescence d'objets](../../../../docs/framework/wpf/advanced/initialization-for-object-elements-not-in-an-object-tree.md)   
 [Architecture de WPF](../../../../docs/framework/wpf/advanced/wpf-architecture.md)